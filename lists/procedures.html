<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Mesh generator, providing the mesh with tree information.">
    <meta name="author" content="University of Siegen" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; Seeder
</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">Seeder </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                <li class="nav-item"><a class="nav-link" href="../page/index.html">Build and run Seeder</a></li>
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/programs.html">Programs</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr>
                 <td><a href='../proc/alpha.html'>alpha</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficient alpha from the recursive formulation of Legendre polynomials,
for the Legendre mode 'mode'.</p><a href="../proc/alpha.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/alpha_beta.html'>alpha_beta</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) as
needed by the Clenshaw algorithm in ply_split_legendre_matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/alpha_frac.html'>alpha_frac</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Quotient of two alpha values.</p><a href="../proc/alpha_frac.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_canondboxtosdrbox.html'>append_CanoNDBoxToSdrBox</a></td>
                 <td><a href='../module/sdr_canonicalnd_module.html'>sdr_canonicalND_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine convert plane to triangle and add triangle to 
growing array and add position of triangle into 
spatialObj%primitive_position</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_canondboxtotriangle.html'>append_CanoNDBoxToTriangle</a></td>
                 <td><a href='../module/sdr_canonicalnd_module.html'>sdr_canonicalND_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine convert box to planes and then planes to triangles
and add triangle to growing array and add position of triangle into 
spatialObj%primitive_position</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_canondlinetosdrline.html'>append_CanoNDLineToSdrLine</a></td>
                 <td><a href='../module/sdr_canonicalnd_module.html'>sdr_canonicalND_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine convert canonical line to seeder line array</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_canondplanetotriangle.html'>append_CanoNDPlaneToTriangle</a></td>
                 <td><a href='../module/sdr_canonicalnd_module.html'>sdr_canonicalND_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine convert plane to triangle and add triangle to 
growing array and add position of triangle into 
spatialObj%primitive_position</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_canondpointtosdrpoint.html'>append_CanoNDPointToSdrPoint</a></td>
                 <td><a href='../module/sdr_canonicalnd_module.html'>sdr_canonicalND_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine convert canonical point to seeder point array</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_cylinder2spaobj.html'>append_cylinder2SpaObj</a></td>
                 <td><a href='../module/sdr_cylinder_module.html'>sdr_cylinder_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine single cylinder from object table</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=).html'>assignment(=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~2.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~3.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~4.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~5.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~6.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~7.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/beta.html'>beta</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficient beta from the recursive formulation of Legendre polynomials,
 for the Legendre mode 'mode'.</p><a href="../proc/beta.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_bndlevel.html'>check_bndLevel</a></td>
                 <td><a href='../module/sdr_refinept_module.html'>sdr_refinePT_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine checks if neighbor node with intersected boundary is level 
higher than current node level.</p><a href="../proc/check_bndlevel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_fpt.html'>Copy_fpt</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_fpt_header.html'>Copy_fpt_header</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Copy the FPT header information.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_fxt_header.html'>Copy_fxt_header</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_l2p_header.html'>Copy_l2p_header</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_nodes_header.html'>Copy_nodes_header</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_ply_l2p.html'>Copy_ply_l2p</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_poly_proj_header.html'>Copy_poly_proj_header</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/create_children.html'>create_children</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine creates children for each parent if children
 intersect with boundary object.</p><a href="../proc/create_children.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/create_children~2.html'>create_children</a></td>
                 <td><a href='../module/sdr_refinept_module.html'>sdr_refinePT_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine append 8 children to protoTree and inherit property bits from 
parent. leaf bit is removed from parent.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/create_target.html'>create_target</a></td>
                 <td><a href='../module/sdr_proto2treelm_module.html'>sdr_proto2treelm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create an element with subelement resolution.</p><a href="../proc/create_target.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/flood_parents.html'>flood_parents</a></td>
                 <td><a href='../module/sdr_flooding_module.html'>sdr_flooding_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Mark all virtual nodes, which contain a flooded child as flooded
starting from the second finest level moving up to the root.
This allows to easily avoid non-flooded domains later on.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/flood_periphery.html'>flood_periphery</a></td>
                 <td><a href='../module/sdr_flooding_module.html'>sdr_flooding_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loops over all intersected with geoemtry nodes and fluidify
 some node according to the following rule:\n
 1. one of its link does noe intersect with any geometry that requires qVal
 2. it has fluid neighbor on that direction.
    i.e. it is wet in that side.
 Jiaxing Qi</p><a href="../proc/flood_periphery.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/flood_periphery_diagonal.html'>flood_periphery_diagonal</a></td>
                 <td><a href='../module/sdr_flooding_module.html'>sdr_flooding_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine checks for qVal of the periphery and floods if qVal &lt; 0 and
the node in that direction is fluid and not intersected by boundary</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/floodwaves_tree.html'>floodwaves_tree</a></td>
                 <td><a href='../module/sdr_flooding_module.html'>sdr_flooding_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loop over all nodes are flood non-interesting leaf node with
wet face and inherit the wetness of the virtual node to the eligble
childrens</p><a href="../proc/floodwaves_tree.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_sampled_element.html'>get_sampled_element</a></td>
                 <td><a href='../module/ply_sampling_adaptive_module.html'>ply_sampling_adaptive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get sampled data.</p><a href="../proc/get_sampled_element.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getbcid_and_calcqval.html'>getBCID_and_calcQval</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine gets minBCID of the given node position in the protoTree.
 If the minBcid is periodic then it bcID is set to treeID of fluid node
 on the opposite side of periodic plane.
 It also computes the qVal if calc_dist = true. If qVal = -1 then
 there is no intersection and if qVal &gt; 1 then the geometry is intersected
 after the link distance.</p><a href="../proc/getbcid_and_calcqval.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getnormal.html'>getNormal</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Obtain the surface normal of the chosen boundary if the boundary has
<code>store_normal</code> set. Otherwise a null vector is returned.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/gettreeidposofcoord.html'>getTreeIDPosOfCoord</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns the position of treeID of given coordReal in the
the given mesh
Start from minLevel which is the level of neighbor and find the treeID
which is a leaf in protoTree</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/inherit_intersectedobject.html'>inHerit_intersectedObject</a></td>
                 <td><a href='../module/sdr_refinept_module.html'>sdr_refinePT_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine inherit the intersected boundary objects from parent to
childrens</p><a href="../proc/inherit_intersectedobject.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/is_intersecting.html'>is_intersecting</a></td>
                 <td><a href='../module/sdr_geometry_module.html'>sdr_geometry_module</a></td>
                 <td>Function</td>
                 <td><p>Test the intersection between the given cube and the object specified by
obj_pos.</p><a href="../proc/is_intersecting.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal.html'>isEqual</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two projections.</p><a href="../proc/isequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~2.html'>isEqual</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two projections.</p><a href="../proc/isequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~3.html'>isEqual</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of the header for two
projections.</p><a href="../proc/isequal~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~4.html'>isEqual</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~5.html'>isEqual</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two projections.</p><a href="../proc/isequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater.html'>isGreater</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of two projections.</p><a href="../proc/isgreater.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~2.html'>isGreater</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of two projections.</p><a href="../proc/isgreater~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~3.html'>isGreater</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of the header of two projections.</p><a href="../proc/isgreater~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~4.html'>isGreater</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~5.html'>isGreater</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of two projections.</p><a href="../proc/isgreater~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two projections.</p><a href="../proc/isgreaterorequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~2.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two projections.</p><a href="../proc/isgreaterorequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~3.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of the header of two projections.</p><a href="../proc/isgreaterorequal~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~4.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~5.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two projections.</p><a href="../proc/isgreaterorequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller.html'>isSmaller</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two projections.</p><a href="../proc/issmaller.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~2.html'>isSmaller</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two projections.</p><a href="../proc/issmaller~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~3.html'>isSmaller</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of the header of two projections.</p><a href="../proc/issmaller~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~4.html'>isSmaller</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~5.html'>isSmaller</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two projections.</p><a href="../proc/issmaller~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two projections.</p><a href="../proc/issmallerorequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~2.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two projections.</p><a href="../proc/issmallerorequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~3.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of the header of two projections.</p><a href="../proc/issmallerorequal~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~4.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~5.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two projections.</p><a href="../proc/issmallerorequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal.html'>isUnequal</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two projections.</p><a href="../proc/isunequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~2.html'>isUnequal</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two projections.</p><a href="../proc/isunequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~3.html'>isUnequal</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of the header of two
projections.</p><a href="../proc/isunequal~3.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~4.html'>isUnequal</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~5.html'>isUnequal</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two projections.</p><a href="../proc/isunequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_single_fill.html'>load_single_fill</a></td>
                 <td><a href='../module/sdr_subres_fills_module.html'>sdr_subres_fills_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the value fill definition for a single color.</p><a href="../proc/load_single_fill.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mark_leafnode.html'>mark_leafNode</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Small helping routine to keep track of leaf nodes.</p><a href="../proc/mark_leafnode.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/needcalcqvalbybcid.html'>needCalcQValByBCID</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>This routine checks if a boundary need calc qVal for a given BCID
It is used in identify_boundary routine</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/needflddglbybcid.html'>needFldDglByBCID</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>This routine checks if a boundary need flood periphery for diagonal
directions for a given BCID.
It is used in identify_boundary routine</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=).html'>operator(/=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~2.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~3.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~4.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~5.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt).html'>operator(<)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~2.html'>operator(<)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~3.html'>operator(<)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~4.html'>operator(<)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~5.html'>operator(<)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=).html'>operator(<=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~2.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~3.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~4.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~5.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==).html'>operator(==)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~2.html'>operator(==)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~3.html'>operator(==)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~4.html'>operator(==)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~5.html'>operator(==)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt).html'>operator(>)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~2.html'>operator(>)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~3.html'>operator(>)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~4.html'>operator(>)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~5.html'>operator(>)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=).html'>operator(>=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~2.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~3.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~4.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~5.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_alpha.html'>ply_alpha</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficients from the recursive formulation of legendre polynomials.
L_n = alpha * x * L_n-1 + beta * L_n-2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_alpha_beta.html'>ply_alpha_beta</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_alpha_frac.html'>ply_alpha_frac</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Quotient of two alpha values.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_beta.html'>ply_beta</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficients from the recursive formulation of legendre polynomials.
L_n = alpha * x * L_n-1 + beta * L_n-2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_doftoqpoly.html'>ply_dofToQPoly</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to convert linearized dof index to ansatz function number for
Q-Polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_element_load.html'>ply_filter_element_load</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Loading parameters for the filtering from the configuration script.
This needs to be performed before any call of the actual transformation
<a href="../proc/ply_split_element_1d.html">ply_split_element_1D</a>.</p><a href="../proc/ply_filter_element_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_element_oddfract.html'>ply_filter_element_oddfract</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter a polynomial representation in elements in one dimension according
to its odd mode fraction.</p><a href="../proc/ply_filter_element_oddfract.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_oddfract_1d.html'>ply_filter_oddfract_1D</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter one-dimensional elements of degree element_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_oddfract_2d.html'>ply_filter_oddfract_2D</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter two-dimensional elements of degree element_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_oddfract_3d.html'>ply_filter_oddfract_3D</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter three-dimensional elements of degree element_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_define.html'>ply_fpt_header_define</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Define settings for the Fast Polynomial Transformation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_display.html'>ply_fpt_header_display</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Print the FPT settings to the log output.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_load.html'>ply_fpt_header_load</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the FPT configuration options from the provided Lua script in
<code>conf</code>.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_out.html'>ply_fpt_header_out</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write FPT settings into a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_fptm2n.html'>ply_fptm2n</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_fptn2m.html'>ply_fptn2m</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_header_display.html'>ply_fxt_header_display</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_header_load.html'>ply_fxt_header_load</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p><a href="../proc/ply_fxt_header_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_header_out.html'>ply_fxt_header_out</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write FXT settings into a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_m2n_1d.html'>ply_fxt_m2n_1D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert modal data to nodal data in 1D using flpt.</p><a href="../proc/ply_fxt_m2n_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_m2n_2d.html'>ply_fxt_m2n_2D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert modal data to nodal data in 2D using flpt.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_m2n_3d.html'>ply_fxt_m2n_3D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert modal data to nodal data in 3D using flpt.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_n2m_1d.html'>ply_fxt_n2m_1D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert nodal data to modal data using flpt.</p><a href="../proc/ply_fxt_n2m_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_n2m_2d.html'>ply_fxt_n2m_2D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_n2m_3d.html'>ply_fxt_n2m_3D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_gauleg.html'>ply_gauleg</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to create gauss points and weights for one-dimensional
integration on the interval [x1,x2].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_gausslegpoints.html'>ply_gaussLegPoints</a></td>
                 <td><a href='../module/ply_space_integration_module.html'>ply_space_integration_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create Gauss-Legendre integration points and weights for one-dimensional
integration on the interval [x1,x2].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_fxt.html'>ply_init_fxt</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the flpt data structure for fast legendre polynomial
transformation via the fxtpack.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_l2p.html'>ply_init_l2p</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the transformations via L2 projections.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_legfpt.html'>ply_init_legFpt</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to initialize the fast polynomial transformation
 for Legendre expansion.</p><a href="../proc/ply_init_legfpt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_initqlegprojcoeff.html'>ply_initQLegProjCoeff</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize the projection coefficients for a usage in the
subsampling routine to project degrees of freedoms of a parent cell
to the degrees of freedoms of a child cell if the degrees of
freedoms are Q-Legendre polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2_projection.html'>ply_l2_projection</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Actual implementation of the matrix operation to change between nodal
and modal representations.</p><a href="../proc/ply_l2_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_define.html'>ply_l2p_header_define</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_display.html'>ply_l2p_header_display</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_load.html'>ply_l2p_header_load</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_out.html'>ply_l2p_header_out</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write L2P settings into a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_trafo_1d.html'>ply_l2p_trafo_1D</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transformation between modal and nodal values in 1D via L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_trafo_2d.html'>ply_l2p_trafo_2D</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transformation between modal and nodal values in 2D via L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_trafo_3d.html'>ply_l2p_trafo_3D</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transformation between modal and nodal values in 3D via L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_1d.html'>ply_lagrange_1D</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_define.html'>ply_lagrange_define</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td><p>Define a new polynomial in the Lagrange basis.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_eval.html'>ply_lagrange_eval</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td><p>Evaluate a polynomial in the Lagrange basis at some point x.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_mode_at.html'>ply_lagrange_mode_at</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td><p>Evaluate the given Lagrangian mode (which is 1 at coord(mode) and 0 in
all other points) at a given point x.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legser.html'>ply_legser</a></td>
                 <td><a href='../module/ply_legser_module.html'>ply_legser_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to convert Chebyshev (A) to Legendre (B) coefficients.</p><a href="../proc/ply_legser.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_lobatto_single.html'>ply_legToPnt_lobatto_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev-Lobatto nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_lobatto_vec.html'>ply_legToPnt_lobatto_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform Legendre expansion to point values
at Chebyshev-Lobatto nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_single.html'>ply_legToPnt_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_vec.html'>ply_legToPnt_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legval.html'>ply_legVal</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Function</td>
                 <td><p>Evaluate a given set of Legendre polynomials a given set of 1D points.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodes_create.html'>ply_nodes_create</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize points with the Chebyshev quadrature points, 3D</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodes_surface_coords.html'>ply_nodes_surface_coords</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create the integration points on the surface of (cubical) elements.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodes_volume_coords.html'>ply_nodes_volume_coords</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create multidimensional points from given 1D set of nodes in the cubic
reference element.</p><a href="../proc/ply_nodes_volume_coords.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodeset_chebyloba.html'>ply_nodeset_chebyloba</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Function</td>
                 <td><p>Generates a given number of Chebyshev-Lobatto points on the unit interval
[-1;+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodeset_chebyshev.html'>ply_nodeset_chebyshev</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Function</td>
                 <td><p>Generates a given number of Chebyshev points on the unit interval [-1;+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_nodeset_coords.html'>ply_nodeset_coords</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodeset_legendre.html'>ply_nodeset_legendre</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Function</td>
                 <td><p>Compute Gauss-Legendre integration points on the interval [-1,1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_lobatto_single.html'>ply_pntToLeg_lobatto_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform point values at Chebyshev-Lobatto nodes to a
Legendre expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_lobatto_vec.html'>ply_pntToLeg_lobatto_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform point values at Chebyshev-Lobatto
nodes to a Legendre expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_single.html'>ply_pntToLeg_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform point values at Chebyshev nodes to a Legendre
expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_vec.html'>ply_pntToLeg_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform point values at Chebyshev nodes to a
Legendre expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_point_tensor.html'>ply_point_tensor</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute a multi-dimensional tensor for the given set of nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_poly_transformation.html'>ply_Poly_Transformation</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of polynomial data from parent elements to child elements.
The projection is done by a direct transformation of the modal
coeffiecients to another coordinate system with z=ax+b.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_prj_header_load.html'>ply_prj_header_load</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_prj_header_out.html'>ply_prj_header_out</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_projdatatochild.html'>ply_projDataToChild</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project element data from a parent cell to its children.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_projdatatochild~2.html'>ply_projDataToChild</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project elemental data from a parent cell to one of
its children.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_qlegonedimcoeff.html'>ply_QLegOneDimCoeff</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to create one-dimensional projection coefficient for a coarse
element to a fine element.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_qlegsqnorm.html'>ply_QLegSqNorm</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Function</td>
                 <td><p>Function to calculate the squared L2-Norm of a given Legendre polynomial
on the reference element [-1,+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_qpolyprojection.html'>ply_QPolyProjection</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subsampling by L2-Projection of the Q-Tensorproduct Legendre polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sample_adaptive.html'>ply_sample_adaptive</a></td>
                 <td><a href='../module/ply_sampling_adaptive_module.html'>ply_sampling_adaptive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Sample data described by varsys in orig_mesh according to the tracking
object trackInst with adaptive refinements.</p><a href="../proc/ply_sample_adaptive.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampled_track_init.html'>ply_sampled_track_init</a></td>
                 <td><a href='../module/ply_sampled_tracking_module.html'>ply_sampled_tracking_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the sampled tracking entities.</p><a href="../proc/ply_sampled_track_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampled_track_output.html'>ply_sampled_track_output</a></td>
                 <td><a href='../module/ply_sampled_tracking_module.html'>ply_sampled_tracking_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Output sampled tracking data.</p><a href="../proc/ply_sampled_track_output.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampled_tracking_load.html'>ply_sampled_tracking_load</a></td>
                 <td><a href='../module/ply_sampled_tracking_module.html'>ply_sampled_tracking_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the configuration of sampled tracking objects.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_adaptive_load.html'>ply_sampling_adaptive_load</a></td>
                 <td><a href='../module/ply_sampling_adaptive_module.html'>ply_sampling_adaptive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the configuration for adaptive subsampling.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_var_allocate.html'>ply_sampling_var_allocate</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Allocate memory for a sampled variable.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_var_compute_elemdev.html'>ply_sampling_var_compute_elemdev</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes for each element whether the solution in it is
considered to be deviating from the mean above the given threshold or
not. The logical result is stored in <code>var%deviates</code> for each element.</p><a href="../proc/ply_sampling_var_compute_elemdev.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_var_move.html'>ply_sampling_var_move</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Move the variable data from source to destination.</p><a href="../proc/ply_sampling_var_move.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_varsys_for_track.html'>ply_sampling_varsys_for_track</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create a variable system for the given tracking instance.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_1d.html'>ply_split_element_1D</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Split one-dimensional elements of degree parent_degree into two elements
with polynomials of degree child_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_1d_test.html'>ply_split_element_1D_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing the 1D splitting.</p><a href="../proc/ply_split_element_1d_test.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_2d.html'>ply_split_element_2D</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Split two-dimensional elements of degree parent_degree into four elements
with polynomials of degree child_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_2d_test.html'>ply_split_element_2D_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing the 2D splitting.</p><a href="../proc/ply_split_element_2d_test.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_3d.html'>ply_split_element_3D</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Split three-dimensional elements of degree parent_degree into eight
elements with polynomials of degree child_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_3d_test.html'>ply_split_element_3D_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing the 3D splitting.</p><a href="../proc/ply_split_element_3d_test.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_init.html'>ply_split_element_init</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the module.
This needs to be performed before any call of the actual transformation
<a href="../proc/ply_split_element_1d.html">ply_split_element_1D</a>.</p><a href="../proc/ply_split_element_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_singled.html'>ply_split_element_singleD</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project a polynomial representation in elements in one dimension to its
 two halves in that direction.</p><a href="../proc/ply_split_element_singled.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_test.html'>ply_split_element_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing routine for the functions of this module.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_legendre_matrix.html'>ply_split_legendre_matrix</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Compute the transformation matrix for a projection to the left and right
 half-interval of Legendre polynomials for the given maximal number of
 modes.</p><a href="../proc/ply_split_legendre_matrix.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_legendre_test.html'>ply_split_legendre_test</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Subroutine</td>
                 <td><p>A small testing routine to check the functions of this module.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subres_get_elemcolor.html'>ply_subres_get_elemcolor</a></td>
                 <td><a href='../module/ply_subresolution_module.html'>ply_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the color of an element.</p><a href="../proc/ply_subres_get_elemcolor.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subres_import_color.html'>ply_subres_import_color</a></td>
                 <td><a href='../module/ply_subresolution_module.html'>ply_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the subresolution data for all elements for a given color and in the
requested format.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subresolution_load.html'>ply_subresolution_load</a></td>
                 <td><a href='../module/ply_subresolution_module.html'>ply_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load subresolution information for a given tree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subsampledata.html'>ply_subsampleData</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subsampledata~2.html'>ply_subsampleData</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to subsample mesh information for one refinement level.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_transform_matrix.html'>ply_transform_matrix</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the transformation matrix for a projection to the left and right
half-interval of Legendre polynomials for the given maximal number of
modes.</p><a href="../proc/ply_transform_matrix.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/projectveconplane.html'>projectVecOnPlane</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>This function project given vector on an given plane</p><a href="../proc/projectveconplane.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/proto2treelm.html'>proto2Treelm</a></td>
                 <td><a href='../module/sdr_proto2treelm_module.html'>sdr_proto2treelm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to convert protoTree to Treelm data format.
append all leaves to the temData%treeID</p><a href="../proc/proto2treelm.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/protodata_ofnode.html'>protoData_ofNode</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Function</td>
                 <td><p>Small helping routine to get the variable data from a leaf.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_addtimers.html'>sdr_addTimers</a></td>
                 <td><a href='../module/sdr_timer_module.html'>sdr_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Setup timers to assess the runtime of various parts of Seeder</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_append_distancerefineobject.html'>sdr_append_distanceRefineObject</a></td>
                 <td><a href='../module/sdr_geometry_module.html'>sdr_geometry_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine created sphere objects and new attribute and extend 
a list of spatial objects if node intersected boundary has distance 
refine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_build_prototree.html'>sdr_build_protoTree</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine builds the preliminary tree with geometry intersection and
neighbor identification</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_color_points.html'>sdr_color_points</a></td>
                 <td><a href='../module/sdr_proto2treelm_module.html'>sdr_proto2treelm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the color at all given points.</p><a href="../proc/sdr_color_points.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_dump_treelm.html'>sdr_dump_treelm</a></td>
                 <td><a href='../module/sdr_proto2treelm_module.html'>sdr_proto2treelm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine dumps the final fluid tree leaves in the disk</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_dumptimers.html'>sdr_dumptimers</a></td>
                 <td><a href='../module/sdr_timer_module.html'>sdr_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Performance results are written to a file for statistical review</p><a href="../proc/sdr_dumptimers.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_find_periodic_neighbor.html'>sdr_find_periodic_neighbor</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine find the treeID on the opposite side neighbor of the
 periodic plane for current leaf node</p><a href="../proc/sdr_find_periodic_neighbor.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_flood_tree.html'>sdr_flood_tree</a></td>
                 <td><a href='../module/sdr_flooding_module.html'>sdr_flooding_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine identifies the nodes, which are supposed to be part of the
computational domain, as defined by the seed objects.</p><a href="../proc/sdr_flood_tree.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_hvs_config_load.html'>sdr_hvs_config_load</a></td>
                 <td><a href='../module/sdr_hvs_config_module.html'>sdr_hvs_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the configuration for the Seeder harvesting from a Lua script.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_hvs_props_clean.html'>sdr_hvs_props_clean</a></td>
                 <td><a href='../module/sdr_hvs_props_module.html'>sdr_hvs_props_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Clean up the properties data type.</p><a href="../proc/sdr_hvs_props_clean.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_hvs_props_import_dofs.html'>sdr_hvs_props_import_dofs</a></td>
                 <td><a href='../module/sdr_hvs_props_module.html'>sdr_hvs_props_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Import subresolved color data.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_hvs_props_load.html'>sdr_hvs_props_load</a></td>
                 <td><a href='../module/sdr_hvs_props_module.html'>sdr_hvs_props_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the properties from the mesh.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_identify_boundary.html'>sdr_identify_boundary</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine checks for boundary neighbors and level of the boundary
node</p><a href="../proc/sdr_identify_boundary.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_inherit_distancerefineobject.html'>sdr_inHerit_distanceRefineObject</a></td>
                 <td><a href='../module/sdr_refinept_module.html'>sdr_refinePT_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines inherit distance refine sphere object from root node
down to leaf node. 
Only the object with level greater than node level are inHerited</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_init_global.html'>sdr_init_global</a></td>
                 <td><a href='../module/sdr_aux_module.html'>sdr_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Prominently let the user now, what he actually is running right now.</p><a href="../proc/sdr_init_global.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_canonicalnd.html'>sdr_load_canonicalND</a></td>
                 <td><a href='../module/sdr_canonicalnd_module.html'>sdr_canonicalND_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads canonical geometrial objects like point, line, plane 
and box and add them to the growing array of each primitive geometries
and the position of this geometries are stored in the growing array
of spatialObject</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_config.html'>sdr_load_config</a></td>
                 <td><a href='../module/sdr_config_module.html'>sdr_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the configuration from the Lua script provided on the command line
or from seeder.lua by default, if no file name is given as program
argument.</p><a href="../proc/sdr_load_config.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_cube.html'>sdr_load_cube</a></td>
                 <td><a href='../module/sdr_cube_module.html'>sdr_cube_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads the boundCube table from config file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_cylinder.html'>sdr_load_cylinder</a></td>
                 <td><a href='../module/sdr_cylinder_module.html'>sdr_cylinder_module</a></td>
                 <td>Subroutine</td>
                 <td><p>\brief Loading cylinder information from config file \n</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_deformation.html'>sdr_load_deformation</a></td>
                 <td><a href='../module/sdr_transformation_module.html'>sdr_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads the deformation table from transformation table</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_ellipsoid.html'>sdr_load_ellipsoid</a></td>
                 <td><a href='../module/sdr_ellipsoid_module.html'>sdr_ellipsoid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load ellipsoid information from config file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_geom_table.html'>sdr_load_geom_table</a></td>
                 <td><a href='../module/sdr_geometry_module.html'>sdr_geometry_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads the geometry table from the config file i.e loading
different geometry kinds like canoND, cube, periodic, STL etc.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_geom_table_single.html'>sdr_load_geom_table_single</a></td>
                 <td><a href='../module/sdr_geometry_module.html'>sdr_geometry_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine reads a single geometry table from the config file i.e 
loading different geometry kinds like canoND, cube, periodic, STL etc.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_geometry.html'>sdr_load_geometry</a></td>
                 <td><a href='../module/sdr_geometry_module.html'>sdr_geometry_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to load spatial object defined in config file and store in 
geometry type</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_inverted.html'>sdr_load_inverted</a></td>
                 <td><a href='../module/sdr_config_module.html'>sdr_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_spatialobject_single.html'>sdr_load_spatialObject_single</a></td>
                 <td><a href='../module/sdr_geometry_module.html'>sdr_geometry_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to load single spatial object table defined in config file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_sphere.html'>sdr_load_sphere</a></td>
                 <td><a href='../module/sdr_sphere_module.html'>sdr_sphere_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load sphere information from config file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_stl.html'>sdr_load_stl</a></td>
                 <td><a href='../module/sdr_stl_module.html'>sdr_stl_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads STL files from config and reads the triangles from the
files into the dynamic array of triangles.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_transformation.html'>sdr_load_transformation</a></td>
                 <td><a href='../module/sdr_transformation_module.html'>sdr_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads the transformation table for each spatial object table
in config file</p><a href="../proc/sdr_load_transformation.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_translation.html'>sdr_load_translation</a></td>
                 <td><a href='../module/sdr_transformation_module.html'>sdr_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads the translation table from transformation table</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_load_triangle.html'>sdr_load_triangle</a></td>
                 <td><a href='../module/sdr_triangle_module.html'>sdr_triangle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load triangle information from config file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_mark_neighborhasbnd.html'>sdr_mark_neighborHasBnd</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine marks 26 direct neighbors as has boundary bit</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_neighbor_in_proto.html'>sdr_neighbor_in_proto</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Function</td>
                 <td><p>Find the neighbor position in protoTree for iDir on the same level 
or on any one above.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_node_neighbors.html'>sdr_node_neighbors</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Function</td>
                 <td><p>This routine identifies the 6 direct neighbors of a node in the prototree</p><a href="../proc/sdr_node_neighbors.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_proto2treelm.html'>sdr_proto2treelm</a></td>
                 <td><a href='../module/sdr_proto2treelm_module.html'>sdr_proto2treelm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine creates the treelmesh from the flooded prototree.</p><a href="../proc/sdr_proto2treelm.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_qvalbynode.html'>sdr_qValByNode</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes the minimum distance of a given link and all the
geometries in a given node:\n
the link is given by a vector and a origin point.\n
the node is given by the node position in the protoTree.\n
If there is no intersection, qVal returns -1.0</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_refine_leaf.html'>sdr_refine_leaf</a></td>
                 <td><a href='../module/sdr_refinept_module.html'>sdr_refinePT_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine extends the protoTree with max of minlevel or level of
refinement object.</p><a href="../proc/sdr_refine_leaf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_smooth_leaf.html'>sdr_smooth_leaf</a></td>
                 <td><a href='../module/sdr_refinept_module.html'>sdr_refinePT_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine smoothens fluid domain with maximum level jumps of 1.</p><a href="../proc/sdr_smooth_leaf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_subres_fills_add.html'>sdr_subres_fills_add</a></td>
                 <td><a href='../module/sdr_subres_fills_module.html'>sdr_subres_fills_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Add a value definition for a color to the list of fillings.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_subres_fills_load.html'>sdr_subres_fills_load</a></td>
                 <td><a href='../module/sdr_subres_fills_module.html'>sdr_subres_fills_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the filling definition for subresolved colors.</p><a href="../proc/sdr_subres_fills_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_subresolution_encolor.html'>sdr_subresolution_encolor</a></td>
                 <td><a href='../module/sdr_subresolution_module.html'>sdr_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Find the value definitions for all unique colors.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_subresolution_load.html'>sdr_subresolution_load</a></td>
                 <td><a href='../module/sdr_subresolution_module.html'>sdr_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Loading the settings for the subresolution in the mesh.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sdr_transformcanond.html'>sdr_transformcanoND</a></td>
                 <td><a href='../module/sdr_transformation_module.html'>sdr_transformation_module</a></td>
                 <td>Interface</td>
                 <td><p>This routine apply transformations to canonical objects</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_truncate_qval.html'>sdr_truncate_qVal</a></td>
                 <td><a href='../module/sdr_boundary_module.html'>sdr_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine gives special treatment when qVal &gt; 1.0 or qVal == -1.0
for flooded neighbor, treat it as normal fluid: clean BCID,
set qVal to -1 (no itersection).
for non-flooded neighbor, treat it as high order wall: set qVal to 1</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sdr_write_proto_as_restart.html'>sdr_write_proto_as_restart</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write current leaves of the prototree as treelm restart.</p><a href="../proc/sdr_write_proto_as_restart.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/subres_load_color_defaults.html'>subres_load_color_defaults</a></td>
                 <td><a href='../module/sdr_subresolution_module.html'>sdr_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Internal subroutine to load the list of colors, which by default should
apply subelement resolution to its boundaries.</p><a href="../proc/subres_load_color_defaults.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/transformcanond.html'>transformCanoND</a></td>
                 <td><a href='../module/sdr_transformation_module.html'>sdr_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine apply transformation to canonical objects.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/transformcanond_single.html'>transformCanoND_single</a></td>
                 <td><a href='../module/sdr_transformation_module.html'>sdr_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine apply transformation to canonical objects.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/traverse_tree.html'>traverse_tree</a></td>
                 <td><a href='../module/sdr_proto2treelm_module.html'>sdr_proto2treelm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursively traverse the tree in a depth first manner to obtain the
the ordering required by treelm.</p><a href="../proc/traverse_tree.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/write_childleaves.html'>write_childLeaves</a></td>
                 <td><a href='../module/sdr_prototree_module.html'>sdr_protoTree_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Small helping routine to write leaves in order into a treelmesh formatted
file.</p></td>
               </tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col">
            <p>
              Seeder
 was developed by University of Siegen<br>              &copy; 2024 
<br /><small>09089c1df7dd</small></p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
 on 2024-11-11T16:20:47.539531             </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>