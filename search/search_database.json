var tipuesearch = {"pages":[{"title":" Seeder ","text":"Seeder Seeder Mesh Generator The goal of Seeder is simple: create an octree mesh out of a given geometry.\nTypically the geometry is given in the form of STL -files.\nAs simple as this goal is the basic idea for the construction of this mesh.\nThe user first has to describe the cubical outline of the mesh, which has to\nenclose the complete geometry.\nThis is referred to as bounding_cube .\nIt is the root node of the octree, from which all elements of the mesh are\nderived by recursive bisection in all three spatial dimensions.\nThe generated mesh will be written to the location provided by the folder setting.\nThis either is simply a prefix to use for all mesh file names or a directory,\nif it is a directory, the string has to include the path-separator at the end,\nand the directory has to exist.\nA third global setting can be used to define a minimial refinement level to\nuse for all elements that will be part of the final mesh.\nThis minlevel setting provides a method to prescribe a minimal resolution\nfor the complete domain, if it is not provided the resolution will only be\ndefined by the geometrical objects you put into the bounding cube.\nSee the fully periodic cube example for a mesh that uses only these three settings. Getting Started Quick Start: Building and Compiling Seeder Treelm Requirements Testsuite : An introduction to the\n    usage of the features of Seeder. You are guided through all required steps\n    to generate meshes with different configurations. Transformations like translation,\n    scaling, reflection and rotation can be applied to all geometric objects. Geometric definitions, have to be given one of the attributes . Attributes are defined by their kind : Boundary Seed Refinement level , that describes\n  the minimal refinement level by which the object should be resolved and some kind specific further values, like a label for boundary\n  conditions For some further internal details see: the overall algorithm . Octree describes the implementation of the\n  Octree data structure in a little more detail. Treelm is a common library that implements the octree mesh\n  handling for the solvers. Aotus is a library that provides the access to Lua scripts as\n  configuration files. License Seeder is licensed under the terms of the 2-clause BSD license reproduced below.\nThis means that Seeder is free software and can be used, reproduced, modified,\ndistributed and redistributed also for commercial purposes under the conditions\nof the BSD license.\nThe only requirement is that some credit to the authors is given by putting this\ncopyright notice somewhere in your project. According to good scientific practice, publications on results achieved in whole\nor in part due to Seeder should cite at least one paper presenting the Seeder\nsoftware. An appropriate reference is: @incollection{harlacher_seeder12,\n   author = {Harlacher, Daniel F. and Hasert, Manuel and Klimach, Harald and Zimny, Simon and Roller, Sabine},\n   affiliation = {German Research School for Simulation Sciences GmbH, and RWTH, Aachen, Germany},\n   title = {Tree Based Voxelization of STL {Data}},\n   booktitle = {High Performance Computing on Vector Systems 2011},\n   editor = {Resch, Michael and Wang, Xin and Bez, Wolfgang and Focht, Erich and Kobayashi, Hiroaki and Roller, Sabine},\n   publisher = {Springer Berlin Heidelberg},\n   pages = {81-92},\n   year = {2012}\n} See each file for respective copyright notices. Redistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Developer Info University of Siegen","tags":"home","url":"index.html"},{"title":"ply_l2p_header_type – Seeder ","text":"type, public :: ply_l2p_header_type l2p projection header type, consisting of the node header which give\ninformation about the type and number of points for the projection Inherits type~~ply_l2p_header_type~~InheritsGraph type~ply_l2p_header_type ply_l2p_header_type type~ply_nodes_header_type ply_nodes_header_type type~ply_l2p_header_type->type~ply_nodes_header_type nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ply_l2p_header_type~~InheritedByGraph type~ply_l2p_header_type ply_l2p_header_type type~ply_prj_header_type ply_prj_header_type type~ply_prj_header_type->type~ply_l2p_header_type l2p_header type~sdr_subresolution_type sdr_subresolution_type type~sdr_subresolution_type->type~ply_prj_header_type project_header type~sdr_confhead_type sdr_confHead_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( ply_nodes_header_type ), public :: nodes_header real(kind=rk), public :: factor","tags":"","url":"type/ply_l2p_header_type.html"},{"title":"sdr_protoTree_type – Seeder ","text":"type, public :: sdr_protoTree_type The protoTree is used to describe the preliminary tree, before it\nis actually extended to the full information of the mesh. This extension will only be done for the actual leaf nodes, in the\ncomputational domain. Inherits type~~sdr_prototree_type~~InheritsGraph type~sdr_prototree_type sdr_protoTree_type grw_intarray_type grw_intarray_type type~sdr_prototree_type->grw_intarray_type child_intersected_object sdr_node_type sdr_node_type type~sdr_prototree_type->sdr_node_type node Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: nLevels Keep track of the deepest level in the tree. integer, public :: nLeafNodes Number of leaf nodes. integer, public :: nFloodedLeaves Number of flooded leaves. type(sdr_node_type), public :: node List of all nodes in the tree, each node contains a list of the\nobjects it is intersecting and a property bit mask.\nIt is identified by its treeID. All components of Node are growing arrays, thus the corresponding\ncomponent of node inode has to be accessed with component%val(inode). integer, public :: levelNode_first (0:globalMaxLevels) The index of the first node on a given level in node%treeID%sorted. integer, public :: levelNode_last (0:globalMaxLevels) The index of the last node on a given level in node%treeID%sorted. type( grw_intarray_type ), public :: child_intersected_object Temporary array intersected objects of 8 children which will later\nbe copied to intersected_object in node_type. This array is initialized in build_protoTree and destroyed\nafter refine_leaf","tags":"","url":"type/sdr_prototree_type.html"},{"title":"levelValues_type – Seeder ","text":"type, public :: levelValues_type Auxilary data type to provide data on the current level iteration. Components Type Visibility Attributes Name Initial integer(kind=long_k), public :: ID_offset First treeID on current level real(kind=rk), public :: dx Node cube length on current level integer, public :: level Number of the level itself.","tags":"","url":"type/levelvalues_type.html"},{"title":"ply_sampling_adaptive_type – Seeder ","text":"type, public :: ply_sampling_adaptive_type Configuration of the adaptive sampling. The main setting is max_nlevels, which states the maximum number of\nlevels that elements will be refined. Inherits type~~ply_sampling_adaptive_type~~InheritsGraph type~ply_sampling_adaptive_type ply_sampling_adaptive_type type~ply_filter_element_type ply_filter_element_type type~ply_sampling_adaptive_type->type~ply_filter_element_type filter_element Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: max_nlevels = 0 Maximal number of levels by which any mesh element should be refined. A setting of 0 results in no sampling, and the original mesh elements\nwill be used with the integral mean value (first degree of freedom).\nHigher levels provide a limit for the refinement of the mesh.\nNote, that even for large settings here, the overall mesh depth is\nrestricted by the global limit, due to the available space in the\nintegers representing the treeIDs. real(kind=rk), public :: eps_osci Maximum allowed oscillation of the solution.\nFor adaptive subsampling only. integer, public :: reduction_mode Method to use for the reduction. This may either be: redux_factor: multiply the maximal polynomial degree by the\n              given factor in each refinement level. This allows to\n              maintain the same total number of degrees of freedom by\n              halfing the modes during each refinement.\n              This is the default reduction mode redux_decrement: Cut off the given dof_decrement last modes in each\n                   refinement. This can be used to filter off the most\n                   oscillatory modes while affecting the solution\n                   minimally otherwise. logical, public :: ignore_highmodes = .false. Indication whether to filter modes during refinement by ignoring\nall modes in the parent, that exceed the target polynomial degree\nof the child elements. This provides a simple lowpass filtering method if activated.\nDefaults to false. integer, public :: dof_decrement = 1 Number of modes to cut off in each refinement. If the decrement mode for reduction is used, this setting will\nbe used to cut off as many modes from the refined elements. real(kind=rk), public :: dofReducFactor Factor to Reduce dofs for every sampling level.\nCan be used to avoid too drastic increase of memory consumption.\nFor adaptive subsampling only. logical, public :: adaptiveDofReduction Indicator for the limitation of memory consumption. integer, public :: AbsUpperBoundLevel Absolute upper bound level to refine to. type( ply_filter_element_type ), public :: filter_element Filtering the poylnomial modes during adaptive refinement. This filtering provides the possibility to change the applied\nfiltering based on the polynomials and thereby attempting to\ncapture discontinuities more sharply.","tags":"","url":"type/ply_sampling_adaptive_type.html"},{"title":"realarray_type – Seeder ","text":"type, private :: realarray_type Small helping type to allow arrays of arrays for the variable data. Inherited by type~~realarray_type~~InheritedByGraph type~realarray_type realarray_type type~sampled_method_data_type sampled_method_data_type type~sampled_method_data_type->type~realarray_type component Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, pointer :: dat (:) => NULL()","tags":"","url":"type/realarray_type.html"},{"title":"sampled_method_data_type – Seeder ","text":"type, private :: sampled_method_data_type A container for the method data to hold the data in a scalar pointer for\nthe C-pointer conversion. Inherits type~~sampled_method_data_type~~InheritsGraph type~sampled_method_data_type sampled_method_data_type type~realarray_type realarray_type type~sampled_method_data_type->type~realarray_type component Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( realarray_type ), public, allocatable :: component (:)","tags":"","url":"type/sampled_method_data_type.html"},{"title":"sdr_confHead_type – Seeder ","text":"type, public :: sdr_confHead_type This type contains basic information loaded from the config file. Inherits type~~sdr_confhead_type~~InheritsGraph type~sdr_confhead_type sdr_confHead_type dyn_labelarray_type dyn_labelarray_type type~sdr_confhead_type->dyn_labelarray_type inverted_colors tem_general_type tem_general_type type~sdr_confhead_type->tem_general_type general type~sdr_subresolution_type sdr_subresolution_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution type~sdr_subresolution_type->dyn_labelarray_type default_colors ply_prj_init_type ply_prj_init_type type~sdr_subresolution_type->ply_prj_init_type projection type~ply_prj_header_type ply_prj_header_type type~sdr_subresolution_type->type~ply_prj_header_type project_header type~sdr_subres_fills_type sdr_subres_fills_type type~sdr_subresolution_type->type~sdr_subres_fills_type color_values type~ply_fpt_header_type ply_fpt_header_type type~ply_prj_header_type->type~ply_fpt_header_type fpt_header type~ply_fxt_header_type ply_fxt_header_type type~ply_prj_header_type->type~ply_fxt_header_type fxt_header type~ply_l2p_header_type ply_l2p_header_type type~ply_prj_header_type->type~ply_l2p_header_type l2p_header type~sdr_subres_fills_type->dyn_labelarray_type label grw_realarray_type grw_realarray_type type~sdr_subres_fills_type->grw_realarray_type fill, void type~ply_nodes_header_type ply_nodes_header_type type~ply_fpt_header_type->type~ply_nodes_header_type nodes_header type~ply_fxt_header_type->type~ply_nodes_header_type nodes_header type~ply_l2p_header_type->type~ply_nodes_header_type nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=PathLen), public :: comment character(len=PathLen), public :: folder integer, public :: minlevel type( tem_general_type ), public :: general type( sdr_subresolution_type ), public :: subresolution Information on resolution of boundaries within elements using\npolynomials. type( dyn_labelarray_type ), public :: inverted_colors List of colors to invert. Colors that are listed here, will get their definition inverted, such\nthat filled areas are turned void and void areas will get filled if\nthey are flooded by the none color. Inverting the none color is not\npossible.","tags":"","url":"type/sdr_confhead_type.html"},{"title":"sdr_hvs_config_type – Seeder ","text":"type, public :: sdr_hvs_config_type This datatype describes the various settings to load from the configuration\nfile. Inherits type~~sdr_hvs_config_type~~InheritsGraph type~sdr_hvs_config_type sdr_hvs_config_type hvs_output_config_type hvs_output_config_type type~sdr_hvs_config_type->hvs_output_config_type output type~ply_sampled_tracking_type ply_sampled_tracking_type type~sdr_hvs_config_type->type~ply_sampled_tracking_type ply_sample_track ply_sampling_type ply_sampling_type type~ply_sampled_tracking_type->ply_sampling_type sampling tem_tracking_type tem_tracking_type type~ply_sampled_tracking_type->tem_tracking_type tracking tem_varSys_type tem_varSys_type type~ply_sampled_tracking_type->tem_varSys_type varsys treelmesh_type treelmesh_type type~ply_sampled_tracking_type->treelmesh_type mesh Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=pathLen), public :: prefix Location on disk to load the mesh data from. This prefix will be put before the various filenames of the individual\nmesh data files. logical, public :: do_subsampling Indication on wether to do subsampling. Subsampling is only necessary if there is any variable with more than a\nsingle degree of freedom, and the user requests sampling of the\npolynomials. type( ply_sampled_tracking_type ), public :: ply_sample_track Definition of trackings to extract only parts of the information. This includes the configuration for subsampling (which is only relevant\nif there is actually subresolved data in the mesh). type( hvs_output_config_type ), public :: output Description of how the visualization output should be done.","tags":"","url":"type/sdr_hvs_config_type.html"},{"title":"sdr_cube_type – Seeder ","text":"type, public :: sdr_cube_type An auxilary data type to describe a cube. Here: The origin is the corner from which on the cube is spanned \nwith the given length in each direction. Components Type Visibility Attributes Name Initial real(kind=rk), public :: origin (3) real(kind=rk), public :: center (3) real(kind=rk), public :: extent real(kind=rk), public :: halfwidth","tags":"","url":"type/sdr_cube_type.html"},{"title":"sdr_temData_type – Seeder ","text":"type, public :: sdr_temData_type Data type contains final fluid info dumped into mesh file Inherits type~~sdr_temdata_type~~InheritsGraph type~sdr_temdata_type sdr_temData_type grw_char2darray_type grw_char2darray_type type~sdr_temdata_type->grw_char2darray_type colors, subres grw_longarray_type grw_longarray_type type~sdr_temdata_type->grw_longarray_type treeID, propertyBits, bc_ID grw_realarray_type grw_realarray_type type~sdr_temdata_type->grw_realarray_type qVal, bc_normal ply_poly_project_type ply_poly_project_type type~sdr_temdata_type->ply_poly_project_type projection treelmesh_type treelmesh_type type~sdr_temdata_type->treelmesh_type meshUniverse Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( grw_longarray_type ), public :: treeID list of fluid treeIDs type( grw_longarray_type ), public :: propertyBits list of property bits for fluid nodes type( grw_longarray_type ), public :: bc_ID (qQQQ) list of boundary iDs for fluid nodes in 26 directions type( grw_char2darray_type ), public :: colors list of color characters type( grw_char2darray_type ), public :: subres list of color characters indicating their subresolution status. integer, public, allocatable :: color_subres_count (:) Count number of subresolved elements for each color. integer, public, allocatable :: color_subres_unit (:) File unit for the subresolution information of each color. real(kind=rk), public, allocatable :: color_volume (:) Measure of the volume covered by each color integer, public :: maxLevel maxlevel in the fluid domain integer, public :: minLevel minlevel in the fluid domain type( grw_realarray_type ), public :: qVal (qQQQ) link-wise distances from boundary for fluid nodes in 26 directions type( grw_realarray_type ), public :: bc_normal (3) Surface normals in boundary elements for which it is to be stored type( treelmesh_type ), public :: meshUniverse treelm mesh type contains only bounding cube info\nneeded to identify boundary and compute q-values integer, public :: nSolids = 0 number of fluidifyable ( solids ) integer, public :: nFluids (globalMaxLevels) Number of fluids on each level type(ply_poly_project_type), public :: projection Projection workspace.","tags":"","url":"type/sdr_temdata_type.html"},{"title":"ply_faceNodes_type – Seeder ","text":"type, public :: ply_faceNodes_type Datatype to represent facewise nodes Components Type Visibility Attributes Name Initial integer, public :: nquadPoints The number of face nodes real(kind=rk), public, allocatable :: points (:,:) The face nodes.\nFirst index goes from 1 to nPoints and second index\nfrom 1 to 3 for the 3 spatial coordinates.","tags":"","url":"type/ply_facenodes_type.html"},{"title":"ply_filter_element_type – Seeder ","text":"type, public :: ply_filter_element_type Paramaters describing the filtering to apply to elemental polynomial data. Inherited by type~~ply_filter_element_type~~InheritedByGraph type~ply_filter_element_type ply_filter_element_type type~ply_sampling_adaptive_type ply_sampling_adaptive_type type~ply_sampling_adaptive_type->type~ply_filter_element_type filter_element Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: strategy = filter_strat_none Filter strategy to use. integer, public :: max_order Maximal order for exponential spectral filtering to use\nwhere little filtering is to be done. integer, public :: min_order Minimal order for exponential spectral filtering to use. integer, public :: fract_exponent Exponent to use for the fraction. procedure( ply_filter_element ), public, pointer :: filter1D => NULL() Function pointer for 1D filtering procedure( ply_filter_element ), public, pointer :: filter2D => NULL() Function pointer for 2D filtering procedure( ply_filter_element ), public, pointer :: filter3D => NULL() Function pointer for 3D filtering","tags":"","url":"type/ply_filter_element_type.html"},{"title":"ply_subsample_type – Seeder ","text":"type, public :: ply_subsample_type Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. Is subsampling active integer, public :: sampling_lvl The current sampling lvl. integer, public :: projectionType = ply_QLegendrePoly_prp The type of projection we use to subsample the elemental data. integer, public :: caplevel = 20 Maximal Level down to which subsampling should be done. integer, public :: minsub = 0 Minimal subsampling depth: integer, public :: maxsub = 0 Maximal subsampling depth: real(kind=rk), public :: eps_osci Maximum allowed oscillation of the solution.\nFor adaptive subsampling only. real(kind=rk), public :: dofReducFactor Factor for the reduction of the degrees of freedom in one subsampling\nstep (per spatial direction). logical, public :: adaptiveDofReduction Indicator for limitation of total memory consumption integer, public :: AbsUpperBoundLevel Absolute upper bound level to refine to.","tags":"","url":"type/ply_subsample_type.html"},{"title":"ply_array_type – Seeder ","text":"type, public :: ply_array_type Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dat (:)","tags":"","url":"type/ply_array_type.html"},{"title":"ply_ProjCoeff_type – Seeder ","text":"type, private :: ply_ProjCoeff_type Datatype storing the coefficients arising for the projection\nof solutions on a parent cell to its children during the subsampling\nroutines. Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: projCoeff (:,:,:) Array holding all the projection coefficients for the projection\nof a degree of freedom on the parent element (first index) to\na degree of freedom on the child element (second index) for\na given child element (third index).\nTherefore the dimension of this array is (nDofs, nDofs, 8).","tags":"","url":"type/ply_projcoeff_type.html"},{"title":"ply_fxt_type – Seeder ","text":"type, public :: ply_fxt_type Inherits type~~ply_fxt_type~~InheritsGraph type~ply_fxt_type ply_fxt_type fxtf_flptld_type fxtf_flptld_type type~ply_fxt_type->fxtf_flptld_type flpt Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(fxtf_flptld_type), public :: flpt real(kind=rk), public :: prec integer, public :: ndims","tags":"","url":"type/ply_fxt_type.html"},{"title":"ply_prj_header_type – Seeder ","text":"type, public :: ply_prj_header_type Configurable projection settings. Inherits type~~ply_prj_header_type~~InheritsGraph type~ply_prj_header_type ply_prj_header_type type~ply_fpt_header_type ply_fpt_header_type type~ply_prj_header_type->type~ply_fpt_header_type fpt_header type~ply_fxt_header_type ply_fxt_header_type type~ply_prj_header_type->type~ply_fxt_header_type fxt_header type~ply_l2p_header_type ply_l2p_header_type type~ply_prj_header_type->type~ply_l2p_header_type l2p_header type~ply_nodes_header_type ply_nodes_header_type type~ply_fpt_header_type->type~ply_nodes_header_type nodes_header type~ply_fxt_header_type->type~ply_nodes_header_type nodes_header type~ply_l2p_header_type->type~ply_nodes_header_type nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ply_prj_header_type~~InheritedByGraph type~ply_prj_header_type ply_prj_header_type type~sdr_subresolution_type sdr_subresolution_type type~sdr_subresolution_type->type~ply_prj_header_type project_header type~sdr_confhead_type sdr_confHead_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=labelLen), public :: kind Kind of projection. Currently available:\n- 'l2p', L2-Projection\n- 'fpt', Fast Polynomial Transformation. Requires the FFTW. type( ply_fpt_header_type ), public :: fpt_header type( ply_l2p_header_type ), public :: l2p_header type( ply_fxt_header_type ), public :: fxt_header","tags":"","url":"type/ply_prj_header_type.html"},{"title":"ply_nodes_header_type – Seeder ","text":"type, public :: ply_nodes_header_type Inherited by type~~ply_nodes_header_type~~InheritedByGraph type~ply_nodes_header_type ply_nodes_header_type type~ply_fpt_header_type ply_fpt_header_type type~ply_fpt_header_type->type~ply_nodes_header_type nodes_header type~ply_fxt_header_type ply_fxt_header_type type~ply_fxt_header_type->type~ply_nodes_header_type nodes_header type~ply_l2p_header_type ply_l2p_header_type type~ply_l2p_header_type->type~ply_nodes_header_type nodes_header type~ply_prj_header_type ply_prj_header_type type~ply_prj_header_type->type~ply_fpt_header_type fpt_header type~ply_prj_header_type->type~ply_fxt_header_type fxt_header type~ply_prj_header_type->type~ply_l2p_header_type l2p_header type~sdr_subresolution_type sdr_subresolution_type type~sdr_subresolution_type->type~ply_prj_header_type project_header type~sdr_confhead_type sdr_confHead_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=labelLen), public :: nodes_kind which kind of nodes are used. For l2p projection the nodes are\nlegendre-gauss and chebyshev nodes for using fpt logical, public :: lobattoPoints = .false. Logical to indicate whether Chebyshev-Lobatto points or simple\nChebyshev points are used","tags":"","url":"type/ply_nodes_header_type.html"},{"title":"sdr_subres_fills_type – Seeder ","text":"type, public :: sdr_subres_fills_type Definition of values to use for colors in polynomial representations. Inherits type~~sdr_subres_fills_type~~InheritsGraph type~sdr_subres_fills_type sdr_subres_fills_type dyn_labelarray_type dyn_labelarray_type type~sdr_subres_fills_type->dyn_labelarray_type label grw_realarray_type grw_realarray_type type~sdr_subres_fills_type->grw_realarray_type fill, void Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~sdr_subres_fills_type~~InheritedByGraph type~sdr_subres_fills_type sdr_subres_fills_type type~sdr_subresolution_type sdr_subresolution_type type~sdr_subresolution_type->type~sdr_subres_fills_type color_values type~sdr_confhead_type sdr_confHead_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( dyn_labelarray_type ), public :: label Name of the color, to which the color values apply. type( grw_realarray_type ), public :: fill Actual value to use, where the color is present, defaults to 1. Todo HK: replace by spatial function type( grw_realarray_type ), public :: void Actual value to use, where the color is not present, defaults to 0.","tags":"","url":"type/sdr_subres_fills_type.html"},{"title":"ply_sampled_tracking_type – Seeder ","text":"type, public :: ply_sampled_tracking_type Inherits type~~ply_sampled_tracking_type~~InheritsGraph type~ply_sampled_tracking_type ply_sampled_tracking_type ply_sampling_type ply_sampling_type type~ply_sampled_tracking_type->ply_sampling_type sampling tem_tracking_type tem_tracking_type type~ply_sampled_tracking_type->tem_tracking_type tracking tem_varSys_type tem_varSys_type type~ply_sampled_tracking_type->tem_varSys_type varsys treelmesh_type treelmesh_type type~ply_sampled_tracking_type->treelmesh_type mesh Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ply_sampled_tracking_type~~InheritedByGraph type~ply_sampled_tracking_type ply_sampled_tracking_type type~sdr_hvs_config_type sdr_hvs_config_type type~sdr_hvs_config_type->type~ply_sampled_tracking_type ply_sample_track Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_tracking_type ), public :: tracking Contains all tracking headers, control and tracking entities\nactive on local process type( treelmesh_type ), public, allocatable :: mesh (:) Subsampled mesh for each tracking. Todo Actually make use of these, instead of regenerating the mesh\n      every time the tracking is written. type( tem_varSys_type ), public, allocatable :: varsys (:) Variable system description after subsampling. Todo Actuall make use of these, instead of recreating the variable\n      system each time a tracking is written. type(ply_sampling_type), public :: sampling Configuration of the subsampling (applied to all trackings). integer, public :: ndims Dimensionality of the data to sample.","tags":"","url":"type/ply_sampled_tracking_type.html"},{"title":"ply_subsample_type – Seeder ","text":"type, public :: ply_subsample_type Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. Is subsampling active integer, public :: sampling_lvl The current sampling lvl. integer, public :: caplevel = 20 Maximal Level down to which subsampling should be done. integer, public :: minsub = 0 Minimal subsampling depth: integer, public :: maxsub = 0 Maximal subsampling depth: real(kind=rk), public :: eps_osci Maximum allowed oscillation of the solution.\nFor adaptive subsampling only. real(kind=rk), public :: dofReducFactor Factor for the reduction of the degrees of freedom in one subsampling\nstep (per spatial direction). logical, public :: adaptiveDofReduction Indicator for limitation of total memory consumption integer, public :: AbsUpperBoundLevel Absolute upper bound level to refine to.","tags":"","url":"type/ply_subsample_type~2.html"},{"title":"ply_array_type – Seeder ","text":"type, public :: ply_array_type Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dat (:)","tags":"","url":"type/ply_array_type~2.html"},{"title":"ply_sampling_var_type – Seeder ","text":"type, public :: ply_sampling_var_type Small helping type to allow arrays of arrays for the variable data. Components Type Visibility Attributes Name Initial integer, public :: nDeviating integer, public, allocatable :: degree (:) integer, public, allocatable :: first (:) real(kind=rk), public, pointer :: dat (:) logical, public, allocatable :: deviates (:)","tags":"","url":"type/ply_sampling_var_type.html"},{"title":"ply_subresolution_type – Seeder ","text":"type, public :: ply_subresolution_type Inherits type~~ply_subresolution_type~~InheritsGraph type~ply_subresolution_type ply_subresolution_type tem_subres_prop_type tem_subres_prop_type type~ply_subresolution_type->tem_subres_prop_type subres_prop Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ply_subresolution_type~~InheritedByGraph type~ply_subresolution_type ply_subresolution_type type~ply_subres_colvar_type ply_subres_colvar_type type~ply_subres_colvar_type->type~ply_subresolution_type subres type~sdr_hvs_props_type sdr_hvs_props_type type~sdr_hvs_props_type->type~ply_subresolution_type subres type~sdr_hvs_colvar_ptr_type sdr_hvs_colvar_ptr_type type~sdr_hvs_props_type->type~sdr_hvs_colvar_ptr_type colorVar type~sdr_hvs_colvar_ptr_type->type~ply_subres_colvar_type p Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: polydegree = 0 integer, public :: basisType type( tem_subres_prop_type ), public :: subres_prop","tags":"","url":"type/ply_subresolution_type.html"},{"title":"ply_subres_colvar_type – Seeder ","text":"type, public :: ply_subres_colvar_type Self contained description of color data to be used for method data. Inherits type~~ply_subres_colvar_type~~InheritsGraph type~ply_subres_colvar_type ply_subres_colvar_type tem_color_prop_type tem_color_prop_type type~ply_subres_colvar_type->tem_color_prop_type color type~ply_subresolution_type ply_subresolution_type type~ply_subres_colvar_type->type~ply_subresolution_type subres tem_subres_prop_type tem_subres_prop_type type~ply_subresolution_type->tem_subres_prop_type subres_prop Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ply_subres_colvar_type~~InheritedByGraph type~ply_subres_colvar_type ply_subres_colvar_type type~sdr_hvs_colvar_ptr_type sdr_hvs_colvar_ptr_type type~sdr_hvs_colvar_ptr_type->type~ply_subres_colvar_type p type~sdr_hvs_props_type sdr_hvs_props_type type~sdr_hvs_props_type->type~sdr_hvs_colvar_ptr_type colorVar Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_color_prop_type ), public, pointer :: color => NULL() Pointer to the overall color property description. type( ply_subresolution_type ), public, pointer :: subres => NULL() Pointer to the overall subresolution property description. real(kind=rk), public, allocatable :: subresdat (:,:) Degrees of freedom for subresolved elements. integer, public :: nsubdofs Number of degrees of freedom of the subresolution data. integer, public :: colpos Position of this color in the list of colors, needed to make use of the\npointers above.","tags":"","url":"type/ply_subres_colvar_type.html"},{"title":"sdr_translation_type – Seeder ","text":"type, public :: sdr_translation_type Data type defines geometry translation Inherited by type~~sdr_translation_type~~InheritedByGraph type~sdr_translation_type sdr_translation_type type~sdr_transformation_type sdr_transformation_type type~sdr_transformation_type->type~sdr_translation_type translate Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active Is translation defined real(kind=rk), public :: vec (3) vector defining translation in x,y,z direction","tags":"","url":"type/sdr_translation_type.html"},{"title":"sdr_deformation_type – Seeder ","text":"type, public :: sdr_deformation_type Data type defines geometry scale and rotation Inherited by type~~sdr_deformation_type~~InheritedByGraph type~sdr_deformation_type sdr_deformation_type type~sdr_transformation_type sdr_transformation_type type~sdr_transformation_type->type~sdr_deformation_type deform Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active Is deformation defined real(kind=rk), public :: matrix (3,3) matrix defining the deformation","tags":"","url":"type/sdr_deformation_type.html"},{"title":"sdr_transformation_type – Seeder ","text":"type, public :: sdr_transformation_type Data type defines geometry transformation Inherits type~~sdr_transformation_type~~InheritsGraph type~sdr_transformation_type sdr_transformation_type type~sdr_deformation_type sdr_deformation_type type~sdr_transformation_type->type~sdr_deformation_type deform type~sdr_translation_type sdr_translation_type type~sdr_transformation_type->type~sdr_translation_type translate Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active is transformation active type( sdr_translation_type ), public :: translate translation of geometry type( sdr_deformation_type ), public :: deform deformation of geometry","tags":"","url":"type/sdr_transformation_type.html"},{"title":"ply_lagrange_type – Seeder ","text":"type, public :: ply_lagrange_type Components Type Visibility Attributes Name Initial integer, public :: nPoints Number of points to represent the Lagrange polynomials real(kind=rk), public, allocatable :: coords (:) Coordinates of the points where the nodes are to be found. real(kind=rk), public, allocatable :: values (:) Values of the function at all coords.","tags":"","url":"type/ply_lagrange_type.html"},{"title":"sdr_geometry_type – Seeder ","text":"type, public :: sdr_geometry_type Geometric description of the space to mesh. Inherits type~~sdr_geometry_type~~InheritsGraph type~sdr_geometry_type sdr_geometry_type grw_boxarray_type grw_boxarray_type type~sdr_geometry_type->grw_boxarray_type box grw_cylinderarray_type grw_cylinderarray_type type~sdr_geometry_type->grw_cylinderarray_type cylinder grw_ellipsoidarray_type grw_ellipsoidarray_type type~sdr_geometry_type->grw_ellipsoidarray_type ellipsoid grw_linearray_type grw_linearray_type type~sdr_geometry_type->grw_linearray_type line grw_periPlaneArray_type grw_periPlaneArray_type type~sdr_geometry_type->grw_periPlaneArray_type periPlane grw_pointarray_type grw_pointarray_type type~sdr_geometry_type->grw_pointarray_type point grw_spacerInterwovenArray_type grw_spacerInterwovenArray_type type~sdr_geometry_type->grw_spacerInterwovenArray_type spacerInterwoven grw_spatialObjArray_type grw_spatialObjArray_type type~sdr_geometry_type->grw_spatialObjArray_type spatialObj grw_spherearray_type grw_spherearray_type type~sdr_geometry_type->grw_spherearray_type sphere grw_trianglearray_type grw_trianglearray_type type~sdr_geometry_type->grw_trianglearray_type triangle sdr_attrList_type sdr_attrList_type type~sdr_geometry_type->sdr_attrList_type attribute tem_cube_type tem_cube_type type~sdr_geometry_type->tem_cube_type universe Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_cube_type ), public :: universe The universe given as a bounding cube. type( grw_pointarray_type ), public :: point growing array of all points type( grw_linearray_type ), public :: line growing array of all lines type( grw_trianglearray_type ), public :: triangle growing array of all triangles type( grw_boxarray_type ), public :: box growing array of all boxes type(grw_periPlaneArray_type), public :: periPlane growing array of periodic plane objects type( grw_spherearray_type ), public :: sphere growing array of spheres type( grw_ellipsoidarray_type ), public :: ellipsoid growing array of spheres type( grw_cylinderarray_type ), public :: cylinder growing array of cylinders type(grw_spacerInterwovenArray_type), public :: spacerInterwoven growing array of spacer type(grw_spatialObjArray_type), public :: spatialObj Growing array of geometrical objects. type(sdr_attrList_type), public :: attribute Dynamic Unique array of attributes connected to the objects\n(seed, boundary or refinement) logical, public :: smoothbounds = .true. Smooth refinement towards boundaries. logical, public :: smoothLevels = .true. Smooth level jumps, avoid level jump > 1 in domain integer, public :: nUserObjs Number of user defined spatial objects\ni.e excluding spatial objects created for distance refine","tags":"","url":"type/sdr_geometry_type.html"},{"title":"ply_l2p_type – Seeder ","text":"type, public :: ply_l2p_type Storage of the transformation matrices for the L2 projection method to\nconvert between modal and nodal values. Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: leg2node (:,:) real(kind=rk), public, allocatable :: node2leg (:,:)","tags":"","url":"type/ply_l2p_type.html"},{"title":"ply_fxt_header_type – Seeder ","text":"type, public :: ply_fxt_header_type Fxt projection header type, consisting of the node header which give\ninformation about the type and number of points for the projection Inherits type~~ply_fxt_header_type~~InheritsGraph type~ply_fxt_header_type ply_fxt_header_type type~ply_nodes_header_type ply_nodes_header_type type~ply_fxt_header_type->type~ply_nodes_header_type nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ply_fxt_header_type~~InheritedByGraph type~ply_fxt_header_type ply_fxt_header_type type~ply_prj_header_type ply_prj_header_type type~ply_prj_header_type->type~ply_fxt_header_type fxt_header type~sdr_subresolution_type sdr_subresolution_type type~sdr_subresolution_type->type~ply_prj_header_type project_header type~sdr_confhead_type sdr_confHead_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( ply_nodes_header_type ), public :: nodes_header real(kind=rk), public :: factor = 1.0 real(kind=rk), public :: prec = epsilon(1.0)","tags":"","url":"type/ply_fxt_header_type.html"},{"title":"ply_fpt_header_type – Seeder ","text":"type, public :: ply_fpt_header_type Type for the fpt header, stores all information needed to initialize the\nfpt method later on Inherits type~~ply_fpt_header_type~~InheritsGraph type~ply_fpt_header_type ply_fpt_header_type type~ply_nodes_header_type ply_nodes_header_type type~ply_fpt_header_type->type~ply_nodes_header_type nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~ply_fpt_header_type~~InheritedByGraph type~ply_fpt_header_type ply_fpt_header_type type~ply_prj_header_type ply_prj_header_type type~ply_prj_header_type->type~ply_fpt_header_type fpt_header type~sdr_subresolution_type sdr_subresolution_type type~sdr_subresolution_type->type~ply_prj_header_type project_header type~sdr_confhead_type sdr_confHead_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( ply_nodes_header_type ), public :: nodes_header real(kind=rk), public :: factor = 1.0_rk In case of nonlinear equations, aliasing occurs if the projections\nof the nonlinear terms on the testfunctions are not calculated\naccurately enough. To avoid these errors it is possible to\nextend the transformation vectors of the FPT with zeros. This\nfactor determines by how many zeros the modal vector is extended\nbefore transformation. This factor has to be chosen properly with\nrespect of the type of nonlinearity of your equation. integer, public :: blocksize = ply_fpt_default_blocksize The blockisze of the fast bases exchange algorithm from\nLegendre to Chebyshev polynomials.\nA negative number indicates to use the default blocksize of the\nalgorithm. integer, public :: approx_terms = ply_fpt_default_approx_terms The number of approximation terms to use for blocks apart from the\ndiagonal. This defaults to 18, which is recommended for double precision. integer, public :: implementation The implementation variant to use for the transformation computation. The computation can be done either by a 'vector' implementation or\nby a 'scalar' implementation.\nWe indicate the respective implementations by the integers ply_fpt_scalar or ply_fpt_vector . integer, public :: striplen = vlen The striplen, that should be used for vectorized simultaneous\ncomputations of the matrix operation. This defaults to the vlen from the TEM_compileconf_module, it might\nbe set differently here, as we are dealing with a twodimensional\nproblem here, and the optimal setting might be different from the code\nparts. integer, public :: subblockingWidth = ply_fpt_default_subblockingWidth The width of the subblocks used during the unrolled base exchange to\nensure a better cache usage. The default is a subblocking width of 8. logical, public :: adapt_factor_pow2 = .false. Should the oversampling factor be adapted to ensure a power of 2\nin the oversampled polynomial? If this is true, the factor will be increased to ensure\nan oversampled representation with a power of 2.\nDefault is false.","tags":"","url":"type/ply_fpt_header_type.html"},{"title":"ply_legFpt_type – Seeder ","text":"type, public :: ply_legFpt_type Datatype for parameters of the FPT used for 1d, 2d and 3d. Stores of the parameters for a fast conversion of a modal\nLegendre expansion to point values (located at Chebyshev nodes)\nand vice versa. \\n\nThe FPT covers: \\n\n- Transformation from Legendre expansion to point values\n  at Chebyshev nodes \\n\n- Transformation from point values (Chebyshev nodes) to\n  modal Legendre expansion \\n Inherits type~~ply_legfpt_type~~InheritsGraph type~ply_legfpt_type ply_legFpt_type C_PTR C_PTR type~ply_legfpt_type->C_PTR planChebToPnt, planPntToCheb ply_trafo_params_type ply_trafo_params_type type~ply_legfpt_type->ply_trafo_params_type legToChebParams, chebToLegParams Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(ply_trafo_params_type), public :: legToChebParams FPT params for the fast base exchange from Legendre to\nChebyshev expansion. type(ply_trafo_params_type), public :: chebToLegParams FPT params for the fast base exchange from Chebyshev to\nLegendre expansion. type(C_PTR), public :: planChebToPnt FFTW plan for DCT from Chebyshev coefficients to point values. type(C_PTR), public :: planPntToCheb FFTW plan for DCT from point values to Chebyshev coefficients. logical, public :: use_lobatto_points Flag whether to use Lobatto points (include boundary points) procedure( ply_fptm2n ), public, pointer :: legtopnt => NULL() procedure( ply_fptn2m ), public, pointer :: pnttoleg => NULL()","tags":"","url":"type/ply_legfpt_type.html"},{"title":"sdr_hvs_props_type – Seeder ","text":"type, public :: sdr_hvs_props_type Datatype to collect the various properties of the mesh. Inherits type~~sdr_hvs_props_type~~InheritsGraph type~sdr_hvs_props_type sdr_hvs_props_type tem_BC_prop_type tem_BC_prop_type type~sdr_hvs_props_type->tem_BC_prop_type bc tem_color_prop_type tem_color_prop_type type~sdr_hvs_props_type->tem_color_prop_type color type~ply_subresolution_type ply_subresolution_type type~sdr_hvs_props_type->type~ply_subresolution_type subres type~sdr_hvs_colvar_ptr_type sdr_hvs_colvar_ptr_type type~sdr_hvs_props_type->type~sdr_hvs_colvar_ptr_type colorVar tem_subres_prop_type tem_subres_prop_type type~ply_subresolution_type->tem_subres_prop_type subres_prop type~ply_subres_colvar_type ply_subres_colvar_type type~sdr_hvs_colvar_ptr_type->type~ply_subres_colvar_type p type~ply_subres_colvar_type->tem_color_prop_type color type~ply_subres_colvar_type->type~ply_subresolution_type subres Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_BC_prop_type ), public, pointer :: bc => NULL() Property describing the boundary conditions in the mesh. type( tem_color_prop_type ), public, pointer :: color => NULL() Property describing the coloring of the mesh. type( ply_subresolution_type ), public, pointer :: subres => NULL() Additional color distribution information via subresolution. type( sdr_hvs_colvar_ptr_type ), public, allocatable :: colorVar (:) Description of color variables. integer, public, allocatable :: colorvarpos (:) Position in the variables for each color. If a color was not added as variable, the entry will be negative.\nThis is useful to iterate through all colors, that were actually added\nas variables.","tags":"","url":"type/sdr_hvs_props_type.html"},{"title":"sdr_hvs_colvar_ptr_type – Seeder ","text":"type, private :: sdr_hvs_colvar_ptr_type Auxilary data type to allow an array of pointers to colvar objects. Inherits type~~sdr_hvs_colvar_ptr_type~~InheritsGraph type~sdr_hvs_colvar_ptr_type sdr_hvs_colvar_ptr_type type~ply_subres_colvar_type ply_subres_colvar_type type~sdr_hvs_colvar_ptr_type->type~ply_subres_colvar_type p tem_color_prop_type tem_color_prop_type type~ply_subres_colvar_type->tem_color_prop_type color type~ply_subresolution_type ply_subresolution_type type~ply_subres_colvar_type->type~ply_subresolution_type subres tem_subres_prop_type tem_subres_prop_type type~ply_subresolution_type->tem_subres_prop_type subres_prop Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~sdr_hvs_colvar_ptr_type~~InheritedByGraph type~sdr_hvs_colvar_ptr_type sdr_hvs_colvar_ptr_type type~sdr_hvs_props_type sdr_hvs_props_type type~sdr_hvs_props_type->type~sdr_hvs_colvar_ptr_type colorVar Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( ply_subres_colvar_type ), public, pointer :: p => NULL() procedure( tem_varSys_proc_element ), public, nopass, pointer :: get_element","tags":"","url":"type/sdr_hvs_colvar_ptr_type.html"},{"title":"sdr_subresolution_type – Seeder ","text":"type, public :: sdr_subresolution_type Settings for the resolution below mesh elements. Inherits type~~sdr_subresolution_type~~InheritsGraph type~sdr_subresolution_type sdr_subresolution_type dyn_labelarray_type dyn_labelarray_type type~sdr_subresolution_type->dyn_labelarray_type default_colors ply_prj_init_type ply_prj_init_type type~sdr_subresolution_type->ply_prj_init_type projection type~ply_prj_header_type ply_prj_header_type type~sdr_subresolution_type->type~ply_prj_header_type project_header type~sdr_subres_fills_type sdr_subres_fills_type type~sdr_subresolution_type->type~sdr_subres_fills_type color_values type~ply_fpt_header_type ply_fpt_header_type type~ply_prj_header_type->type~ply_fpt_header_type fpt_header type~ply_fxt_header_type ply_fxt_header_type type~ply_prj_header_type->type~ply_fxt_header_type fxt_header type~ply_l2p_header_type ply_l2p_header_type type~ply_prj_header_type->type~ply_l2p_header_type l2p_header type~sdr_subres_fills_type->dyn_labelarray_type label grw_realarray_type grw_realarray_type type~sdr_subres_fills_type->grw_realarray_type fill, void type~ply_nodes_header_type ply_nodes_header_type type~ply_fpt_header_type->type~ply_nodes_header_type nodes_header type~ply_fxt_header_type->type~ply_nodes_header_type nodes_header type~ply_l2p_header_type->type~ply_nodes_header_type nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~sdr_subresolution_type~~InheritedByGraph type~sdr_subresolution_type sdr_subresolution_type type~sdr_confhead_type sdr_confHead_type type~sdr_confhead_type->type~sdr_subresolution_type subresolution Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: polydegree Degree for the polynomials to use in the subelement resolution. character(len=1), public :: polyspace Identification of the polynomial space to use. type(ply_prj_init_type), public :: projection Definition of conversions between modal and nodal values. type( ply_prj_header_type ), public :: project_header Header definition of the projection header. Stored here for later output in the subresolution file. integer, public :: nLevels Number of levels to use for the resolution of boundaries within elements. By default this value is automatically determined by the polydegree and\nthe point set that is to be used. But that can be explicitly overwritten\nby the user with an arbitrary value here.\nIf there is no subresolution to be done, this value will be 0. type( dyn_labelarray_type ), public :: default_colors Dynamic array to store the color names, for which the default boundary\nresolution should reach subelements. All boundaries with this color will by default have subelement\nresolution, but this default can still be overwritten by the attribute\nsetting of the boundary. type( sdr_subres_fills_type ), public :: color_values Definition of the values to use for color filling and color voids. integer, public, allocatable :: value_pos (:) Position of value definitions for each color in the mesh.","tags":"","url":"type/sdr_subresolution_type.html"},{"title":"ply_filter_element – Seeder","text":"interface public  subroutine ply_filter_element(me, element_degree, element_data) Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Parameters of the filter. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in element. The first index describes the\ndegrees of freedom. The second index refers to the elements to filter. Description Filter the polynomial data in a given element.","tags":"","url":"interface/ply_filter_element.html"},{"title":"ply_split_element – Seeder","text":"interface public  subroutine ply_split_element(parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Elements follow the ordering of the Z space filling curve. logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. This can be used as a simple lowpass filter by ignoring all higher\nmodes from the parent element, that exceed the target polynomial\ndegree. Thus, the polynomials are filtered before projection,\ninstead of cutting them only of after refinement.\nDefaults to false (no filtering). Description Split elements of degree parent_degree into elements with polynomials of\ndegree child_degree.","tags":"","url":"interface/ply_split_element.html"},{"title":"sdr_load_ellipsoid – Seeder","text":"public  subroutine sdr_load_ellipsoid(sphArray, spaObjArray, attr_pos, transform, conf, thandle) Load ellipsoid information from config file. Arguments Type Intent Optional Attributes Name type( grw_ellipsoidarray_type ), intent(inout) :: sphArray growing array of ellipsoids type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle Calls proc~~sdr_load_ellipsoid~~CallsGraph proc~sdr_load_ellipsoid sdr_load_ellipsoid append append proc~sdr_load_ellipsoid->append tem_load_ellipsoid tem_load_ellipsoid proc~sdr_load_ellipsoid->tem_load_ellipsoid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_ellipsoid~~CalledByGraph proc~sdr_load_ellipsoid sdr_load_ellipsoid proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_ellipsoid proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_ellipsoid.html"},{"title":"isEqual – Seeder","text":"private pure function isEqual(left, right) result(equality) This function provides the test for equality of two projections. Two l2p header are considered to be equal, if their node_header,\nand the factor are equal. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? Called by proc~~isequal~~CalledByGraph proc~isequal isEqual interface~operator(==) operator(==) interface~operator(==)->proc~isequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isequal.html"},{"title":"isUnequal – Seeder","text":"private pure function isUnequal(left, right) result(unequality) This function provides the test for unequality of two projections. Two l2p header are considered to be unequal, if their node_header,\nor the factor are not equal. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? Called by proc~~isunequal~~CalledByGraph proc~isunequal isUnequal interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~isunequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isunequal.html"},{"title":"isSmaller – Seeder","text":"private pure function isSmaller(left, right) result(small) This function provides a < comparison of two projections. Sorting of l2p header is given by node_header and by the factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmaller~~CalledByGraph proc~issmaller isSmaller interface~operator(lt) operator(<) interface~operator(lt)->proc~issmaller Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmaller.html"},{"title":"isSmallerOrEqual – Seeder","text":"private pure function isSmallerOrEqual(left, right) result(small) This function provides a <= comparison of two projections. Sorting of l2p header is given by node_header, l2p_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmallerorequal~~CalledByGraph proc~issmallerorequal isSmallerOrEqual interface~operator(lt=) operator(<=) interface~operator(lt=)->proc~issmallerorequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmallerorequal.html"},{"title":"isGreater – Seeder","text":"private pure function isGreater(left, right) result(great) This function provides a > comparison of two projections. Sorting of l2p header is given by node_header, l2p_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreater~~CalledByGraph proc~isgreater isGreater interface~operator(gt) operator(>) interface~operator(gt)->proc~isgreater Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreater.html"},{"title":"isGreaterOrEqual – Seeder","text":"private pure function isGreaterOrEqual(left, right) result(great) This function provides a >= comparison of two projections. Sorting of l2p header is given by node_header, l2p_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreaterorequal~~CalledByGraph proc~isgreaterorequal isGreaterOrEqual interface~operator(gt=) operator(>=) interface~operator(gt=)->proc~isgreaterorequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreaterorequal.html"},{"title":"ply_l2p_header_load – Seeder","text":"public  subroutine ply_l2p_header_load(me, conf, thandle) Load settings to describe a projection method from a Lua table. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: me type( flu_State ), intent(inout) :: conf integer, intent(in) :: thandle Calls proc~~ply_l2p_header_load~~CallsGraph proc~ply_l2p_header_load ply_l2p_header_load aot_get_val aot_get_val proc~ply_l2p_header_load->aot_get_val tem_abort tem_abort proc~ply_l2p_header_load->tem_abort upper_to_lower upper_to_lower proc~ply_l2p_header_load->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_l2p_header_load~~CalledByGraph proc~ply_l2p_header_load ply_l2p_header_load proc~ply_prj_header_load ply_prj_header_load proc~ply_prj_header_load->proc~ply_l2p_header_load proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2p_header_load.html"},{"title":"ply_l2p_header_define – Seeder","text":"public  subroutine ply_l2p_header_define(me, factor, nodes_kind, lobattoPoints) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: me L2P header to define. integer, intent(in), optional :: factor Oversampling factor to use in the projection, defaults to 1. character(len=*), optional :: nodes_kind Set of nodes to use in the nodal representation. May be 'gauss-legendre' or 'chebyshev', defaults to 'gauss-legendre' logical, intent(in), optional :: lobattoPoints Wether to use Lobatto points (include interval bounds) when using the\nchebyshev nodes, defaults to .false.. Calls proc~~ply_l2p_header_define~~CallsGraph proc~ply_l2p_header_define ply_l2p_header_define tem_abort tem_abort proc~ply_l2p_header_define->tem_abort upper_to_lower upper_to_lower proc~ply_l2p_header_define->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2p_header_define.html"},{"title":"ply_l2p_header_out – Seeder","text":"public  subroutine ply_l2p_header_out(me, conf) Write L2P settings into a Lua table. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: me type( aot_out_type ), intent(inout) :: conf Calls proc~~ply_l2p_header_out~~CallsGraph proc~ply_l2p_header_out ply_l2p_header_out aot_out_val aot_out_val proc~ply_l2p_header_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_l2p_header_out~~CalledByGraph proc~ply_l2p_header_out ply_l2p_header_out proc~ply_prj_header_out ply_prj_header_out proc~ply_prj_header_out->proc~ply_l2p_header_out proc~sdr_dump_treelm sdr_dump_treelm proc~sdr_dump_treelm->proc~ply_prj_header_out program~seeder seeder program~seeder->proc~sdr_dump_treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2p_header_out.html"},{"title":"ply_l2p_header_display – Seeder","text":"public  subroutine ply_l2p_header_display(me) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: me Called by proc~~ply_l2p_header_display~~CalledByGraph proc~ply_l2p_header_display ply_l2p_header_display proc~ply_prj_header_load ply_prj_header_load proc~ply_prj_header_load->proc~ply_l2p_header_display proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2p_header_display.html"},{"title":"Copy_l2p_header – Seeder","text":"private pure subroutine Copy_l2p_header(left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: left fpt to copy to type( ply_l2p_header_type ), intent(in) :: right fpt to copy from Called by proc~~copy_l2p_header~~CalledByGraph proc~copy_l2p_header Copy_l2p_header interface~assignment(=) assignment(=) interface~assignment(=)->proc~copy_l2p_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/copy_l2p_header.html"},{"title":"assignment(=) – Seeder","text":"public interface assignment(=) Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~copy_l2p_header Copy_l2p_header interface~assignment(=)->proc~copy_l2p_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine Copy_l2p_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: left fpt to copy to type( ply_l2p_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"interface/assignment(=).html"},{"title":"operator(==) – Seeder","text":"public interface operator(==) Calls interface~~operator(==)~~CallsGraph interface~operator(==) operator(==) proc~isequal isEqual interface~operator(==)->proc~isequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is equal??","tags":"","url":"interface/operator(==).html"},{"title":"operator(/=) – Seeder","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~~CallsGraph interface~operator(SLASH=) operator(/=) proc~isunequal isUnequal interface~operator(SLASH=)->proc~isunequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal??","tags":"","url":"interface/operator(SLASH=).html"},{"title":"operator(<) – Seeder","text":"public interface operator(<) Calls interface~~operator(lt)~~CallsGraph interface~operator(lt) operator(<) proc~issmaller isSmaller interface~operator(lt)->proc~issmaller Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt).html"},{"title":"operator(<=) – Seeder","text":"public interface operator(<=) Calls interface~~operator(lt=)~~CallsGraph interface~operator(lt=) operator(<=) proc~issmallerorequal isSmallerOrEqual interface~operator(lt=)->proc~issmallerorequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt=).html"},{"title":"operator(>) – Seeder","text":"public interface operator(>) Calls interface~~operator(gt)~~CallsGraph interface~operator(gt) operator(>) proc~isgreater isGreater interface~operator(gt)->proc~isgreater Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt).html"},{"title":"operator(>=) – Seeder","text":"public interface operator(>=) Calls interface~~operator(gt=)~~CallsGraph interface~operator(gt=) operator(>=) proc~isgreaterorequal isGreaterOrEqual interface~operator(gt=)->proc~isgreaterorequal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt=).html"},{"title":"sdr_load_sphere – Seeder","text":"public  subroutine sdr_load_sphere(sphArray, spaObjArray, attr_pos, transform, conf, thandle) Load sphere information from config file. Arguments Type Intent Optional Attributes Name type( grw_spherearray_type ), intent(inout) :: sphArray growing array of spheres type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle Calls proc~~sdr_load_sphere~~CallsGraph proc~sdr_load_sphere sdr_load_sphere append append proc~sdr_load_sphere->append tem_load_sphere tem_load_sphere proc~sdr_load_sphere->tem_load_sphere Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_sphere~~CalledByGraph proc~sdr_load_sphere sdr_load_sphere proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_sphere proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_sphere.html"},{"title":"sdr_node_neighbors – Seeder","text":"public  function sdr_node_neighbors(me, level_offset, iNode, coord) result(neighbors) This routine identifies the 6 direct neighbors of a node in the prototree Todo We could cut the lookups of neighbors in the complete tree\n      by one half, if we set the siblings within the same\n      direct parent by their in-node relation (all 8 siblings within a\n      parent either exist or do not exist at all).\n      We than would have to iterate only over the remaining\n      three outer sides of each node here. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: me neighbors are identified for this tree and neighbor of each node\nare stored at link_pos of each node in node_data type integer(kind=long_k), intent(in), optional :: level_offset First treeID on level integer, intent(in) :: iNode Node position in protoTree integer, intent(in), optional :: coord (4) if coord is present, no need to compute using tem_coordOfID Return Value integer, (6) Calls proc~~sdr_node_neighbors~~CallsGraph proc~sdr_node_neighbors sdr_node_neighbors positionofval positionofval proc~sdr_node_neighbors->positionofval tem_CoordOfId tem_CoordOfId proc~sdr_node_neighbors->tem_CoordOfId tem_IdOfCoord tem_IdOfCoord proc~sdr_node_neighbors->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_node_neighbors->tem_ParentOf val val proc~sdr_node_neighbors->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_node_neighbors~~CalledByGraph proc~sdr_node_neighbors sdr_node_neighbors proc~sdr_build_prototree sdr_build_protoTree proc~sdr_build_prototree->proc~sdr_node_neighbors program~seeder seeder program~seeder->proc~sdr_build_prototree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_node_neighbors.html"},{"title":"sdr_neighbor_in_proto – Seeder","text":"public  function sdr_neighbor_in_proto(proto, coord, iDir, neighbor_level) result(pos) Find the neighbor position in protoTree for iDir on the same level \nor on any one above. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree integer, intent(in) :: coord (4) integer, intent(in) :: iDir integer, intent(out) :: neighbor_level Return Value integer Calls proc~~sdr_neighbor_in_proto~~CallsGraph proc~sdr_neighbor_in_proto sdr_neighbor_in_proto positionofval positionofval proc~sdr_neighbor_in_proto->positionofval tem_IdOfCoord tem_IdOfCoord proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_neighbor_in_proto~~CalledByGraph proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~check_bndlevel check_bndLevel proc~check_bndlevel->proc~sdr_neighbor_in_proto proc~create_target create_target proc~create_target->proc~sdr_neighbor_in_proto proc~flood_periphery_diagonal flood_periphery_diagonal proc~flood_periphery_diagonal->proc~sdr_neighbor_in_proto proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~sdr_neighbor_in_proto proc~sdr_mark_neighborhasbnd sdr_mark_neighborHasBnd proc~sdr_mark_neighborhasbnd->proc~sdr_neighbor_in_proto proc~flood_periphery flood_periphery proc~flood_periphery->proc~flood_periphery_diagonal proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~sdr_build_prototree sdr_build_protoTree proc~sdr_build_prototree->proc~sdr_mark_neighborhasbnd proc~sdr_refine_leaf sdr_refine_leaf proc~sdr_refine_leaf->proc~check_bndlevel proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~flood_periphery proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_build_prototree program~seeder->proc~sdr_refine_leaf program~seeder->proc~sdr_flood_tree program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_neighbor_in_proto.html"},{"title":"protoData_ofNode – Seeder","text":"private  function protoData_ofNode(node_pos, proto, geometry, level) result(protodata) Small helping routine to get the variable data from a leaf. Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos type( sdr_protoTree_type ), intent(in) :: proto type( sdr_geometry_type ), intent(in) :: geometry integer, intent(in) :: level Return Value real(kind=rk), (11+proto%node%nColors) Calls proc~~protodata_ofnode~~CallsGraph proc~protodata_ofnode protoData_ofNode sdr_nodeprop_btest sdr_nodeprop_btest proc~protodata_ofnode->sdr_nodeprop_btest val val proc~protodata_ofnode->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~protodata_ofnode~~CalledByGraph proc~protodata_ofnode protoData_ofNode proc~sdr_write_proto_as_restart sdr_write_proto_as_restart proc~sdr_write_proto_as_restart->proc~protodata_ofnode proc~write_childleaves write_childLeaves proc~sdr_write_proto_as_restart->proc~write_childleaves proc~write_childleaves->proc~protodata_ofnode proc~write_childleaves->proc~write_childleaves proc~floodwaves_tree floodwaves_tree proc~floodwaves_tree->proc~sdr_write_proto_as_restart program~seeder seeder program~seeder->proc~sdr_write_proto_as_restart proc~sdr_flood_tree sdr_flood_tree program~seeder->proc~sdr_flood_tree proc~sdr_flood_tree->proc~floodwaves_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/protodata_ofnode.html"},{"title":"sdr_build_protoTree – Seeder","text":"public  subroutine sdr_build_protoTree(me, geometry, header) This routine builds the preliminary tree with geometry intersection and\nneighbor identification Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(out) :: me preliminary tree created by this routine type( sdr_geometry_type ), intent(inout) :: geometry type which contains all geometry object infos type( sdr_confHead_type ), intent(inout) :: header some global information on solver name and version Calls proc~~sdr_build_prototree~~CallsGraph proc~sdr_build_prototree sdr_build_protoTree append append proc~sdr_build_prototree->append init init proc~sdr_build_prototree->init proc~create_children create_children proc~sdr_build_prototree->proc~create_children proc~sdr_append_distancerefineobject sdr_append_distanceRefineObject proc~sdr_build_prototree->proc~sdr_append_distancerefineobject proc~sdr_mark_neighborhasbnd sdr_mark_neighborHasBnd proc~sdr_build_prototree->proc~sdr_mark_neighborhasbnd proc~sdr_node_neighbors sdr_node_neighbors proc~sdr_build_prototree->proc~sdr_node_neighbors sdr_any_bc_distancerefine sdr_any_bc_distancerefine proc~sdr_build_prototree->sdr_any_bc_distancerefine sdr_any_bc_subresolution sdr_any_bc_subresolution proc~sdr_build_prototree->sdr_any_bc_subresolution sdr_clear_nodeprop_bit sdr_clear_nodeprop_bit proc~sdr_build_prototree->sdr_clear_nodeprop_bit sdr_mark_floodnode sdr_mark_floodnode proc~sdr_build_prototree->sdr_mark_floodnode sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_build_prototree->sdr_nodeprop_btest sdr_set_nodeprop_bit sdr_set_nodeprop_bit proc~sdr_build_prototree->sdr_set_nodeprop_bit sdr_wetneighborsface sdr_wetneighborsface proc~sdr_build_prototree->sdr_wetneighborsface tem_CoordOfId tem_CoordOfId proc~sdr_build_prototree->tem_CoordOfId tem_FirstIdAtLevel tem_FirstIdAtLevel proc~sdr_build_prototree->tem_FirstIdAtLevel tem_abort tem_abort proc~sdr_build_prototree->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~sdr_build_prototree->tem_horizontalSpacer tem_startTimer tem_startTimer proc~sdr_build_prototree->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_build_prototree->tem_stopTimer truncate truncate proc~sdr_build_prototree->truncate uni_name uni_name proc~sdr_build_prototree->uni_name val val proc~sdr_build_prototree->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_build_prototree~~CalledByGraph proc~sdr_build_prototree sdr_build_protoTree program~seeder seeder program~seeder->proc~sdr_build_prototree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_build_prototree.html"},{"title":"sdr_write_proto_as_restart – Seeder","text":"public  subroutine sdr_write_proto_as_restart(proto, geometry, itime, header, prefix) Write current leaves of the prototree as treelm restart. This routine is mainly for debugging, to allow the visualization of the\ntree with harvester. The mesh will not contain any properties, instead\nadditional data is provided as restart.\nNote that recursive output is used, to write each leaf node on its own,\nthis output is thus really only useful for debugging, and might take very\nlong for large meshes, however memory consumption should be fairly small. Todo SDR_write_proto_as_restart is a explicitly serial routine, deploying\n      its own writing to save memory. Therefore this is some code\n      duplication from treelmesh_module::dump_treelmesh. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto The prototree to output. type( sdr_geometry_type ), intent(in) :: geometry Bounding cube, the prototree lives in. integer, intent(in) :: itime wave number in character format to prepend to filenames and timestamp type( sdr_confHead_type ), intent(in) :: header some global information on solver name and version character(len=*), intent(in), optional :: prefix prefix for filenames Calls proc~~sdr_write_proto_as_restart~~CallsGraph proc~sdr_write_proto_as_restart sdr_write_proto_as_restart dump_tem_global dump_tem_global proc~sdr_write_proto_as_restart->dump_tem_global newunit newunit proc~sdr_write_proto_as_restart->newunit proc~protodata_ofnode protoData_ofNode proc~sdr_write_proto_as_restart->proc~protodata_ofnode proc~write_childleaves write_childLeaves proc~sdr_write_proto_as_restart->proc~write_childleaves sdr_append_protovar sdr_append_protovar proc~sdr_write_proto_as_restart->sdr_append_protovar sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_write_proto_as_restart->sdr_nodeprop_btest tem_create_varMap tem_create_varMap proc~sdr_write_proto_as_restart->tem_create_varMap tem_restart_writeHeader tem_restart_writeHeader proc~sdr_write_proto_as_restart->tem_restart_writeHeader tem_solverTag tem_solverTag proc~sdr_write_proto_as_restart->tem_solverTag tem_varSys_init tem_varSys_init proc~sdr_write_proto_as_restart->tem_varSys_init val val proc~sdr_write_proto_as_restart->val proc~protodata_ofnode->sdr_nodeprop_btest proc~protodata_ofnode->val proc~write_childleaves->proc~protodata_ofnode proc~write_childleaves->proc~write_childleaves proc~write_childleaves->sdr_nodeprop_btest proc~write_childleaves->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_write_proto_as_restart~~CalledByGraph proc~sdr_write_proto_as_restart sdr_write_proto_as_restart proc~floodwaves_tree floodwaves_tree proc~floodwaves_tree->proc~sdr_write_proto_as_restart program~seeder seeder program~seeder->proc~sdr_write_proto_as_restart proc~sdr_flood_tree sdr_flood_tree program~seeder->proc~sdr_flood_tree proc~sdr_flood_tree->proc~floodwaves_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_write_proto_as_restart.html"},{"title":"create_children – Seeder","text":"private  subroutine create_children(me, parent, geometry, leVal, testAll, minlevel) This routine creates children for each parent if children\n intersect with boundary object. First loop over 8 children, and test for intersection of each child cube\n with the geometry objects inherited from the parent node.\n Then check for various object kinds, that might be intersected:\n If BOUNDARY objects are intersected, record the minimal bcID for later,\n boundaries are only marked as a leaf if the maxlevel has been reached.\n If NO BOUNDARY are intersected, the refinement can stop early here, and\n the node is marked as leaf. This avoids overly many elements before\n flooding.\n If a leaf is intersecting a SEED object, mark it already as flooded here.\n Children that do not intersect any objects do not need to be refined\n further at this stage and are marked as leaf nodes. Todo HK: The content of the childLoop should probably move into its\n          own subroutine, it could then also be used to define the root\n          node (treeID=0). Though this might just add a 9th check on\n          all defined objects in most cases. Needs further thinking. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: me preliminary tree on which childern are created integer, intent(in) :: parent Position of parent node on the growing array of node_treeID and node_data\nin preliminary tree type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos type( levelValues_type ), intent(in) :: leVal contains information on current level on which children are created logical, intent(in) :: testAll testAll objects only for root node integer, intent(in) :: minlevel Calls proc~~create_children~~CallsGraph proc~create_children create_children append append proc~create_children->append bc_color_id bc_color_id proc~create_children->bc_color_id proc~is_intersecting is_intersecting proc~create_children->proc~is_intersecting proc~mark_leafnode mark_leafNode proc~create_children->proc~mark_leafnode sdr_append_childintersectedobject sdr_append_childintersectedobject proc~create_children->sdr_append_childintersectedobject sdr_inheritbnd_eligiblechildren sdr_inheritbnd_eligiblechildren proc~create_children->sdr_inheritbnd_eligiblechildren sdr_mark_floodnode sdr_mark_floodnode proc~create_children->sdr_mark_floodnode sdr_set_nodeprop_bit sdr_set_nodeprop_bit proc~create_children->sdr_set_nodeprop_bit tem_CoordOfId tem_CoordOfId proc~create_children->tem_CoordOfId tem_directChildren tem_directChildren proc~create_children->tem_directChildren val val proc~create_children->val proc~is_intersecting->val sdr_periodicplanecubeoverlap sdr_periodicplanecubeoverlap proc~is_intersecting->sdr_periodicplanecubeoverlap sdr_spacerinterwovencubeoverlap sdr_spacerinterwovencubeoverlap proc~is_intersecting->sdr_spacerinterwovencubeoverlap tem_boxCubeOverlap tem_boxCubeOverlap proc~is_intersecting->tem_boxCubeOverlap tem_cylinderCubeOverlap tem_cylinderCubeOverlap proc~is_intersecting->tem_cylinderCubeOverlap tem_ellipsoidCubeOverlap tem_ellipsoidCubeOverlap proc~is_intersecting->tem_ellipsoidCubeOverlap tem_lineCubeOverlap tem_lineCubeOverlap proc~is_intersecting->tem_lineCubeOverlap tem_pointCubeOverlap tem_pointCubeOverlap proc~is_intersecting->tem_pointCubeOverlap tem_sphereCubeOverlap tem_sphereCubeOverlap proc~is_intersecting->tem_sphereCubeOverlap tem_triangleCubeOverlap tem_triangleCubeOverlap proc~is_intersecting->tem_triangleCubeOverlap proc~mark_leafnode->sdr_set_nodeprop_bit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_children~~CalledByGraph proc~create_children create_children proc~sdr_build_prototree sdr_build_protoTree proc~sdr_build_prototree->proc~create_children program~seeder seeder program~seeder->proc~sdr_build_prototree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/create_children.html"},{"title":"mark_leafNode – Seeder","text":"private  subroutine mark_leafNode(me, node_pos) Small helping routine to keep track of leaf nodes. Todo HK: Originally this operation was inlined in create_children in\n          a few places. Need to check for performance impact? Readability\n          was not hurt too much by this, but it was changed into a flag and\n          final decision, which in my opinion did not improve the\n          readability as the reader has to track down the location where the\n          final decision is taken, and introduces an additional if.\n          It might be that the compiler is smart enough on both variants\n          but anyway, I would prefer such a small routine if you think\n          inlining is too burdensome.\n          We should have an eye on the performance, though. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: me Property bit mask to set the leaf bit in integer, intent(in) :: node_pos Calls proc~~mark_leafnode~~CallsGraph proc~mark_leafnode mark_leafNode sdr_set_nodeprop_bit sdr_set_nodeprop_bit proc~mark_leafnode->sdr_set_nodeprop_bit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mark_leafnode~~CalledByGraph proc~mark_leafnode mark_leafNode proc~create_children create_children proc~create_children->proc~mark_leafnode proc~sdr_build_prototree sdr_build_protoTree proc~sdr_build_prototree->proc~create_children program~seeder seeder program~seeder->proc~sdr_build_prototree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/mark_leafnode.html"},{"title":"sdr_mark_neighborHasBnd – Seeder","text":"private  subroutine sdr_mark_neighborHasBnd(proto, coord) This routine marks 26 direct neighbors as has boundary bit Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto neighbors are identified for this tree and neighbors\nas marked with hasBoundary_bit integer, intent(in) :: coord (4) Coordinate of current node Calls proc~~sdr_mark_neighborhasbnd~~CallsGraph proc~sdr_mark_neighborhasbnd sdr_mark_neighborHasBnd proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~sdr_mark_neighborhasbnd->proc~sdr_neighbor_in_proto sdr_set_nodeprop_bit sdr_set_nodeprop_bit proc~sdr_mark_neighborhasbnd->sdr_set_nodeprop_bit val val proc~sdr_mark_neighborhasbnd->val positionofval positionofval proc~sdr_neighbor_in_proto->positionofval tem_IdOfCoord tem_IdOfCoord proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_mark_neighborhasbnd~~CalledByGraph proc~sdr_mark_neighborhasbnd sdr_mark_neighborHasBnd proc~sdr_build_prototree sdr_build_protoTree proc~sdr_build_prototree->proc~sdr_mark_neighborhasbnd program~seeder seeder program~seeder->proc~sdr_build_prototree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_mark_neighborhasbnd.html"},{"title":"write_childLeaves – Seeder","text":"private recursive subroutine write_childLeaves(meshunit, restunit, iLeaf, node_pos, proto, geometry, level) Small helping routine to write leaves in order into a treelmesh formatted\nfile. Arguments Type Intent Optional Attributes Name integer, intent(in) :: meshunit integer, intent(in) :: restunit integer, intent(inout) :: iLeaf integer, intent(in) :: node_pos type( sdr_protoTree_type ), intent(in) :: proto type( sdr_geometry_type ), intent(in) :: geometry integer, intent(in) :: level Calls proc~~write_childleaves~~CallsGraph proc~write_childleaves write_childLeaves proc~write_childleaves->proc~write_childleaves proc~protodata_ofnode protoData_ofNode proc~write_childleaves->proc~protodata_ofnode sdr_nodeprop_btest sdr_nodeprop_btest proc~write_childleaves->sdr_nodeprop_btest val val proc~write_childleaves->val proc~protodata_ofnode->sdr_nodeprop_btest proc~protodata_ofnode->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_childleaves~~CalledByGraph proc~write_childleaves write_childLeaves proc~write_childleaves->proc~write_childleaves proc~sdr_write_proto_as_restart sdr_write_proto_as_restart proc~sdr_write_proto_as_restart->proc~write_childleaves proc~floodwaves_tree floodwaves_tree proc~floodwaves_tree->proc~sdr_write_proto_as_restart program~seeder seeder program~seeder->proc~sdr_write_proto_as_restart proc~sdr_flood_tree sdr_flood_tree program~seeder->proc~sdr_flood_tree proc~sdr_flood_tree->proc~floodwaves_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/write_childleaves.html"},{"title":"ply_sampling_adaptive_load – Seeder","text":"public  subroutine ply_sampling_adaptive_load(me, conf, parent) Load the configuration for adaptive subsampling. Arguments Type Intent Optional Attributes Name type( ply_sampling_adaptive_type ), intent(out) :: me Sampling definition to load. type( flu_State ), intent(in) :: conf Configuration to read the sampling settings from. integer, intent(in), optional :: parent Parent table in which to look for the adaptive sampling settings. Calls proc~~ply_sampling_adaptive_load~~CallsGraph proc~ply_sampling_adaptive_load ply_sampling_adaptive_load aot_get_val aot_get_val proc~ply_sampling_adaptive_load->aot_get_val proc~ply_filter_element_load ply_filter_element_load proc~ply_sampling_adaptive_load->proc~ply_filter_element_load tem_abort tem_abort proc~ply_sampling_adaptive_load->tem_abort upper_to_lower upper_to_lower proc~ply_sampling_adaptive_load->upper_to_lower proc~ply_filter_element_load->aot_get_val proc~ply_filter_element_load->tem_abort proc~ply_filter_element_load->upper_to_lower aot_table_close aot_table_close proc~ply_filter_element_load->aot_table_close aot_table_open aot_table_open proc~ply_filter_element_load->aot_table_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampling_adaptive_load.html"},{"title":"ply_sample_adaptive – Seeder","text":"public  subroutine ply_sample_adaptive(me, ndims, orig_mesh, orig_bcs, varsys, var_degree, lvl_degree, trackInst, trackConfig, time, new_mesh, resvars) Sample data described by varsys in orig_mesh according to the tracking\nobject trackInst with adaptive refinements. Only works for Q-Polynomials. Arguments Type Intent Optional Attributes Name type( ply_sampling_adaptive_type ), intent(in) :: me A ply_sampling_type to describe the sampling method. integer, intent(in) :: ndims Number of dimensions in the polynomial representation. type( treelmesh_type ), intent(in) :: orig_mesh The original mesh to be refined. type( tem_BC_prop_type ), intent(in) :: orig_bcs Boundary conditions for the original mesh. type( tem_varSys_type ), intent(in) :: varsys Variable system of the original data to do the sampling on. integer, intent(in) :: var_degree (:) Maximal polynomial degree for each variable. Needs to be matching the variable definition in the variable system. Todo Needs to be changed to be an information per element per variable!\n      Possibly by defining a variable in the varsys, providing the\n      degree. integer, intent(in) :: lvl_degree (:) Maximal polynomial degree for each level. type( tem_tracking_instance_type ), intent(in) :: trackInst Tracking object describing what to sample. type( tem_tracking_config_type ), intent(in) :: trackConfig Tracking configuration with the geometry to obtain from the overall mesh. type( tem_time_type ), intent(in) :: time Point in time to get the data for. type( treelmesh_type ), intent(out) :: new_mesh The new mesh with the refined elements. type( tem_varSys_type ), intent(out) :: resvars Resulting system of variables describing the data in the arrays of\nsubsampled elements. Calls proc~~ply_sample_adaptive~~CallsGraph proc~ply_sample_adaptive ply_sample_adaptive mpi_allreduce mpi_allreduce proc~ply_sample_adaptive->mpi_allreduce proc~ply_sampling_var_allocate ply_sampling_var_allocate proc~ply_sample_adaptive->proc~ply_sampling_var_allocate proc~ply_sampling_var_compute_elemdev ply_sampling_var_compute_elemdev proc~ply_sample_adaptive->proc~ply_sampling_var_compute_elemdev proc~ply_sampling_var_move ply_sampling_var_move proc~ply_sample_adaptive->proc~ply_sampling_var_move proc~ply_sampling_varsys_for_track ply_sampling_varsys_for_track proc~ply_sample_adaptive->proc~ply_sampling_varsys_for_track proc~ply_split_element_init ply_split_element_init proc~ply_sample_adaptive->proc~ply_split_element_init property property proc~ply_sample_adaptive->property tem_LevelOf tem_LevelOf proc~ply_sample_adaptive->tem_LevelOf tem_bc_prop_pos tem_bc_prop_pos proc~ply_sample_adaptive->tem_bc_prop_pos tem_bc_prop_sublist tem_bc_prop_sublist proc~ply_sample_adaptive->tem_bc_prop_sublist tem_create_subTree_of tem_create_subTree_of proc~ply_sample_adaptive->tem_create_subTree_of tem_create_tree_from_sub tem_create_tree_from_sub proc~ply_sample_adaptive->tem_create_tree_from_sub tem_destroy_subTree tem_destroy_subTree proc~ply_sample_adaptive->tem_destroy_subTree tem_refine_global_subtree tem_refine_global_subtree proc~ply_sample_adaptive->tem_refine_global_subtree tem_subTree_from tem_subTree_from proc~ply_sample_adaptive->tem_subTree_from tem_varSys_append_stateVar tem_varSys_append_stateVar proc~ply_sample_adaptive->tem_varSys_append_stateVar val val proc~ply_sample_adaptive->val proc~ply_sampling_varsys_for_track->proc~ply_sampling_var_allocate proc~ply_sampling_varsys_for_track->tem_LevelOf proc~ply_sampling_varsys_for_track->val get_element get_element proc~ply_sampling_varsys_for_track->get_element tem_varSys_init tem_varSys_init proc~ply_sampling_varsys_for_track->tem_varSys_init proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~alpha alpha proc~ply_split_legendre_matrix->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix->proc~alpha_frac proc~beta beta proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sample_adaptive.html"},{"title":"get_sampled_element – Seeder","text":"private  subroutine get_sampled_element(fun, varSys, elempos, time, tree, n, nDofs, res) Get sampled data. This routine provides the get_element function of the variable definition\nto access the sampled data array obtained by ply_sample_data. Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) TreeID of the element to get the variable for. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: n Number of elements to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(nComponents of resulting variable) x (nDegrees of freedom) x (nElems)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp","tags":"","url":"proc/get_sampled_element.html"},{"title":"sdr_load_canonicalND – Seeder","text":"public  subroutine sdr_load_canonicalND(pntArray, lineArray, triArray, boxArray, spaObjArray, attr_pos, transform, conf, thandle) This routine loads canonical geometrial objects like point, line, plane \nand box and add them to the growing array of each primitive geometries\nand the position of this geometries are stored in the growing array\nof spatialObject Arguments Type Intent Optional Attributes Name type( grw_pointarray_type ), intent(inout) :: pntArray growing array of points type( grw_linearray_type ), intent(inout) :: lineArray growing array of line type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type( grw_boxarray_type ), intent(inout) :: boxArray growing array of boxes type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle Calls proc~~sdr_load_canonicalnd~~CallsGraph proc~sdr_load_canonicalnd sdr_load_canonicalND proc~append_canondboxtosdrbox append_CanoNDBoxToSdrBox proc~sdr_load_canonicalnd->proc~append_canondboxtosdrbox proc~append_canondboxtotriangle append_CanoNDBoxToTriangle proc~sdr_load_canonicalnd->proc~append_canondboxtotriangle proc~append_canondlinetosdrline append_CanoNDLineToSdrLine proc~sdr_load_canonicalnd->proc~append_canondlinetosdrline proc~append_canondplanetotriangle append_CanoNDPlaneToTriangle proc~sdr_load_canonicalnd->proc~append_canondplanetotriangle proc~append_canondpointtosdrpoint append_CanoNDPointToSdrPoint proc~sdr_load_canonicalnd->proc~append_canondpointtosdrpoint tem_load_canonicalND tem_load_canonicalND proc~sdr_load_canonicalnd->tem_load_canonicalND upper_to_lower upper_to_lower proc~sdr_load_canonicalnd->upper_to_lower append append proc~append_canondboxtosdrbox->append proc~append_canondboxtotriangle->proc~append_canondplanetotriangle proc~append_canondlinetosdrline->append proc~append_canondplanetotriangle->append proc~append_canondpointtosdrpoint->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_canonicalnd~~CalledByGraph proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_canonicalnd.html"},{"title":"append_CanoNDPointToSdrPoint – Seeder","text":"public  subroutine append_CanoNDPointToSdrPoint(canopoint, pntArray, spaObjArray, attr_pos) This routine convert canonical point to seeder point array Arguments Type Intent Optional Attributes Name type( tem_point_type ), intent(in) :: canopoint canonical point object type type( grw_pointarray_type ), intent(inout) :: pntArray growing array of points type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type Calls proc~~append_canondpointtosdrpoint~~CallsGraph proc~append_canondpointtosdrpoint append_CanoNDPointToSdrPoint append append proc~append_canondpointtosdrpoint->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~append_canondpointtosdrpoint~~CalledByGraph proc~append_canondpointtosdrpoint append_CanoNDPointToSdrPoint proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_canonicalnd->proc~append_canondpointtosdrpoint proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/append_canondpointtosdrpoint.html"},{"title":"append_CanoNDLineToSdrLine – Seeder","text":"public  subroutine append_CanoNDLineToSdrLine(canoline, lineArray, spaObjArray, attr_pos) This routine convert canonical line to seeder line array Arguments Type Intent Optional Attributes Name type( tem_line_type ), intent(in) :: canoline canonical geometry line object type type( grw_linearray_type ), intent(inout) :: lineArray growing array of line type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type Calls proc~~append_canondlinetosdrline~~CallsGraph proc~append_canondlinetosdrline append_CanoNDLineToSdrLine append append proc~append_canondlinetosdrline->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~append_canondlinetosdrline~~CalledByGraph proc~append_canondlinetosdrline append_CanoNDLineToSdrLine proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_canonicalnd->proc~append_canondlinetosdrline proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/append_canondlinetosdrline.html"},{"title":"append_CanoNDBoxToTriangle – Seeder","text":"public  subroutine append_CanoNDBoxToTriangle(canoBox, triArray, spaObjArray, attr_pos) This routine convert box to planes and then planes to triangles\nand add triangle to growing array and add position of triangle into \nspatialObj%primitive_position Arguments Type Intent Optional Attributes Name type( tem_box_type ), intent(in) :: canoBox canonical geometry box object type type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type Calls proc~~append_canondboxtotriangle~~CallsGraph proc~append_canondboxtotriangle append_CanoNDBoxToTriangle proc~append_canondplanetotriangle append_CanoNDPlaneToTriangle proc~append_canondboxtotriangle->proc~append_canondplanetotriangle append append proc~append_canondplanetotriangle->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~append_canondboxtotriangle~~CalledByGraph proc~append_canondboxtotriangle append_CanoNDBoxToTriangle proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_canonicalnd->proc~append_canondboxtotriangle proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/append_canondboxtotriangle.html"},{"title":"append_CanoNDPlaneToTriangle – Seeder","text":"public  subroutine append_CanoNDPlaneToTriangle(plane, triArray, spaObjArray, attr_pos) This routine convert plane to triangle and add triangle to \ngrowing array and add position of triangle into \nspatialObj%primitive_position Arguments Type Intent Optional Attributes Name type( tem_plane_type ), intent(in) :: plane canonical plane geometry object type type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type Calls proc~~append_canondplanetotriangle~~CallsGraph proc~append_canondplanetotriangle append_CanoNDPlaneToTriangle append append proc~append_canondplanetotriangle->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~append_canondplanetotriangle~~CalledByGraph proc~append_canondplanetotriangle append_CanoNDPlaneToTriangle proc~append_canondboxtotriangle append_CanoNDBoxToTriangle proc~append_canondboxtotriangle->proc~append_canondplanetotriangle proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_canonicalnd->proc~append_canondplanetotriangle proc~sdr_load_canonicalnd->proc~append_canondboxtotriangle proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/append_canondplanetotriangle.html"},{"title":"append_CanoNDBoxToSdrBox – Seeder","text":"public  subroutine append_CanoNDBoxToSdrBox(canobox, boxArray, spaObjArray, attr_pos) This routine convert plane to triangle and add triangle to \ngrowing array and add position of triangle into \nspatialObj%primitive_position Arguments Type Intent Optional Attributes Name type( tem_box_type ), intent(in) :: canobox canonical geometry object type type( grw_boxarray_type ), intent(inout) :: boxArray growing array of boxes type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type Calls proc~~append_canondboxtosdrbox~~CallsGraph proc~append_canondboxtosdrbox append_CanoNDBoxToSdrBox append append proc~append_canondboxtosdrbox->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~append_canondboxtosdrbox~~CalledByGraph proc~append_canondboxtosdrbox append_CanoNDBoxToSdrBox proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_canonicalnd->proc~append_canondboxtosdrbox proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/append_canondboxtosdrbox.html"},{"title":"sdr_load_config – Seeder","text":"public  subroutine sdr_load_config(me, geometry) Load the configuration from the Lua script provided on the command line\nor from seeder.lua by default, if no file name is given as program\nargument. The configuration needs to describe some general properties, like the\ndirectory where the resulting mesh is to be stored and the geometries,\nthat are to be used to define the mesh. Arguments Type Intent Optional Attributes Name type( sdr_confHead_type ), intent(inout) :: me contains basic information from config file type( sdr_geometry_type ), intent(out) :: geometry contains all geometry object defined in the config file Calls proc~~sdr_load_config~~CallsGraph proc~sdr_load_config sdr_load_config aot_get_val aot_get_val proc~sdr_load_config->aot_get_val close_config close_config proc~sdr_load_config->close_config open_config_file open_config_file proc~sdr_load_config->open_config_file proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_config->proc~sdr_load_geometry proc~sdr_load_inverted sdr_load_inverted proc~sdr_load_config->proc~sdr_load_inverted proc~sdr_subresolution_encolor sdr_subresolution_encolor proc~sdr_load_config->proc~sdr_subresolution_encolor proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_load_config->proc~sdr_subresolution_load tem_abort tem_abort proc~sdr_load_config->tem_abort tem_debug_load_main tem_debug_load_main proc~sdr_load_config->tem_debug_load_main tem_load_general tem_load_general proc~sdr_load_config->tem_load_general tem_logging_load_primary tem_logging_load_primary proc~sdr_load_config->tem_logging_load_primary tem_startTimer tem_startTimer proc~sdr_load_config->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_load_config->tem_stopTimer uni_name uni_name proc~sdr_load_config->uni_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_config~~CalledByGraph proc~sdr_load_config sdr_load_config program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_config.html"},{"title":"sdr_load_inverted – Seeder","text":"private  subroutine sdr_load_inverted(invlist, conf) Arguments Type Intent Optional Attributes Name type( dyn_labelarray_type ), intent(out) :: invlist List of labels for inverted colors. type( flu_State ) :: conf Lua script handle to read the inversion list from. Calls proc~~sdr_load_inverted~~CallsGraph proc~sdr_load_inverted sdr_load_inverted aot_get_val aot_get_val proc~sdr_load_inverted->aot_get_val aot_table_close aot_table_close proc~sdr_load_inverted->aot_table_close aot_table_length aot_table_length proc~sdr_load_inverted->aot_table_length aot_table_open aot_table_open proc~sdr_load_inverted->aot_table_open append append proc~sdr_load_inverted->append init init proc~sdr_load_inverted->init tem_abort tem_abort proc~sdr_load_inverted->tem_abort upper_to_lower upper_to_lower proc~sdr_load_inverted->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_inverted~~CalledByGraph proc~sdr_load_inverted sdr_load_inverted proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_load_inverted program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_inverted.html"},{"title":"needCalcQValByBCID – Seeder","text":"public  function needCalcQValByBCID(attribute, bcid) result(calc_qVal) This routine checks if a boundary need calc qVal for a given BCID\nIt is used in identify_boundary routine Arguments Type Intent Optional Attributes Name type(sdr_attrList_type), intent(in) :: attribute integer, intent(in) :: bcid Return Value logical Calls proc~~needcalcqvalbybcid~~CallsGraph proc~needcalcqvalbybcid needCalcQValByBCID kindpos kindpos proc~needcalcqvalbybcid->kindpos val val proc~needcalcqvalbybcid->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~needcalcqvalbybcid~~CalledByGraph proc~needcalcqvalbybcid needCalcQValByBCID proc~flood_periphery flood_periphery proc~flood_periphery->proc~needcalcqvalbybcid proc~getbcid_and_calcqval getBCID_and_calcQval proc~getbcid_and_calcqval->proc~needcalcqvalbybcid proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_find_periodic_neighbor->proc~needcalcqvalbybcid proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~needcalcqvalbybcid proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~create_target create_target proc~create_target->proc~sdr_find_periodic_neighbor proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~flood_periphery proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_flood_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/needcalcqvalbybcid.html"},{"title":"needFldDglByBCID – Seeder","text":"public  function needFldDglByBCID(attribute, bcid) result(flood_diagonal) This routine checks if a boundary need flood periphery for diagonal\ndirections for a given BCID.\nIt is used in identify_boundary routine Arguments Type Intent Optional Attributes Name type(sdr_attrList_type), intent(in) :: attribute integer, intent(in) :: bcid Return Value logical Calls proc~~needflddglbybcid~~CallsGraph proc~needflddglbybcid needFldDglByBCID kindpos kindpos proc~needflddglbybcid->kindpos val val proc~needflddglbybcid->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~needflddglbybcid~~CalledByGraph proc~needflddglbybcid needFldDglByBCID proc~flood_periphery flood_periphery proc~flood_periphery->proc~needflddglbybcid proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~flood_periphery program~seeder seeder program~seeder->proc~sdr_flood_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/needflddglbybcid.html"},{"title":"getTreeIDPosOfCoord – Seeder","text":"private  function getTreeIDPosOfCoord(coordReal, mesh, minLevel, maxLevel, leafLevel, leafTreeID, proto) result(pos) This function returns the position of treeID of given coordReal in the\nthe given mesh\nStart from minLevel which is the level of neighbor and find the treeID\nwhich is a leaf in protoTree Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: coordReal (3) type( treelmesh_type ), intent(in) :: mesh Mesh contain geometry universe (bounding cube) info integer, intent(in) :: minLevel minlevel integer, intent(in) :: maxLevel maxlevel integer, intent(out) :: leafLevel level in which leaf node is found integer(kind=long_k), intent(inout) :: leafTreeID type( sdr_protoTree_type ), intent(in) :: proto preliminary tree Return Value integer position of treeID in proto tree Calls proc~~gettreeidposofcoord~~CallsGraph proc~gettreeidposofcoord getTreeIDPosOfCoord positionofval positionofval proc~gettreeidposofcoord->positionofval sdr_nodeprop_btest sdr_nodeprop_btest proc~gettreeidposofcoord->sdr_nodeprop_btest tem_CoordOfReal tem_CoordOfReal proc~gettreeidposofcoord->tem_CoordOfReal tem_IdOfCoord tem_IdOfCoord proc~gettreeidposofcoord->tem_IdOfCoord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~gettreeidposofcoord~~CalledByGraph proc~gettreeidposofcoord getTreeIDPosOfCoord proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~sdr_find_periodic_neighbor->proc~gettreeidposofcoord proc~create_target create_target proc~create_target->proc~sdr_find_periodic_neighbor proc~getbcid_and_calcqval getBCID_and_calcQval proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~traverse_tree proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/gettreeidposofcoord.html"},{"title":"projectVecOnPlane – Seeder","text":"private  function projectVecOnPlane(vecU, plane) result(res) This function project given vector on an given plane Example: projection of vector a onto a vector u is given as\n \\f$ proj_u a = \\frac{a \\cdot u}{|u|&#94;2} \\cdot u \\f$ Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vecU (3) vector to project type( tem_plane_type ), intent(in) :: plane plane on which vecU will be projected Return Value real(kind=rk), (3) output projected value Called by proc~~projectveconplane~~CalledByGraph proc~projectveconplane projectVecOnPlane proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~sdr_find_periodic_neighbor->proc~projectveconplane proc~create_target create_target proc~create_target->proc~sdr_find_periodic_neighbor proc~getbcid_and_calcqval getBCID_and_calcQval proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~traverse_tree proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/projectveconplane.html"},{"title":"getNormal – Seeder","text":"private  function getNormal(geometry, elemBary, node, node_pos, bcid) result(normal) Obtain the surface normal of the chosen boundary if the boundary has store_normal set. Otherwise a null vector is returned. Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(in) :: geometry real(kind=rk), intent(in) :: elemBary (3) type(sdr_node_type), intent(in) :: node integer, intent(in) :: node_pos integer, intent(in) :: bcid Return Value real(kind=rk), (3) Calls proc~~getnormal~~CallsGraph proc~getnormal getNormal append append proc~getnormal->append destroy destroy proc~getnormal->destroy init init proc~getnormal->init kindpos kindpos proc~getnormal->kindpos mrgrnk mrgrnk proc~getnormal->mrgrnk tem_triangle_normal_proximity tem_triangle_normal_proximity proc~getnormal->tem_triangle_normal_proximity val val proc~getnormal->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~getnormal~~CalledByGraph proc~getnormal getNormal proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~getnormal proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~traverse_tree traverse_tree proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/getnormal.html"},{"title":"sdr_identify_boundary – Seeder","text":"public  subroutine sdr_identify_boundary(node_pos, treeID, coord, leVal, proto, geometry, BC_ID, qVal, bc_normal, meshUniverse) This routine checks for boundary neighbors and level of the boundary\nnode Note, this can not easily be used for target nodes with subelement\nresolution, as it assumes q-Values if the node is intersected by a\nboundary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree integer(kind=long_k), intent(in) :: treeID treeID of parent node integer, intent(in) :: coord (4) Coordinate of treeID type( levelValues_type ), intent(in) :: leVal level value of parent node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects integer(kind=long_k), intent(out) :: BC_ID (qQQQ) Boundary ID for all 26 neighbor directions real(kind=rk), intent(out) :: qVal (qQQQ) distance from boundary for all 26 neighbor directions real(kind=rk), intent(out) :: bc_normal (3) Wall normal pointing from the surface to the barycenter of the\nboundary element type( treelmesh_type ), intent(in) :: meshUniverse contains bounding cube information Calls proc~~sdr_identify_boundary~~CallsGraph proc~sdr_identify_boundary sdr_identify_boundary kindpos kindpos proc~sdr_identify_boundary->kindpos proc~getbcid_and_calcqval getBCID_and_calcQval proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~getnormal getNormal proc~sdr_identify_boundary->proc~getnormal proc~needcalcqvalbybcid needCalcQValByBCID proc~sdr_identify_boundary->proc~needcalcqvalbybcid proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~sdr_identify_boundary->proc~sdr_neighbor_in_proto sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_identify_boundary->sdr_nodeprop_btest tem_BaryOfId tem_BaryOfId proc~sdr_identify_boundary->tem_BaryOfId tem_abort tem_abort proc~sdr_identify_boundary->tem_abort tem_convertTreeIDtoCube tem_convertTreeIDtoCube proc~sdr_identify_boundary->tem_convertTreeIDtoCube tem_pointCubeOverlap tem_pointCubeOverlap proc~sdr_identify_boundary->tem_pointCubeOverlap val val proc~sdr_identify_boundary->val proc~getbcid_and_calcqval->proc~needcalcqvalbybcid proc~getbcid_and_calcqval->val proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_qvalbynode sdr_qValByNode proc~getbcid_and_calcqval->proc~sdr_qvalbynode proc~sdr_truncate_qval sdr_truncate_qVal proc~getbcid_and_calcqval->proc~sdr_truncate_qval proc~getnormal->kindpos proc~getnormal->val append append proc~getnormal->append destroy destroy proc~getnormal->destroy init init proc~getnormal->init mrgrnk mrgrnk proc~getnormal->mrgrnk tem_triangle_normal_proximity tem_triangle_normal_proximity proc~getnormal->tem_triangle_normal_proximity proc~needcalcqvalbybcid->kindpos proc~needcalcqvalbybcid->val positionofval positionofval proc~sdr_neighbor_in_proto->positionofval tem_IdOfCoord tem_IdOfCoord proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf proc~sdr_find_periodic_neighbor->kindpos proc~sdr_find_periodic_neighbor->proc~needcalcqvalbybcid proc~sdr_find_periodic_neighbor->sdr_nodeprop_btest proc~sdr_find_periodic_neighbor->tem_BaryOfId proc~sdr_find_periodic_neighbor->tem_abort proc~sdr_find_periodic_neighbor->val proc~sdr_find_periodic_neighbor->proc~sdr_qvalbynode proc~sdr_find_periodic_neighbor->proc~sdr_truncate_qval proc~sdr_find_periodic_neighbor->tem_IdOfCoord proc~gettreeidposofcoord getTreeIDPosOfCoord proc~sdr_find_periodic_neighbor->proc~gettreeidposofcoord proc~projectveconplane projectVecOnPlane proc~sdr_find_periodic_neighbor->proc~projectveconplane tem_CoordOfId tem_CoordOfId proc~sdr_find_periodic_neighbor->tem_CoordOfId tem_CoordOfReal tem_CoordOfReal proc~sdr_find_periodic_neighbor->tem_CoordOfReal proc~sdr_qvalbynode->val fraction_PointLine fraction_PointLine proc~sdr_qvalbynode->fraction_PointLine intersect_RayTriangle intersect_RayTriangle proc~sdr_qvalbynode->intersect_RayTriangle proc~sdr_truncate_qval->sdr_nodeprop_btest proc~gettreeidposofcoord->sdr_nodeprop_btest proc~gettreeidposofcoord->positionofval proc~gettreeidposofcoord->tem_IdOfCoord proc~gettreeidposofcoord->tem_CoordOfReal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_identify_boundary~~CalledByGraph proc~sdr_identify_boundary sdr_identify_boundary proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~traverse_tree traverse_tree proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_identify_boundary.html"},{"title":"sdr_find_periodic_neighbor – Seeder","text":"public  subroutine sdr_find_periodic_neighbor(elemBary, iDir, bc_ID, qVal, unKnownBnd, neighbor_pos, neighbor_level, leVal, proto, geometry, meshUniverse) This routine find the treeID on the opposite side neighbor of the\n periodic plane for current leaf node write(dbgUnit(5),*) '1.1 qVal ', qVal Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: elemBary (3) current element barycenter integer, intent(in) :: iDir Current boundary neighbor direction integer(kind=long_k), intent(inout) :: bc_ID treeiD of opposite neighbor with periodic plane real(kind=rk), intent(out) :: qVal distance from boundary for direction iDir Todo HK: maybe turn this optional, why is it relevant for periodic? logical, intent(inout) :: unKnownBnd Set to true if a neighbor with no property is encountered integer, intent(in) :: neighbor_pos position of neighbor treeID in the proto%node list integer, intent(in) :: neighbor_level level of the periodic boundary neighbor node type( levelValues_type ), intent(in) :: leVal level value of parent node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( treelmesh_type ), intent(in) :: meshUniverse contains bounding cube information Calls proc~~sdr_find_periodic_neighbor~~CallsGraph proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor kindpos kindpos proc~sdr_find_periodic_neighbor->kindpos proc~gettreeidposofcoord getTreeIDPosOfCoord proc~sdr_find_periodic_neighbor->proc~gettreeidposofcoord proc~needcalcqvalbybcid needCalcQValByBCID proc~sdr_find_periodic_neighbor->proc~needcalcqvalbybcid proc~projectveconplane projectVecOnPlane proc~sdr_find_periodic_neighbor->proc~projectveconplane proc~sdr_qvalbynode sdr_qValByNode proc~sdr_find_periodic_neighbor->proc~sdr_qvalbynode proc~sdr_truncate_qval sdr_truncate_qVal proc~sdr_find_periodic_neighbor->proc~sdr_truncate_qval sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_find_periodic_neighbor->sdr_nodeprop_btest tem_BaryOfId tem_BaryOfId proc~sdr_find_periodic_neighbor->tem_BaryOfId tem_CoordOfId tem_CoordOfId proc~sdr_find_periodic_neighbor->tem_CoordOfId tem_CoordOfReal tem_CoordOfReal proc~sdr_find_periodic_neighbor->tem_CoordOfReal tem_IdOfCoord tem_IdOfCoord proc~sdr_find_periodic_neighbor->tem_IdOfCoord tem_abort tem_abort proc~sdr_find_periodic_neighbor->tem_abort val val proc~sdr_find_periodic_neighbor->val proc~gettreeidposofcoord->sdr_nodeprop_btest proc~gettreeidposofcoord->tem_CoordOfReal proc~gettreeidposofcoord->tem_IdOfCoord positionofval positionofval proc~gettreeidposofcoord->positionofval proc~needcalcqvalbybcid->kindpos proc~needcalcqvalbybcid->val proc~sdr_qvalbynode->val fraction_PointLine fraction_PointLine proc~sdr_qvalbynode->fraction_PointLine intersect_RayTriangle intersect_RayTriangle proc~sdr_qvalbynode->intersect_RayTriangle proc~sdr_truncate_qval->sdr_nodeprop_btest Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_find_periodic_neighbor~~CalledByGraph proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~create_target create_target proc~create_target->proc~sdr_find_periodic_neighbor proc~getbcid_and_calcqval getBCID_and_calcQval proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~traverse_tree proc~proto2treelm proto2Treelm proc~traverse_tree->proc~proto2treelm proc~proto2treelm->proc~sdr_identify_boundary proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_find_periodic_neighbor.html"},{"title":"sdr_qValByNode – Seeder","text":"public  subroutine sdr_qValByNode(proto, geometry, dx, iDir, origin, node_pos, qVal) This routine computes the minimum distance of a given link and all the\ngeometries in a given node:\\n\nthe link is given by a vector and a origin point.\\n\nthe node is given by the node position in the protoTree.\\n\nIf there is no intersection, qVal returns -1.0 Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects real(kind=rk), intent(in) :: dx dx of current level integer, intent(in) :: iDir Direction real(kind=rk), intent(in) :: origin (3) current element barycenter integer :: node_pos position of node to find the geometries real(kind=rk), intent(out) :: qVal distance from boundary for all 26 neighbor directions Calls proc~~sdr_qvalbynode~~CallsGraph proc~sdr_qvalbynode sdr_qValByNode fraction_PointLine fraction_PointLine proc~sdr_qvalbynode->fraction_PointLine intersect_RayTriangle intersect_RayTriangle proc~sdr_qvalbynode->intersect_RayTriangle val val proc~sdr_qvalbynode->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_qvalbynode~~CalledByGraph proc~sdr_qvalbynode sdr_qValByNode proc~flood_periphery flood_periphery proc~flood_periphery->proc~sdr_qvalbynode proc~getbcid_and_calcqval getBCID_and_calcQval proc~getbcid_and_calcqval->proc~sdr_qvalbynode proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_find_periodic_neighbor->proc~sdr_qvalbynode proc~create_target create_target proc~create_target->proc~sdr_find_periodic_neighbor proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~flood_periphery proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_flood_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_qvalbynode.html"},{"title":"getBCID_and_calcQval – Seeder","text":"private  subroutine getBCID_and_calcQval(proto, geometry, elemBary, iDir, bndnode_pos, level, leVal, meshUniverse, BC_ID, minBCID, qVal, unKnownBnd) This routine gets minBCID of the given node position in the protoTree.\n If the minBcid is periodic then it bcID is set to treeID of fluid node\n on the opposite side of periodic plane.\n It also computes the qVal if calc_dist = true. If qVal = -1 then\n there is no intersection and if qVal > 1 then the geometry is intersected\n after the link distance. write(dbgUnit(5),*) 'min bc_id ', bc_id Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects real(kind=rk), intent(in) :: elemBary (3) current element barycenter integer, intent(in) :: iDir Current boundary neighbor direction integer, intent(in) :: bndnode_pos position of node treeID in the proto%node list integer, intent(in) :: level level of the node type( levelValues_type ), intent(in) :: leVal level value of parent node type( treelmesh_type ), intent(in) :: meshUniverse contains bounding cube information integer(kind=long_k), intent(out) :: BC_ID Boundary ID for direction iDir integer(kind=long_k), intent(inout) :: minBCID minimum boundary id of current node before truncation real(kind=rk), intent(out) :: qVal distance from boundary for direction iDir logical, intent(inout) :: unKnownBnd Is true if a neighbor with no property is encountered Calls proc~~getbcid_and_calcqval~~CallsGraph proc~getbcid_and_calcqval getBCID_and_calcQval proc~needcalcqvalbybcid needCalcQValByBCID proc~getbcid_and_calcqval->proc~needcalcqvalbybcid proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_qvalbynode sdr_qValByNode proc~getbcid_and_calcqval->proc~sdr_qvalbynode proc~sdr_truncate_qval sdr_truncate_qVal proc~getbcid_and_calcqval->proc~sdr_truncate_qval val val proc~getbcid_and_calcqval->val proc~needcalcqvalbybcid->val kindpos kindpos proc~needcalcqvalbybcid->kindpos proc~sdr_find_periodic_neighbor->proc~needcalcqvalbybcid proc~sdr_find_periodic_neighbor->proc~sdr_qvalbynode proc~sdr_find_periodic_neighbor->proc~sdr_truncate_qval proc~sdr_find_periodic_neighbor->val proc~sdr_find_periodic_neighbor->kindpos proc~gettreeidposofcoord getTreeIDPosOfCoord proc~sdr_find_periodic_neighbor->proc~gettreeidposofcoord proc~projectveconplane projectVecOnPlane proc~sdr_find_periodic_neighbor->proc~projectveconplane sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_find_periodic_neighbor->sdr_nodeprop_btest tem_BaryOfId tem_BaryOfId proc~sdr_find_periodic_neighbor->tem_BaryOfId tem_CoordOfId tem_CoordOfId proc~sdr_find_periodic_neighbor->tem_CoordOfId tem_CoordOfReal tem_CoordOfReal proc~sdr_find_periodic_neighbor->tem_CoordOfReal tem_IdOfCoord tem_IdOfCoord proc~sdr_find_periodic_neighbor->tem_IdOfCoord tem_abort tem_abort proc~sdr_find_periodic_neighbor->tem_abort proc~sdr_qvalbynode->val fraction_PointLine fraction_PointLine proc~sdr_qvalbynode->fraction_PointLine intersect_RayTriangle intersect_RayTriangle proc~sdr_qvalbynode->intersect_RayTriangle proc~sdr_truncate_qval->sdr_nodeprop_btest proc~gettreeidposofcoord->sdr_nodeprop_btest proc~gettreeidposofcoord->tem_CoordOfReal proc~gettreeidposofcoord->tem_IdOfCoord positionofval positionofval proc~gettreeidposofcoord->positionofval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~getbcid_and_calcqval~~CalledByGraph proc~getbcid_and_calcqval getBCID_and_calcQval proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~traverse_tree traverse_tree proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/getbcid_and_calcqval.html"},{"title":"sdr_truncate_qVal – Seeder","text":"private  subroutine sdr_truncate_qVal(proto, qVal, BCID, neighPos, treeID_periodic) This routine gives special treatment when qVal > 1.0 or qVal == -1.0\nfor flooded neighbor, treat it as normal fluid: clean BCID,\nset qVal to -1 (no itersection).\nfor non-flooded neighbor, treat it as high order wall: set qVal to 1 Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree real(kind=rk), intent(inout) :: qVal qValue integer(kind=long_k), intent(inout) :: BCID boundary id integer, intent(in) :: neighPos neighbor position in proto tree integer(kind=long_k), intent(in), optional :: treeID_periodic negative treeID of periodic domain Calls proc~~sdr_truncate_qval~~CallsGraph proc~sdr_truncate_qval sdr_truncate_qVal sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_truncate_qval->sdr_nodeprop_btest Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_truncate_qval~~CalledByGraph proc~sdr_truncate_qval sdr_truncate_qVal proc~getbcid_and_calcqval getBCID_and_calcQval proc~getbcid_and_calcqval->proc~sdr_truncate_qval proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_find_periodic_neighbor->proc~sdr_truncate_qval proc~create_target create_target proc~create_target->proc~sdr_find_periodic_neighbor proc~sdr_identify_boundary sdr_identify_boundary proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~proto2treelm proto2Treelm proc~proto2treelm->proc~sdr_identify_boundary proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_truncate_qval.html"},{"title":"sdr_hvs_config_load – Seeder","text":"public  subroutine sdr_hvs_config_load(me, mesh, property, varsys, general, restart, time) Read the configuration for the Seeder harvesting from a Lua script. Arguments Type Intent Optional Attributes Name type( sdr_hvs_config_type ), intent(out) :: me Seeder harvesting configuration to load type( treelmesh_type ), intent(out) :: mesh Treelm mesh description as obtained from the user configuration. type( sdr_hvs_props_type ), intent(out) :: property Properties associated with the mesh. type( tem_varSys_type ), intent(inout) :: varsys A variable system, to which the further variables should be appended. type( tem_general_type ), intent(inout) :: general General treelm data to load type( tem_restart_type ), intent(inout) :: restart type( tem_time_type ), intent(out) :: time Calls proc~~sdr_hvs_config_load~~CallsGraph proc~sdr_hvs_config_load sdr_hvs_config_load aot_get_val aot_get_val proc~sdr_hvs_config_load->aot_get_val close_config close_config proc~sdr_hvs_config_load->close_config hvs_output_load hvs_output_load proc~sdr_hvs_config_load->hvs_output_load load_tem load_tem proc~sdr_hvs_config_load->load_tem open_config_file open_config_file proc~sdr_hvs_config_load->open_config_file proc~ply_sampled_tracking_load ply_sampled_tracking_load proc~sdr_hvs_config_load->proc~ply_sampled_tracking_load proc~sdr_hvs_props_load sdr_hvs_props_load proc~sdr_hvs_config_load->proc~sdr_hvs_props_load tem_debug_load_main tem_debug_load_main proc~sdr_hvs_config_load->tem_debug_load_main tem_load_general tem_load_general proc~sdr_hvs_config_load->tem_load_general tem_load_restart tem_load_restart proc~sdr_hvs_config_load->tem_load_restart tem_logging_load_primary tem_logging_load_primary proc~sdr_hvs_config_load->tem_logging_load_primary ply_sampling_load ply_sampling_load proc~ply_sampled_tracking_load->ply_sampling_load tem_load_tracking tem_load_tracking proc~ply_sampled_tracking_load->tem_load_tracking color_label color_label proc~sdr_hvs_props_load->color_label init_tem_bc_prop init_tem_bc_prop proc~sdr_hvs_props_load->init_tem_bc_prop proc~ply_subresolution_load ply_subresolution_load proc~sdr_hvs_props_load->proc~ply_subresolution_load proc~sdr_hvs_props_clean sdr_hvs_props_clean proc~sdr_hvs_props_load->proc~sdr_hvs_props_clean tem_color_prop_load tem_color_prop_load proc~sdr_hvs_props_load->tem_color_prop_load tem_varSys_append_derVar tem_varSys_append_derVar proc~sdr_hvs_props_load->tem_varSys_append_derVar proc~ply_subresolution_load->aot_get_val proc~ply_subresolution_load->close_config tem_abort tem_abort proc~ply_subresolution_load->tem_abort tem_open_distconf tem_open_distconf proc~ply_subresolution_load->tem_open_distconf tem_subres_prop_load tem_subres_prop_load proc~ply_subresolution_load->tem_subres_prop_load upper_to_lower upper_to_lower proc~ply_subresolution_load->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_hvs_config_load~~CalledByGraph proc~sdr_hvs_config_load sdr_hvs_config_load program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~sdr_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_hvs_config_load.html"},{"title":"sdr_load_cube – Seeder","text":"public  subroutine sdr_load_cube(me, conf, key, pos, parent) This routine loads the boundCube table from config file Arguments Type Intent Optional Attributes Name type( sdr_cube_type ), intent(out) :: me type( flu_State ) :: conf character(len=*), intent(in), optional :: key open cube table by given key integer, intent(in), optional :: pos open cube table by position integer, intent(in), optional :: parent if cube is to be load from pos, parent handle is required Calls proc~~sdr_load_cube~~CallsGraph proc~sdr_load_cube sdr_load_cube aot_get_val aot_get_val proc~sdr_load_cube->aot_get_val aot_table_close aot_table_close proc~sdr_load_cube->aot_table_close aot_table_open aot_table_open proc~sdr_load_cube->aot_table_open tem_abort tem_abort proc~sdr_load_cube->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_cube.html"},{"title":"sdr_proto2treelm – Seeder","text":"public  subroutine sdr_proto2treelm(proto, geometry, temData, header) This subroutine creates the treelmesh from the flooded prototree. It will create the treelmesh out of all flooded elements and refine those\nleaves intersected by a refinement object.\nThis routine will also identify the elements with boundary conditions\nand store the boundary information accordingly.\nPlease keep in mind, that the flooding only considered the 6 face\nneighbors, while we create boundary informations for all 26 neighbors. Todo Neighbors that do not intersect boundary objects.\nThis means, that it might happen, that any of the 20 further neighbors\ndoes not actually intersect a boundary object. We need to deal with\nthis case properly.\nFor example, a boundary condition might be selected based on the\nadjacent face neighbors for the direction in question. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( sdr_temData_type ), intent(inout) :: temData temData contains final mesh created by this routine type( sdr_confHead_type ), intent(inout) :: header Header data. Calls proc~~sdr_proto2treelm~~CallsGraph proc~sdr_proto2treelm sdr_proto2treelm init init proc~sdr_proto2treelm->init ply_poly_project_fillbody ply_poly_project_fillbody proc~sdr_proto2treelm->ply_poly_project_fillbody proc~traverse_tree traverse_tree proc~sdr_proto2treelm->proc~traverse_tree tem_FirstIdAtLevel tem_FirstIdAtLevel proc~sdr_proto2treelm->tem_FirstIdAtLevel tem_startTimer tem_startTimer proc~sdr_proto2treelm->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_proto2treelm->tem_stopTimer proc~traverse_tree->proc~traverse_tree proc~traverse_tree->tem_FirstIdAtLevel proc~create_target create_target proc~traverse_tree->proc~create_target proc~proto2treelm proto2Treelm proc~traverse_tree->proc~proto2treelm sdr_nodecolors sdr_nodecolors proc~traverse_tree->sdr_nodecolors val val proc~traverse_tree->val proc~create_target->val append append proc~create_target->append bc_color_id bc_color_id proc~create_target->bc_color_id newunit newunit proc~create_target->newunit ply_convertfromoversample ply_convertfromoversample proc~create_target->ply_convertfromoversample ply_poly_project_n2m ply_poly_project_n2m proc~create_target->ply_poly_project_n2m positionofval positionofval proc~create_target->positionofval proc~sdr_color_points sdr_color_points proc~create_target->proc~sdr_color_points proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~create_target->proc~sdr_find_periodic_neighbor proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~create_target->proc~sdr_neighbor_in_proto sdr_bitfieldcolors sdr_bitfieldcolors proc~create_target->sdr_bitfieldcolors sdr_color_log2char sdr_color_log2char proc~create_target->sdr_color_log2char sdr_nodeprop_btest sdr_nodeprop_btest proc~create_target->sdr_nodeprop_btest tem_CoordOfId tem_CoordOfId proc~create_target->tem_CoordOfId tem_abort tem_abort proc~create_target->tem_abort proc~proto2treelm->val proc~proto2treelm->append proc~sdr_identify_boundary sdr_identify_boundary proc~proto2treelm->proc~sdr_identify_boundary proc~proto2treelm->tem_CoordOfId Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_proto2treelm~~CalledByGraph proc~sdr_proto2treelm sdr_proto2treelm program~seeder seeder program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_proto2treelm.html"},{"title":"traverse_tree – Seeder","text":"public recursive subroutine traverse_tree(node_pos, leVal, proto, geometry, temData, header, meshUniverse) Recursively traverse the tree in a depth first manner to obtain the\nthe ordering required by treelm. Only consider flooded nodes here, no need to traverse further down any\nnon-flooded node, as it does not belong to the computational domain.\nAll virtual nodes containing at least one flooded leaf node has already\nbeen determined and set after flooding in sdr_flood_module::sdr_flood_tree.\nIf the leaf node is reached, hand over to the ::refine_leaf routine, to\nfind all elements, that actually should be created in the computational\ndomain. Todo KM: Store has_boundary information for every leaf node in\nsdr_refine_leaf routine to avoid excessive boundary checking far\naway from the boundaries. If this node is flooded or fluidifyable it needs to be included in the\nfinal mesh. Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree type( levelValues_type ), intent(in) :: leVal level value of current node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( sdr_temData_type ), intent(inout) :: temData temData contains final treelmesh type( sdr_confHead_type ), intent(in) :: header Header information type( treelmesh_type ), intent(inout) :: meshUniverse contains bounding cube information Calls proc~~traverse_tree~~CallsGraph proc~traverse_tree traverse_tree proc~traverse_tree->proc~traverse_tree proc~create_target create_target proc~traverse_tree->proc~create_target proc~proto2treelm proto2Treelm proc~traverse_tree->proc~proto2treelm sdr_nodecolors sdr_nodecolors proc~traverse_tree->sdr_nodecolors tem_FirstIdAtLevel tem_FirstIdAtLevel proc~traverse_tree->tem_FirstIdAtLevel val val proc~traverse_tree->val proc~create_target->val append append proc~create_target->append bc_color_id bc_color_id proc~create_target->bc_color_id newunit newunit proc~create_target->newunit ply_convertfromoversample ply_convertfromoversample proc~create_target->ply_convertfromoversample ply_poly_project_n2m ply_poly_project_n2m proc~create_target->ply_poly_project_n2m positionofval positionofval proc~create_target->positionofval proc~sdr_color_points sdr_color_points proc~create_target->proc~sdr_color_points proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~create_target->proc~sdr_find_periodic_neighbor proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~create_target->proc~sdr_neighbor_in_proto sdr_bitfieldcolors sdr_bitfieldcolors proc~create_target->sdr_bitfieldcolors sdr_color_log2char sdr_color_log2char proc~create_target->sdr_color_log2char sdr_nodeprop_btest sdr_nodeprop_btest proc~create_target->sdr_nodeprop_btest tem_CoordOfId tem_CoordOfId proc~create_target->tem_CoordOfId tem_abort tem_abort proc~create_target->tem_abort proc~proto2treelm->val proc~proto2treelm->append proc~sdr_identify_boundary sdr_identify_boundary proc~proto2treelm->proc~sdr_identify_boundary proc~proto2treelm->tem_CoordOfId Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~traverse_tree~~CalledByGraph proc~traverse_tree traverse_tree proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/traverse_tree.html"},{"title":"proto2Treelm – Seeder","text":"public  subroutine proto2Treelm(node_pos, treeID, leVal, proto, geometry, check_bnd, temData, nodeprops, nodecolors, meshUniverse) Routine to convert protoTree to Treelm data format.\nappend all leaves to the temData%treeID Add this element to the list of elements in the final tree, by adding:\n      * treeID\n      * propertyBits\nIf there is a boundary, also add the correct boundary data into the\n26 direct neighbors (bc_ID), append to all 26 even if there is no\nboundary condition in the given direction, no boundaries are indicated\nby 0, boundary conditions are decided based on the trumping rule, that\nis the minimal bc_ID of all boundary objects in the corresponding\nneighbor are chosen.\nTreat periodic boundaries here if possible by putting the opposite\ntreeID into the bc_ID. Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree integer(kind=long_k), intent(in) :: treeID treeID of current node type( levelValues_type ), intent(in) :: leVal level value of current node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects logical, intent(in) :: check_bnd does this node has boundary neighbor type( sdr_temData_type ), intent(inout) :: temData integer, intent(in) :: nodeprops propertyBits of current node character(len=1), intent(in) :: nodecolors (:) Color information of the cuurent node type( treelmesh_type ), intent(inout) :: meshUniverse contains bounding cube information Calls proc~~proto2treelm~~CallsGraph proc~proto2treelm proto2Treelm append append proc~proto2treelm->append proc~sdr_identify_boundary sdr_identify_boundary proc~proto2treelm->proc~sdr_identify_boundary tem_CoordOfId tem_CoordOfId proc~proto2treelm->tem_CoordOfId val val proc~proto2treelm->val proc~sdr_identify_boundary->val kindpos kindpos proc~sdr_identify_boundary->kindpos proc~getbcid_and_calcqval getBCID_and_calcQval proc~sdr_identify_boundary->proc~getbcid_and_calcqval proc~getnormal getNormal proc~sdr_identify_boundary->proc~getnormal proc~needcalcqvalbybcid needCalcQValByBCID proc~sdr_identify_boundary->proc~needcalcqvalbybcid proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~sdr_identify_boundary->proc~sdr_neighbor_in_proto sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_identify_boundary->sdr_nodeprop_btest tem_BaryOfId tem_BaryOfId proc~sdr_identify_boundary->tem_BaryOfId tem_abort tem_abort proc~sdr_identify_boundary->tem_abort tem_convertTreeIDtoCube tem_convertTreeIDtoCube proc~sdr_identify_boundary->tem_convertTreeIDtoCube tem_pointCubeOverlap tem_pointCubeOverlap proc~sdr_identify_boundary->tem_pointCubeOverlap proc~getbcid_and_calcqval->val proc~getbcid_and_calcqval->proc~needcalcqvalbybcid proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~getbcid_and_calcqval->proc~sdr_find_periodic_neighbor proc~sdr_qvalbynode sdr_qValByNode proc~getbcid_and_calcqval->proc~sdr_qvalbynode proc~sdr_truncate_qval sdr_truncate_qVal proc~getbcid_and_calcqval->proc~sdr_truncate_qval proc~getnormal->append proc~getnormal->val proc~getnormal->kindpos destroy destroy proc~getnormal->destroy init init proc~getnormal->init mrgrnk mrgrnk proc~getnormal->mrgrnk tem_triangle_normal_proximity tem_triangle_normal_proximity proc~getnormal->tem_triangle_normal_proximity proc~needcalcqvalbybcid->val proc~needcalcqvalbybcid->kindpos positionofval positionofval proc~sdr_neighbor_in_proto->positionofval tem_IdOfCoord tem_IdOfCoord proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf proc~sdr_find_periodic_neighbor->tem_CoordOfId proc~sdr_find_periodic_neighbor->val proc~sdr_find_periodic_neighbor->kindpos proc~sdr_find_periodic_neighbor->proc~needcalcqvalbybcid proc~sdr_find_periodic_neighbor->sdr_nodeprop_btest proc~sdr_find_periodic_neighbor->tem_BaryOfId proc~sdr_find_periodic_neighbor->tem_abort proc~sdr_find_periodic_neighbor->proc~sdr_qvalbynode proc~sdr_find_periodic_neighbor->proc~sdr_truncate_qval proc~sdr_find_periodic_neighbor->tem_IdOfCoord proc~gettreeidposofcoord getTreeIDPosOfCoord proc~sdr_find_periodic_neighbor->proc~gettreeidposofcoord proc~projectveconplane projectVecOnPlane proc~sdr_find_periodic_neighbor->proc~projectveconplane tem_CoordOfReal tem_CoordOfReal proc~sdr_find_periodic_neighbor->tem_CoordOfReal proc~sdr_qvalbynode->val fraction_PointLine fraction_PointLine proc~sdr_qvalbynode->fraction_PointLine intersect_RayTriangle intersect_RayTriangle proc~sdr_qvalbynode->intersect_RayTriangle proc~sdr_truncate_qval->sdr_nodeprop_btest Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~proto2treelm~~CalledByGraph proc~proto2treelm proto2Treelm proc~traverse_tree traverse_tree proc~traverse_tree->proc~proto2treelm proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/proto2treelm.html"},{"title":"create_target – Seeder","text":"public  subroutine create_target(node_pos, proto, geometry, leVal, meshUniverse, header, temData) Routine to create an element with subelement resolution. This routine is used to define a target element, that is a node, that\nreached its final level, but contains boundaries, that are to be resolved\non a subelement basis. For the treelmesh, this is just a normal element\nwith additional information attached to it. That additional information\nis covered by a property.\nFor the actual information in the subelement resolution, the children of\nthe target node need to be considered.\nWe use a separate routine for this case, as it is ensured, that this\nelement never will be refined, due to adjacent boundaries. (Any such\nrefinement was already done during the building of the protoTree).\nAlso we will ignore Q-Value complications here for the identification of\nboundaries. If subelement resolution is active, no Q-Values might be used\nand the other way around. Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( levelValues_type ), intent(in) :: leVal level value of parent node type( treelmesh_type ), intent(inout) :: meshUniverse contains bounding cube information type( sdr_confHead_type ), intent(in) :: header Configuration header. type( sdr_temData_type ), intent(inout) :: temData Data for the final mesh. Calls proc~~create_target~~CallsGraph proc~create_target create_target append append proc~create_target->append bc_color_id bc_color_id proc~create_target->bc_color_id newunit newunit proc~create_target->newunit ply_convertfromoversample ply_convertfromoversample proc~create_target->ply_convertfromoversample ply_poly_project_n2m ply_poly_project_n2m proc~create_target->ply_poly_project_n2m positionofval positionofval proc~create_target->positionofval proc~sdr_color_points sdr_color_points proc~create_target->proc~sdr_color_points proc~sdr_find_periodic_neighbor sdr_find_periodic_neighbor proc~create_target->proc~sdr_find_periodic_neighbor proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~create_target->proc~sdr_neighbor_in_proto sdr_bitfieldcolors sdr_bitfieldcolors proc~create_target->sdr_bitfieldcolors sdr_color_log2char sdr_color_log2char proc~create_target->sdr_color_log2char sdr_nodeprop_btest sdr_nodeprop_btest proc~create_target->sdr_nodeprop_btest tem_CoordOfId tem_CoordOfId proc~create_target->tem_CoordOfId tem_abort tem_abort proc~create_target->tem_abort val val proc~create_target->val proc~sdr_color_points->sdr_nodeprop_btest proc~sdr_color_points->val proc~sdr_find_periodic_neighbor->sdr_nodeprop_btest proc~sdr_find_periodic_neighbor->tem_CoordOfId proc~sdr_find_periodic_neighbor->tem_abort proc~sdr_find_periodic_neighbor->val kindpos kindpos proc~sdr_find_periodic_neighbor->kindpos proc~gettreeidposofcoord getTreeIDPosOfCoord proc~sdr_find_periodic_neighbor->proc~gettreeidposofcoord proc~needcalcqvalbybcid needCalcQValByBCID proc~sdr_find_periodic_neighbor->proc~needcalcqvalbybcid proc~projectveconplane projectVecOnPlane proc~sdr_find_periodic_neighbor->proc~projectveconplane proc~sdr_qvalbynode sdr_qValByNode proc~sdr_find_periodic_neighbor->proc~sdr_qvalbynode proc~sdr_truncate_qval sdr_truncate_qVal proc~sdr_find_periodic_neighbor->proc~sdr_truncate_qval tem_BaryOfId tem_BaryOfId proc~sdr_find_periodic_neighbor->tem_BaryOfId tem_CoordOfReal tem_CoordOfReal proc~sdr_find_periodic_neighbor->tem_CoordOfReal tem_IdOfCoord tem_IdOfCoord proc~sdr_find_periodic_neighbor->tem_IdOfCoord proc~sdr_neighbor_in_proto->positionofval proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf proc~gettreeidposofcoord->positionofval proc~gettreeidposofcoord->sdr_nodeprop_btest proc~gettreeidposofcoord->tem_CoordOfReal proc~gettreeidposofcoord->tem_IdOfCoord proc~needcalcqvalbybcid->val proc~needcalcqvalbybcid->kindpos proc~sdr_qvalbynode->val fraction_PointLine fraction_PointLine proc~sdr_qvalbynode->fraction_PointLine intersect_RayTriangle intersect_RayTriangle proc~sdr_qvalbynode->intersect_RayTriangle proc~sdr_truncate_qval->sdr_nodeprop_btest Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_target~~CalledByGraph proc~create_target create_target proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/create_target.html"},{"title":"sdr_color_points – Seeder","text":"public  subroutine sdr_color_points(nodals, nPoints, point, target_pos, fill, void, proto, iColor) Get the color at all given points. Points need to be in the interval [-1,1]. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: nodals (:) integer, intent(in) :: nPoints real(kind=rk), intent(in) :: point (:,:) Point for which to evaluate the color. integer, intent(in) :: target_pos Position of leaf in the preliminary tree real(kind=rk), intent(in) :: fill real(kind=rk), intent(in) :: void type( sdr_protoTree_type ), intent(in) :: proto preliminary tree integer, intent(in) :: iColor Calls proc~~sdr_color_points~~CallsGraph proc~sdr_color_points sdr_color_points sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_color_points->sdr_nodeprop_btest val val proc~sdr_color_points->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_color_points~~CalledByGraph proc~sdr_color_points sdr_color_points proc~create_target create_target proc~create_target->proc~sdr_color_points proc~traverse_tree traverse_tree proc~traverse_tree->proc~create_target proc~traverse_tree->proc~traverse_tree proc~sdr_proto2treelm sdr_proto2treelm proc~sdr_proto2treelm->proc~traverse_tree program~seeder seeder program~seeder->proc~sdr_proto2treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_color_points.html"},{"title":"sdr_dump_treelm – Seeder","text":"public  subroutine sdr_dump_treelm(temData, geometry, confHeader) This routine dumps the final fluid tree leaves in the disk Arguments Type Intent Optional Attributes Name type( sdr_temData_type ), intent(in) :: temData temData contains final treelmesh type( sdr_geometry_type ), intent(in) :: geometry Bounding cube, the prototree lives in. type( sdr_confHead_type ), intent(inout) :: confHeader config header info. Calls proc~~sdr_dump_treelm~~CallsGraph proc~sdr_dump_treelm sdr_dump_treelm aot_out_close aot_out_close proc~sdr_dump_treelm->aot_out_close aot_out_close_table aot_out_close_table proc~sdr_dump_treelm->aot_out_close_table aot_out_open aot_out_open proc~sdr_dump_treelm->aot_out_open aot_out_open_table aot_out_open_table proc~sdr_dump_treelm->aot_out_open_table aot_out_val aot_out_val proc~sdr_dump_treelm->aot_out_val append append proc~sdr_dump_treelm->append destroy destroy proc~sdr_dump_treelm->destroy dump_tem_global dump_tem_global proc~sdr_dump_treelm->dump_tem_global newunit newunit proc~sdr_dump_treelm->newunit proc~ply_prj_header_out ply_prj_header_out proc~sdr_dump_treelm->proc~ply_prj_header_out tem_startTimer tem_startTimer proc~sdr_dump_treelm->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_dump_treelm->tem_stopTimer uni_name uni_name proc~sdr_dump_treelm->uni_name val val proc~sdr_dump_treelm->val proc~ply_prj_header_out->aot_out_val proc~ply_fpt_header_out ply_fpt_header_out proc~ply_prj_header_out->proc~ply_fpt_header_out proc~ply_fxt_header_out ply_fxt_header_out proc~ply_prj_header_out->proc~ply_fxt_header_out proc~ply_l2p_header_out ply_l2p_header_out proc~ply_prj_header_out->proc~ply_l2p_header_out proc~ply_fpt_header_out->aot_out_val proc~ply_fxt_header_out->aot_out_val proc~ply_l2p_header_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_dump_treelm~~CalledByGraph proc~sdr_dump_treelm sdr_dump_treelm program~seeder seeder program~seeder->proc~sdr_dump_treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_dump_treelm.html"},{"title":"sdr_load_stl – Seeder","text":"public  subroutine sdr_load_stl(triArray, spaObjArray, attr_pos, transform, conf, thandle) This routine loads STL files from config and reads the triangles from the\nfiles into the dynamic array of triangles. Arguments Type Intent Optional Attributes Name type( grw_trianglearray_type ), intent(inout) :: triArray Dynamic array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray Growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute, this object is connected to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf Lua state integer, intent(in) :: thandle Calls proc~~sdr_load_stl~~CallsGraph proc~sdr_load_stl sdr_load_stl append append proc~sdr_load_stl->append tem_load_stl tem_load_stl proc~sdr_load_stl->tem_load_stl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_stl~~CalledByGraph proc~sdr_load_stl sdr_load_stl proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_stl proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_stl.html"},{"title":"ply_nodes_create – Seeder","text":"public  subroutine ply_nodes_create(me, nodes, faces, nQuadPointsPerDir, ndims) Initialize points with the Chebyshev quadrature points, 3D Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: me real(kind=rk), intent(out), allocatable :: nodes (:,:) type( ply_faceNodes_type ), intent(out), allocatable :: faces (:,:) integer, intent(in) :: nQuadPointsPerDir integer, intent(in) :: ndims Calls proc~~ply_nodes_create~~CallsGraph proc~ply_nodes_create ply_nodes_create proc~ply_nodes_surface_coords ply_nodes_surface_coords proc~ply_nodes_create->proc~ply_nodes_surface_coords proc~ply_nodes_volume_coords ply_nodes_volume_coords proc~ply_nodes_create->proc~ply_nodes_volume_coords proc~ply_point_tensor ply_point_tensor proc~ply_nodes_surface_coords->proc~ply_point_tensor proc~ply_nodes_volume_coords->proc~ply_point_tensor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_nodes_create.html"},{"title":"ply_nodes_volume_coords – Seeder","text":"private  subroutine ply_nodes_volume_coords(num_intp_per_direction, nDims, nodeset, points) Create multidimensional points from given 1D set of nodes in the cubic\nreference element. The points will be created by a tensor product of the provided 1d nodeset\nfor the given number of dimensions. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_intp_per_direction Number auf integration points in each direction. integer, intent(in) :: nDims Number of dimensions to create the points for. procedure( ply_nodeset_coords ) :: nodeset Set of node coordinates to use in the element. real(kind=rk), intent(out), allocatable :: points (:,:) Resulting list of points. First index runs over all points, second\nindicates the coordinate dimension (x=1,y=2,z=3). For ndims smaller than 3, the higher dimensions will be set to 0. Calls proc~~ply_nodes_volume_coords~~CallsGraph proc~ply_nodes_volume_coords ply_nodes_volume_coords proc~ply_point_tensor ply_point_tensor proc~ply_nodes_volume_coords->proc~ply_point_tensor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_nodes_volume_coords~~CalledByGraph proc~ply_nodes_volume_coords ply_nodes_volume_coords proc~ply_nodes_create ply_nodes_create proc~ply_nodes_create->proc~ply_nodes_volume_coords Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_nodes_volume_coords.html"},{"title":"ply_nodes_surface_coords – Seeder","text":"private  subroutine ply_nodes_surface_coords(num_intp_per_direction, ndims, nodeset, left, right, dir) Create the integration points on the surface of (cubical) elements. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_intp_per_direction Number of integration points in each direction integer, intent(in) :: ndims Number of dimensions in the element. procedure( ply_nodeset_coords ) :: nodeset Set of node coordinates to use in the element for which the surface\npoints are to be defined. real(kind=rk), intent(out), allocatable :: left (:,:) The points on the left surface. real(kind=rk), intent(out), allocatable :: right (:,:) The points on the right surface. integer :: dir The spatial direction of the face. \\n\n1 -> x direction \\n\n2 -> y direction \\n\n3 -> z direction Calls proc~~ply_nodes_surface_coords~~CallsGraph proc~ply_nodes_surface_coords ply_nodes_surface_coords proc~ply_point_tensor ply_point_tensor proc~ply_nodes_surface_coords->proc~ply_point_tensor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_nodes_surface_coords~~CalledByGraph proc~ply_nodes_surface_coords ply_nodes_surface_coords proc~ply_nodes_create ply_nodes_create proc~ply_nodes_create->proc~ply_nodes_surface_coords Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_nodes_surface_coords.html"},{"title":"ply_point_tensor – Seeder","text":"private  subroutine ply_point_tensor(nPoints1D, nDims, nodeset, points) Compute a multi-dimensional tensor for the given set of nodes. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints1D Number auf integration points in each direction. integer, intent(in) :: nDims Number of dimensions to create the points for. procedure( ply_nodeset_coords ) :: nodeset Set of node coordinates to use in the element. real(kind=rk), intent(out) :: points (nPoints1D**nDims,nDims) Resulting list of points. First index runs over all points, second\nindicates the coordinate dimension (x=1,y=2,z=3). Called by proc~~ply_point_tensor~~CalledByGraph proc~ply_point_tensor ply_point_tensor proc~ply_nodes_surface_coords ply_nodes_surface_coords proc~ply_nodes_surface_coords->proc~ply_point_tensor proc~ply_nodes_volume_coords ply_nodes_volume_coords proc~ply_nodes_volume_coords->proc~ply_point_tensor proc~ply_nodes_create ply_nodes_create proc~ply_nodes_create->proc~ply_nodes_surface_coords proc~ply_nodes_create->proc~ply_nodes_volume_coords Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_point_tensor.html"},{"title":"ply_legser – Seeder","text":"public  subroutine ply_legser(A, B, n) Subroutine to convert Chebyshev (A) to Legendre (B) coefficients. This is Piessens Algorithm, which can be found as Algorithm 473 in the\nCommunications of the ACM, January 1974, Volume 17, Number 1, page 25.\nIt is slightly modified to account for Fortran 90 practices. Algorithm makes use of the recurrence relation, by which the integral\nof the product of the nth Legendre polynomial with the kth Chebyshev\npolynomial I_{n,k} is given by: I_{n,k+2} = {[(k-1) k - n(n+1)] (k+2) / ([(k+3) (k+2) - n (n+1)] k)}\n          * I_{n,k}\nwith I_{0,0} and I_{n,k} = 0 if k < n. For I_{n,n} we have:\nI_{n,n} = 2&#94;{2n} (n!)&#94;2/(2n+1)! if n > 0 Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (n) Known coefficients of the Chebyshev approximation. real(kind=rk), intent(out) :: B (n) Computed corresponding coefficients of the Legendre approximation. integer, intent(in) :: n Number of coefficients.","tags":"","url":"proc/ply_legser.html"},{"title":"ply_filter_element_load – Seeder","text":"public  subroutine ply_filter_element_load(me, conf, parent) Loading parameters for the filtering from the configuration script.\nThis needs to be performed before any call of the actual transformation ply_split_element_1D . The initialization will compute the transformation matrix for Legendre\npolynomials with at least nMaxModes. If the initialization was already\ncalled before with the same or larger nMaxModes, the matrix will not be\nchanged. Thus, calling this routine will only increase the size of the\nmodule variable split_legendre, never decrease it. Arguments Type Intent Optional Attributes Name type( ply_filter_element_type ), intent(out) :: me Data structure that holds the filter parameters. type( flu_State ) :: conf Lua script to get the filter parameters from. integer, intent(in), optional :: parent Table handle to a possible parent, that contains the filter table\nto load. Calls proc~~ply_filter_element_load~~CallsGraph proc~ply_filter_element_load ply_filter_element_load aot_get_val aot_get_val proc~ply_filter_element_load->aot_get_val aot_table_close aot_table_close proc~ply_filter_element_load->aot_table_close aot_table_open aot_table_open proc~ply_filter_element_load->aot_table_open tem_abort tem_abort proc~ply_filter_element_load->tem_abort upper_to_lower upper_to_lower proc~ply_filter_element_load->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_filter_element_load~~CalledByGraph proc~ply_filter_element_load ply_filter_element_load proc~ply_sampling_adaptive_load ply_sampling_adaptive_load proc~ply_sampling_adaptive_load->proc~ply_filter_element_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_filter_element_load.html"},{"title":"ply_filter_element_oddfract – Seeder","text":"public  subroutine ply_filter_element_oddfract(me, nDims, inLen, element_data, filtered_data) Filter a polynomial representation in elements in one dimension according\nto its odd mode fraction. Odd and even modes are weighed with their polynomial degree (so it's a\nlittle like actually using the derivative), squared and summed\nrespectively.\nWe then compute a spectral damping order with fraction of the odd mode\nenergy in the total modal energy. The larger the fraction, the larger\ndamping order and the weaker the filtering. uscale is given by (me%max_order-me%min_order+1) . odd_fraction is given by odd / (odd+even) and the damping order is\nthen computed by me%min_order + floor(uscale * odd_fraction**me%fract_ex) The fract_exponent provides a mechanism to take larger odd fractions\nstronger into account than smaller ones. As we need to perform this operation in all dimensions, it would be good\nto shift the indices around. When doing this, we can stick to the same\nimplementation for all directions, without the need to put any logic in\nhere to decide on the current direction.\nIn 3D we would end up with this chain:\n(x,y,z) -> filter_element for Z -> (z,x,y)\n        -> filter_element for Y -> (y,z,x)\n        -> filter_element for X -> (x,y,z)\nThus, the logic is that we perform the filter on the last dimension, and\ncycle the indices in the output. We can generalize this to arbitrary dimensions.\nIn 2D it would look like this:\n(x,y) -> filter_element for Y -> (y,x)\n      -> filter_element for X -> (x,y)\nAnd in 1D, we just need to perform one transformation:\n(x) -> filter_element for X -> (x) We need: nDofs in the direction where the transformation is to be done\n         and the nDofs for all normal directions. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: nDims Number of dimensions of the polynomial data. integer, intent(in) :: inLen (nDims) Number degrees of freedom for each direction in element_data. The first index of element_data needs to have a length equal to the\nproduct of all inLen components.\nThe splitting operation will be done in the last dimension. real(kind=rk), intent(in) :: element_data (:,:) Polynomial representation in the elements. The first index are the degrees of freedom in elements, the second index\nare the elements.\nIn the first index the shape of data has to be in the form\n(inLen(1), inLen(2), ... , inLen(nDims)).\nThe filtering operation is performed on the last dimension in that\ndata. real(kind=rk), intent(out) :: filtered_data (:,:) The filtered polynomial modes. The ordering is rotated, such, that the filtered dimension becomes the\nfirst one, and all others are shifted by one to the right.\nThus, the new data has the layout (inLen(nDims), inLen(1), inLen(2), ...) Called by proc~~ply_filter_element_oddfract~~CalledByGraph proc~ply_filter_element_oddfract ply_filter_element_oddfract proc~ply_filter_oddfract_1d ply_filter_oddfract_1D proc~ply_filter_oddfract_1d->proc~ply_filter_element_oddfract proc~ply_filter_oddfract_2d ply_filter_oddfract_2D proc~ply_filter_oddfract_2d->proc~ply_filter_element_oddfract proc~ply_filter_oddfract_3d ply_filter_oddfract_3D proc~ply_filter_oddfract_3d->proc~ply_filter_element_oddfract Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_filter_element_oddfract.html"},{"title":"ply_filter_oddfract_1D – Seeder","text":"private  subroutine ply_filter_oddfract_1D(me, element_degree, element_data) Filter one-dimensional elements of degree element_degree. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. Calls proc~~ply_filter_oddfract_1d~~CallsGraph proc~ply_filter_oddfract_1d ply_filter_oddfract_1D proc~ply_filter_element_oddfract ply_filter_element_oddfract proc~ply_filter_oddfract_1d->proc~ply_filter_element_oddfract Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_filter_oddfract_1d.html"},{"title":"ply_filter_oddfract_2D – Seeder","text":"private  subroutine ply_filter_oddfract_2D(me, element_degree, element_data) Filter two-dimensional elements of degree element_degree. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. Calls proc~~ply_filter_oddfract_2d~~CallsGraph proc~ply_filter_oddfract_2d ply_filter_oddfract_2D proc~ply_filter_element_oddfract ply_filter_element_oddfract proc~ply_filter_oddfract_2d->proc~ply_filter_element_oddfract Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_filter_oddfract_2d.html"},{"title":"ply_filter_oddfract_3D – Seeder","text":"private  subroutine ply_filter_oddfract_3D(me, element_degree, element_data) Filter three-dimensional elements of degree element_degree. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. Calls proc~~ply_filter_oddfract_3d~~CallsGraph proc~ply_filter_oddfract_3d ply_filter_oddfract_3D proc~ply_filter_element_oddfract ply_filter_element_oddfract proc~ply_filter_oddfract_3d->proc~ply_filter_element_oddfract Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_filter_oddfract_3d.html"},{"title":"ply_QLegOneDimCoeff – Seeder","text":"private  function ply_QLegOneDimCoeff(nDofsOneDim, nChildDofsOneDim) result(projCoeffOneDim) Routine to create one-dimensional projection coefficient for a coarse\nelement to a fine element. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDofsOneDim The number of dofs in one dimension. integer, intent(in) :: nChildDofsOneDim The number of dofs in one dimension for the children. Return Value real(kind=rk), allocatable, (:,:,:) Projected one-dimensional coefficients. First index is Legendre polynomial on the parent element, second index\nis the Legendre polynomial on the child element, third index is left\nor right projection. Calls proc~~ply_qlegonedimcoeff~~CallsGraph proc~ply_qlegonedimcoeff ply_QLegOneDimCoeff proc~ply_gauleg ply_gauleg proc~ply_qlegonedimcoeff->proc~ply_gauleg proc~ply_legval ply_legVal proc~ply_qlegonedimcoeff->proc~ply_legval proc~ply_qlegsqnorm ply_QLegSqNorm proc~ply_qlegonedimcoeff->proc~ply_qlegsqnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_qlegonedimcoeff~~CalledByGraph proc~ply_qlegonedimcoeff ply_QLegOneDimCoeff proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_initqlegprojcoeff->proc~ply_qlegonedimcoeff proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_initqlegprojcoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_qlegonedimcoeff.html"},{"title":"ply_QLegSqNorm – Seeder","text":"private  function ply_QLegSqNorm(polyIndex) result(sqNorm) Function to calculate the squared L2-Norm of a given Legendre polynomial\non the reference element [-1,+1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polyIndex The Legendre polynomial index to calculate the squared norm for.\nThe first polynomial has index 1. Return Value real(kind=rk) The squared L2 Norm of the Legendre polynomial. Called by proc~~ply_qlegsqnorm~~CalledByGraph proc~ply_qlegsqnorm ply_QLegSqNorm proc~ply_qlegonedimcoeff ply_QLegOneDimCoeff proc~ply_qlegonedimcoeff->proc~ply_qlegsqnorm proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_initqlegprojcoeff->proc~ply_qlegonedimcoeff proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_initqlegprojcoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_qlegsqnorm.html"},{"title":"ply_legVal – Seeder","text":"private  function ply_legVal(points, nPoints, maxPolyDegree) result(val) Evaluate a given set of Legendre polynomials a given set of 1D points. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: points (:) A given set of 1D points. integer, intent(in) :: nPoints The number of points to evaluate the polynomials at. integer, intent(in) :: maxPolyDegree The maximal polynomial degree to evaluate for. Return Value real(kind=rk), allocatable, (:,:) Function values for for all Legendre polynomials up to degree\nmaxPolyDegree at all given points.\nTherefore the dimension of this array is (maxPolyDegree+1, nPoints) Called by proc~~ply_legval~~CalledByGraph proc~ply_legval ply_legVal proc~ply_qlegonedimcoeff ply_QLegOneDimCoeff proc~ply_qlegonedimcoeff->proc~ply_legval proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_initqlegprojcoeff->proc~ply_qlegonedimcoeff proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_initqlegprojcoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_legval.html"},{"title":"ply_QPolyProjection – Seeder","text":"public  subroutine ply_QPolyProjection(subsamp, dofReduction, tree, meshData, varDofs, ndims, varcomps, refine_tree, new_refine_tree, newMeshData, newVarDofs) Subsampling by L2-Projection of the Q-Tensorproduct Legendre polynomials. Arguments Type Intent Optional Attributes Name type( ply_subsample_type ), intent(in) :: subsamp Parameters for the subsampling. real(kind=rk), intent(in) :: dofReduction (:) Factor for reducion of degrees of freedom. type( treelmesh_type ), intent(in) :: tree The tree the data is written for. type( ply_array_type ), intent(in) :: meshData (:) The data to sub-sample. integer, intent(in) :: varDofs (:) The number of degrees of freedom for each scalar variable. integer, intent(in) :: ndims Number of dimensions in the polynomial representation. integer, intent(in) :: varcomps (:) Number of components logical, intent(in) :: refine_tree (:) Logical array that marks elements for refinement from the last sampling logical, intent(in) :: new_refine_tree (:) Logical array that marks elements for refinment. type( ply_array_type ), intent(out), allocatable :: newMeshData (:) The subsampled data. integer, intent(out), allocatable :: newVarDofs (:) The number of dofs for the subsampled dofs. Calls proc~~ply_qpolyprojection~~CallsGraph proc~ply_qpolyprojection ply_QPolyProjection proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_qpolyprojection->proc~ply_initqlegprojcoeff proc~ply_subsampledata ply_subsampleData proc~ply_qpolyprojection->proc~ply_subsampledata tem_abort tem_abort proc~ply_qpolyprojection->tem_abort proc~ply_initqlegprojcoeff->tem_abort proc~ply_doftoqpoly ply_dofToQPoly proc~ply_initqlegprojcoeff->proc~ply_doftoqpoly proc~ply_qlegonedimcoeff ply_QLegOneDimCoeff proc~ply_initqlegprojcoeff->proc~ply_qlegonedimcoeff proc~ply_projdatatochild ply_projDataToChild proc~ply_subsampledata->proc~ply_projdatatochild proc~ply_gauleg ply_gauleg proc~ply_qlegonedimcoeff->proc~ply_gauleg proc~ply_legval ply_legVal proc~ply_qlegonedimcoeff->proc~ply_legval proc~ply_qlegsqnorm ply_QLegSqNorm proc~ply_qlegonedimcoeff->proc~ply_qlegsqnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_qpolyprojection.html"},{"title":"ply_gauleg – Seeder","text":"public  subroutine ply_gauleg(x1, x2, x, w, nIntP) subroutine to create gauss points and weights for one-dimensional\nintegration on the interval [x1,x2]. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x1 lower limit of integration interval real(kind=rk), intent(in) :: x2 upper limit of integration interval real(kind=rk), intent(inout), allocatable :: x (:) The coordinates of the gauss points on the interval [-1,1].\nThe array has the length nIntP. real(kind=rk), intent(inout), allocatable :: w (:) The quadrature weights. The array has the length nIntP. integer, intent(in) :: nIntP The number of integration points. Called by proc~~ply_gauleg~~CalledByGraph proc~ply_gauleg ply_gauleg proc~ply_qlegonedimcoeff ply_QLegOneDimCoeff proc~ply_qlegonedimcoeff->proc~ply_gauleg proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_initqlegprojcoeff->proc~ply_qlegonedimcoeff proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_initqlegprojcoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_gauleg.html"},{"title":"ply_initQLegProjCoeff – Seeder","text":"private  subroutine ply_initQLegProjCoeff(dofType, nDofs, ndims, nChilds, nChildDofs, projection) Routine to initialize the projection coefficients for a usage in the\nsubsampling routine to project degrees of freedoms of a parent cell\nto the degrees of freedoms of a child cell if the degrees of\nfreedoms are Q-Legendre polynomials. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dofType The type of degrees of freedom we have in our cells. integer, intent(in) :: nDofs The number of degrees of freedom for the parent cells. integer, intent(in) :: ndims The  number of dimensions in the polynomial representation. integer, intent(in) :: nChilds The number of child cells. integer, intent(in) :: nChildDofs The number of degrees of freedom for the child cells. type( ply_ProjCoeff_type ), intent(out) :: projection The subsampling coefficients that will be initialized by this routine. Calls proc~~ply_initqlegprojcoeff~~CallsGraph proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_doftoqpoly ply_dofToQPoly proc~ply_initqlegprojcoeff->proc~ply_doftoqpoly proc~ply_qlegonedimcoeff ply_QLegOneDimCoeff proc~ply_initqlegprojcoeff->proc~ply_qlegonedimcoeff tem_abort tem_abort proc~ply_initqlegprojcoeff->tem_abort proc~ply_gauleg ply_gauleg proc~ply_qlegonedimcoeff->proc~ply_gauleg proc~ply_legval ply_legVal proc~ply_qlegonedimcoeff->proc~ply_legval proc~ply_qlegsqnorm ply_QLegSqNorm proc~ply_qlegonedimcoeff->proc~ply_qlegsqnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_initqlegprojcoeff~~CalledByGraph proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_initqlegprojcoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_initqlegprojcoeff.html"},{"title":"ply_dofToQPoly – Seeder","text":"private  subroutine ply_dofToQPoly(dof, nDofs, ndims, xAnsFunc, yAnsFunc, zAnsFunc) Subroutine to convert linearized dof index to ansatz function number for\nQ-Polynomials. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dof The linearized degree of freedom index. integer, intent(in) :: nDofs The number of dofs for all directions. integer, intent(in) :: ndims The number of Dimensions in the polynomial representation. integer, intent(out) :: xAnsFunc The ansatz function number in x direction. integer, intent(out) :: yAnsFunc The ansatz function number in y direction. integer, intent(out) :: zAnsFunc The ansatz function number in z direction. Called by proc~~ply_doftoqpoly~~CalledByGraph proc~ply_doftoqpoly ply_dofToQPoly proc~ply_initqlegprojcoeff ply_initQLegProjCoeff proc~ply_initqlegprojcoeff->proc~ply_doftoqpoly proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_initqlegprojcoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_doftoqpoly.html"},{"title":"ply_subsampleData – Seeder","text":"private  subroutine ply_subsampleData(tree, meshData, nDofs, nChildDofs, nComponents, projection, projection_oneDof, refine_tree, new_refine_tree, ndims, subsamp, newMeshData) Routine to subsample mesh information for one refinement level. Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(in) :: tree The tree the data is written for. real(kind=rk), intent(in) :: meshData (:) The data to sub-sample. integer, intent(in) :: nDofs The number of degrees of freedom for each scalar variable. integer, intent(in) :: nChildDofs The number of degrees of freedom per scalar variable on the child\nelements. integer, intent(in) :: nComponents Number of components type( ply_ProjCoeff_type ), intent(in) :: projection Projection coefficients for the given data. type( ply_ProjCoeff_type ), intent(in), optional :: projection_oneDof Projection coeffiecients for the the reduction to polynomial\ndegree of 0. logical, intent(in), optional :: refine_tree (:) Logical array that marks all elements for refinement from the last\nsampling lvl. logical, intent(in) :: new_refine_tree (:) Logical array that marks all elements for refinement integer, intent(in) :: ndims The number of dimensions in the polynomial representation. type( ply_subsample_type ), intent(in) :: subsamp Parameters for the subsampling. real(kind=rk), intent(out), allocatable :: newMeshData (:) The subsampled data. Calls proc~~ply_subsampledata~~CallsGraph proc~ply_subsampledata ply_subsampleData proc~ply_projdatatochild ply_projDataToChild proc~ply_subsampledata->proc~ply_projdatatochild Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_subsampledata~~CalledByGraph proc~ply_subsampledata ply_subsampleData proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_subsampledata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_subsampledata.html"},{"title":"ply_projDataToChild – Seeder","text":"private  subroutine ply_projDataToChild(parentData, nParentDofs, nChildDofs, nComponents, nChilds, projection, childData) Subroutine to project elemental data from a parent cell to one of\nits children. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: parentData (:) Linearized data for a single variable (can have multiple components)\nand a single degree of freedom of the parent cell. integer, intent(in) :: nParentDofs The number of dofs of the parent element. integer, intent(in) :: nChildDofs The total number of dofs for the child cells. integer, intent(in) :: nComponents The number of componentns of the given variable. integer, intent(in) :: nChilds The number of children. type( ply_ProjCoeff_type ), intent(in) :: projection The information about the projection coefficients for the parent\ndofs to the child dofs. real(kind=rk), intent(out) :: childData (:) The created childData. Called by proc~~ply_projdatatochild~~CalledByGraph proc~ply_projdatatochild ply_projDataToChild proc~ply_subsampledata ply_subsampleData proc~ply_subsampledata->proc~ply_projdatatochild proc~ply_qpolyprojection ply_QPolyProjection proc~ply_qpolyprojection->proc~ply_subsampledata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_projdatatochild.html"},{"title":"ply_split_legendre_matrix – Seeder","text":"public pure function ply_split_legendre_matrix(nModes) result(split_matrix) Compute the transformation matrix for a projection to the left and right\n half-interval of Legendre polynomials for the given maximal number of\n modes. Note: The transformation matrices to each subinterval are triangular, and\n       the diagonal entries are the same. To save memory both matrices are\n       stored in a single 2 dimensional array of size\n       (nModes, nModes). This matrix only needs to be computed once for a sufficiently high order,\n as submatices out of it can by used to perform the transformation for\n any lower polynomial degree. The upper triangular matrix is created for the right subinterval,\n while the lower triangular matrix is used to store the rotated version\n for the left subinterval.\n For the right interval we interpret the first index as row index\n and the second as column. For the left interval this is reverted and\n we interpret the first index as columns of the matrix. Note Why is this a function? The reasoning for making this a function\n      is that we need to return exactly one thing (the split matrix).\n      It is then quite natural to refer to this by\n      ply_split_legendre_matrix. A subroutine on the other hand usually\n      describes something that should be done. Thus the name for a\n      subroutine would then be ply_split_legendre_compute_matrix\n      (describing the action performed by the subroutine).\n      When using OpenMP it sometimes is better to use subroutines, even\n      though it would be more natural to use a function. However, here\n      we do not expect this to be the case, as this is expected to be\n      called only once. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes The maximal number of modes to compute the transformation for. The resulting matrix v will be max_modes x max_modes large and can\nbe used for the transformation of all polynomials with up to this\nmany modes. Return Value real(kind=rk), (nModes,nModes) Calls proc~~ply_split_legendre_matrix~~CallsGraph proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~alpha alpha proc~ply_split_legendre_matrix->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix->proc~alpha_frac proc~beta beta proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_split_legendre_matrix~~CalledByGraph proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_element_init ply_split_element_init proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~ply_split_legendre_test ply_split_legendre_test proc~ply_split_legendre_test->proc~ply_split_legendre_matrix proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_split_element_init proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_1d_test->proc~ply_split_element_init proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_init proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_legendre_matrix.html"},{"title":"alpha – Seeder","text":"private elemental function alpha(mode) Coefficient alpha from the recursive formulation of Legendre polynomials,\nfor the Legendre mode 'mode'. For Legendre polynomials we have: Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The Legendre mode to compute for. Return Value real(kind=rk) Called by proc~~alpha~~CalledByGraph proc~alpha alpha proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_legendre_matrix->proc~alpha proc~ply_split_legendre_test ply_split_legendre_test proc~ply_split_legendre_test->proc~alpha proc~ply_split_legendre_test->proc~ply_split_legendre_matrix proc~ply_split_element_init ply_split_element_init proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_split_element_init proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_1d_test->proc~ply_split_element_init proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_init proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/alpha.html"},{"title":"beta – Seeder","text":"private elemental function beta(mode) Coefficient beta from the recursive formulation of Legendre polynomials,\n for the Legendre mode 'mode'. For Legendre polynomials we have: Note This is negative for all modes > 1. Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The Legendre mode to compute for. Return Value real(kind=rk) Called by proc~~beta~~CalledByGraph proc~beta beta proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_legendre_matrix->proc~beta proc~ply_split_legendre_test ply_split_legendre_test proc~ply_split_legendre_test->proc~beta proc~ply_split_legendre_test->proc~ply_split_legendre_matrix proc~ply_split_element_init ply_split_element_init proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_split_element_init proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_1d_test->proc~ply_split_element_init proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_init proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/beta.html"},{"title":"alpha_frac – Seeder","text":"private elemental function alpha_frac(denominator, numerator) Quotient of two alpha values. This function computes alpha(numerator)/alpha(denominator). Note This is intended to keep as many integer operations together as\n      possible. Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Legendre mode of the to use in the denominator. integer, intent(in) :: numerator Legendre mode of the to use in the numeratorr. Return Value real(kind=rk) Called by proc~~alpha_frac~~CalledByGraph proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_legendre_matrix->proc~alpha_frac proc~ply_split_legendre_test ply_split_legendre_test proc~ply_split_legendre_test->proc~alpha_frac proc~ply_split_legendre_test->proc~ply_split_legendre_matrix proc~ply_split_element_init ply_split_element_init proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_split_element_init proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_1d_test->proc~ply_split_element_init proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_init proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/alpha_frac.html"},{"title":"alpha_beta – Seeder","text":"private elemental function alpha_beta(denominator, numerator) Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) as\nneeded by the Clenshaw algorithm in ply_split_legendre_matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Legendre mode for the in the denominator and the . integer, intent(in) :: numerator Legendre mode for the in the numerator. Return Value real(kind=rk) Called by proc~~alpha_beta~~CalledByGraph proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_legendre_matrix->proc~alpha_beta proc~ply_split_legendre_test ply_split_legendre_test proc~ply_split_legendre_test->proc~alpha_beta proc~ply_split_legendre_test->proc~ply_split_legendre_matrix proc~ply_split_element_init ply_split_element_init proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_split_element_init proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_1d_test->proc~ply_split_element_init proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_init proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/alpha_beta.html"},{"title":"ply_split_legendre_test – Seeder","text":"public  subroutine ply_split_legendre_test(success) A small testing routine to check the functions of this module. Arguments Type Intent Optional Attributes Name logical, intent(out) :: success Indication whether the tests were completed successfully. Calls proc~~ply_split_legendre_test~~CallsGraph proc~ply_split_legendre_test ply_split_legendre_test proc~alpha alpha proc~ply_split_legendre_test->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_test->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_test->proc~alpha_frac proc~beta beta proc~ply_split_legendre_test->proc~beta proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_legendre_test->proc~ply_split_legendre_matrix proc~ply_split_legendre_matrix->proc~alpha proc~ply_split_legendre_matrix->proc~alpha_beta proc~ply_split_legendre_matrix->proc~alpha_frac proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_legendre_test.html"},{"title":"ply_init_fxt – Seeder","text":"public  subroutine ply_init_fxt(fxt, header, degree) Initialize the flpt data structure for fast legendre polynomial\ntransformation via the fxtpack. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ), intent(out) :: fxt Handle to the resulting fast polynomial table. type( ply_fxt_header_type ), intent(in) :: header integer, intent(in) :: degree Polynomial degree. Calls proc~~ply_init_fxt~~CallsGraph proc~ply_init_fxt ply_init_fxt fxtf_flptld_init fxtf_flptld_init proc~ply_init_fxt->fxtf_flptld_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_init_fxt.html"},{"title":"ply_fxt_m2n_1D – Seeder","text":"public  subroutine ply_fxt_m2n_1D(fxt, modal_data, nodal_data) Convert modal data to nodal data in 1D using flpt. This encapsualtes the pure C-Interface, with extraction of the array\nsizes and dealing with the flpt data. Note: The modal and nodal data array sizes need to match the flpt\ndefinitions, provided in the fxtf_flptld_init call. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: modal_data (:) Modal data real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data Calls proc~~ply_fxt_m2n_1d~~CallsGraph proc~ply_fxt_m2n_1d ply_fxt_m2n_1D fxtf_flptld_m2n fxtf_flptld_m2n proc~ply_fxt_m2n_1d->fxtf_flptld_m2n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_m2n_1d.html"},{"title":"ply_fxt_m2n_2D – Seeder","text":"public  subroutine ply_fxt_m2n_2D(fxt, modal_data, nodal_data, oversamp_degree) Convert modal data to nodal data in 2D using flpt. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: modal_data (:) Modal data real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data integer, intent(in) :: oversamp_degree Calls proc~~ply_fxt_m2n_2d~~CallsGraph proc~ply_fxt_m2n_2d ply_fxt_m2n_2D fxtf_flptld_m2n fxtf_flptld_m2n proc~ply_fxt_m2n_2d->fxtf_flptld_m2n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_m2n_2d.html"},{"title":"ply_fxt_m2n_3D – Seeder","text":"public  subroutine ply_fxt_m2n_3D(fxt, modal_data, nodal_data, oversamp_degree) Convert modal data to nodal data in 3D using flpt. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: modal_data (:) Modal data real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data integer, intent(in) :: oversamp_degree Calls proc~~ply_fxt_m2n_3d~~CallsGraph proc~ply_fxt_m2n_3d ply_fxt_m2n_3D fxtf_flptld_m2n fxtf_flptld_m2n proc~ply_fxt_m2n_3d->fxtf_flptld_m2n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_m2n_3d.html"},{"title":"ply_fxt_n2m_1D – Seeder","text":"public  subroutine ply_fxt_n2m_1D(fxt, nodal_data, modal_data) Convert nodal data to modal data using flpt. This encapsualtes the pure C-Interface, with extraction of the array\nsizes and dealing with the flpt data. Note: The modal and nodal data array sizes need to match the flpt\ndefinitions, provided in the fxtf_flptld_init call. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data real(kind=rk), intent(inout), target :: modal_data (:) Modal data Calls proc~~ply_fxt_n2m_1d~~CallsGraph proc~ply_fxt_n2m_1d ply_fxt_n2m_1D fxtf_flptld_n2m fxtf_flptld_n2m proc~ply_fxt_n2m_1d->fxtf_flptld_n2m Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_n2m_1d.html"},{"title":"ply_fxt_n2m_2D – Seeder","text":"public  subroutine ply_fxt_n2m_2D(fxt, nodal_data, modal_data, oversamp_degree) Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), target :: nodal_data (:) Nodal data real(kind=rk), target :: modal_data (:) Modal data integer, intent(in) :: oversamp_degree Calls proc~~ply_fxt_n2m_2d~~CallsGraph proc~ply_fxt_n2m_2d ply_fxt_n2m_2D fxtf_flptld_n2m fxtf_flptld_n2m proc~ply_fxt_n2m_2d->fxtf_flptld_n2m Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_n2m_2d.html"},{"title":"ply_fxt_n2m_3D – Seeder","text":"public  subroutine ply_fxt_n2m_3D(fxt, nodal_data, modal_data, oversamp_degree) Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data real(kind=rk), intent(inout), target :: modal_data (:) Modal data integer, intent(in) :: oversamp_degree Calls proc~~ply_fxt_n2m_3d~~CallsGraph proc~ply_fxt_n2m_3d ply_fxt_n2m_3D fxtf_flptld_n2m fxtf_flptld_n2m proc~ply_fxt_n2m_3d->fxtf_flptld_n2m Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_n2m_3d.html"},{"title":"ply_gaussLegPoints – Seeder","text":"public  subroutine ply_gaussLegPoints(x1, x2, x, w, nIntP) Create Gauss-Legendre integration points and weights for one-dimensional\nintegration on the interval [x1,x2]. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x1 lower limit of integration interval real(kind=rk), intent(in) :: x2 upper limit of integration interval real(kind=rk), intent(out) :: x (:) The coordinates of the gauss points on the interval [x1,x2].\nThe array has the length nIntP. real(kind=rk), intent(out) :: w (:) The quadrature weights. The array has the length nIntP. integer, intent(in) :: nIntP The number of integration points. Called by proc~~ply_gausslegpoints~~CalledByGraph proc~ply_gausslegpoints ply_gaussLegPoints proc~ply_init_l2p ply_init_l2p proc~ply_init_l2p->proc~ply_gausslegpoints Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_gausslegpoints.html"},{"title":"isEqual – Seeder","text":"private pure function isEqual(left, right) result(equality) This function provides the test for equality of the header for two\nprojections. The headers are considered to be equal, if their kind and the corresponding\nheaders are equal. For unknown kinds, the headers are not taken into\nconsideration. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? Called by proc~~isequal~2~~CalledByGraph proc~isequal~2 isEqual interface~operator(==)~2 operator(==) interface~operator(==)~2->proc~isequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isequal~2.html"},{"title":"isUnequal – Seeder","text":"private pure function isUnequal(left, right) result(unequality) This function provides the test for unequality of the header of two\nprojections. Two projections are considered to be unequal, if their kind, their\nfpt-header or l2p_header are not equal. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? Called by proc~~isunequal~2~~CalledByGraph proc~isunequal~2 isUnequal interface~operator(SLASH=)~2 operator(/=) interface~operator(SLASH=)~2->proc~isunequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isunequal~2.html"},{"title":"isSmaller – Seeder","text":"private pure function isSmaller(left, right) result(small) This function provides a < comparison of the header of two projections. Sorting of projections is given by the kind, fpt_header and\nlast by l2p_header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmaller~2~~CalledByGraph proc~issmaller~2 isSmaller interface~operator(lt)~2 operator(<) interface~operator(lt)~2->proc~issmaller~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmaller~2.html"},{"title":"isSmallerOrEqual – Seeder","text":"private pure function isSmallerOrEqual(left, right) result(small) This function provides a <= comparison of the header of two projections. Sorting of projections is given by kind, fpt_header and\nlast by the l2p header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmallerorequal~2~~CalledByGraph proc~issmallerorequal~2 isSmallerOrEqual interface~operator(lt=)~2 operator(<=) interface~operator(lt=)~2->proc~issmallerorequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmallerorequal~2.html"},{"title":"isGreater – Seeder","text":"private pure function isGreater(left, right) result(great) This function provides a > comparison of the header of two projections. Sorting of projections is given by kind, fpt_header and\nlast by l2p_header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreater~2~~CalledByGraph proc~isgreater~2 isGreater interface~operator(gt)~2 operator(>) interface~operator(gt)~2->proc~isgreater~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreater~2.html"},{"title":"isGreaterOrEqual – Seeder","text":"private pure function isGreaterOrEqual(left, right) result(great) This function provides a >= comparison of the header of two projections. Sorting of projections is given by kind, fpt_header and\nlast by l2p_header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreaterorequal~2~~CalledByGraph proc~isgreaterorequal~2 isGreaterOrEqual interface~operator(gt=)~2 operator(>=) interface~operator(gt=)~2->proc~isgreaterorequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreaterorequal~2.html"},{"title":"ply_prj_header_load – Seeder","text":"public  subroutine ply_prj_header_load(me, conf, parent) Load settings to describe a projection method from a Lua table. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in) :: parent A parent Lua table, in which the boundary conditions are to be found. Calls proc~~ply_prj_header_load~~CallsGraph proc~ply_prj_header_load ply_prj_header_load aot_get_val aot_get_val proc~ply_prj_header_load->aot_get_val proc~ply_fpt_header_display ply_fpt_header_display proc~ply_prj_header_load->proc~ply_fpt_header_display proc~ply_fpt_header_load ply_fpt_header_load proc~ply_prj_header_load->proc~ply_fpt_header_load proc~ply_fxt_header_display ply_fxt_header_display proc~ply_prj_header_load->proc~ply_fxt_header_display proc~ply_fxt_header_load ply_fxt_header_load proc~ply_prj_header_load->proc~ply_fxt_header_load proc~ply_l2p_header_display ply_l2p_header_display proc~ply_prj_header_load->proc~ply_l2p_header_display proc~ply_l2p_header_load ply_l2p_header_load proc~ply_prj_header_load->proc~ply_l2p_header_load tem_abort tem_abort proc~ply_prj_header_load->tem_abort upper_to_lower upper_to_lower proc~ply_prj_header_load->upper_to_lower proc~ply_fpt_header_load->aot_get_val proc~ply_fpt_header_load->tem_abort proc~ply_fpt_header_load->upper_to_lower proc~ply_fxt_header_load->aot_get_val proc~ply_fxt_header_load->tem_abort proc~ply_l2p_header_load->aot_get_val proc~ply_l2p_header_load->tem_abort proc~ply_l2p_header_load->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_prj_header_load~~CalledByGraph proc~ply_prj_header_load ply_prj_header_load proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_prj_header_load.html"},{"title":"ply_prj_header_out – Seeder","text":"public  subroutine ply_prj_header_out(me, conf) Load settings to describe a projection method from a Lua table. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: me type( aot_out_type ) :: conf Calls proc~~ply_prj_header_out~~CallsGraph proc~ply_prj_header_out ply_prj_header_out aot_out_val aot_out_val proc~ply_prj_header_out->aot_out_val proc~ply_fpt_header_out ply_fpt_header_out proc~ply_prj_header_out->proc~ply_fpt_header_out proc~ply_fxt_header_out ply_fxt_header_out proc~ply_prj_header_out->proc~ply_fxt_header_out proc~ply_l2p_header_out ply_l2p_header_out proc~ply_prj_header_out->proc~ply_l2p_header_out proc~ply_fpt_header_out->aot_out_val proc~ply_fxt_header_out->aot_out_val proc~ply_l2p_header_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_prj_header_out~~CalledByGraph proc~ply_prj_header_out ply_prj_header_out proc~sdr_dump_treelm sdr_dump_treelm proc~sdr_dump_treelm->proc~ply_prj_header_out program~seeder seeder program~seeder->proc~sdr_dump_treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_prj_header_out.html"},{"title":"Copy_poly_proj_header – Seeder","text":"private pure subroutine Copy_poly_proj_header(left, right) Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(out) :: left fpt to copy to type( ply_prj_header_type ), intent(in) :: right fpt to copy from Called by proc~~copy_poly_proj_header~~CalledByGraph proc~copy_poly_proj_header Copy_poly_proj_header interface~assignment(=)~2 assignment(=) interface~assignment(=)~2->proc~copy_poly_proj_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/copy_poly_proj_header.html"},{"title":"assignment(=) – Seeder","text":"public interface assignment(=) Calls interface~~assignment(=)~2~~CallsGraph interface~assignment(=)~2 assignment(=) proc~copy_poly_proj_header Copy_poly_proj_header interface~assignment(=)~2->proc~copy_poly_proj_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine Copy_poly_proj_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(out) :: left fpt to copy to type( ply_prj_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"interface/assignment(=)~2.html"},{"title":"operator(==) – Seeder","text":"public interface operator(==) Calls interface~~operator(==)~2~~CallsGraph interface~operator(==)~2 operator(==) proc~isequal~2 isEqual interface~operator(==)~2->proc~isequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isEqual (left, right) result(equality) This function provides the test for equality of the header for two\nprojections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is equal??","tags":"","url":"interface/operator(==)~2.html"},{"title":"operator(/=) – Seeder","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~2~~CallsGraph interface~operator(SLASH=)~2 operator(/=) proc~isunequal~2 isUnequal interface~operator(SLASH=)~2->proc~isunequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of the header of two\nprojections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal??","tags":"","url":"interface/operator(SLASH=)~2.html"},{"title":"operator(<) – Seeder","text":"public interface operator(<) Calls interface~~operator(lt)~2~~CallsGraph interface~operator(lt)~2 operator(<) proc~issmaller~2 isSmaller interface~operator(lt)~2->proc~issmaller~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmaller (left, right) result(small) This function provides a < comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt)~2.html"},{"title":"operator(<=) – Seeder","text":"public interface operator(<=) Calls interface~~operator(lt=)~2~~CallsGraph interface~operator(lt=)~2 operator(<=) proc~issmallerorequal~2 isSmallerOrEqual interface~operator(lt=)~2->proc~issmallerorequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt=)~2.html"},{"title":"operator(>) – Seeder","text":"public interface operator(>) Calls interface~~operator(gt)~2~~CallsGraph interface~operator(gt)~2 operator(>) proc~isgreater~2 isGreater interface~operator(gt)~2->proc~isgreater~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreater (left, right) result(great) This function provides a > comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt)~2.html"},{"title":"operator(>=) – Seeder","text":"public interface operator(>=) Calls interface~~operator(gt=)~2~~CallsGraph interface~operator(gt=)~2 operator(>=) proc~isgreaterorequal~2 isGreaterOrEqual interface~operator(gt=)~2->proc~isgreaterorequal~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt=)~2.html"},{"title":"sdr_addTimers – Seeder","text":"public  subroutine sdr_addTimers() Setup timers to assess the runtime of various parts of Seeder Arguments None Calls proc~~sdr_addtimers~~CallsGraph proc~sdr_addtimers sdr_addTimers tem_addTimer tem_addTimer proc~sdr_addtimers->tem_addTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_addtimers~~CalledByGraph proc~sdr_addtimers sdr_addTimers program~seeder seeder program~seeder->proc~sdr_addtimers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_addtimers.html"},{"title":"sdr_dumptimers – Seeder","text":"public  subroutine sdr_dumptimers(general, nFluids, nBnds) Performance results are written to a file for statistical review write file Arguments Type Intent Optional Attributes Name type( tem_general_type ), intent(in) :: general Parameters of the current simulation integer, intent(in) :: nFluids Number of fluid elements in dumped mesh integer, intent(in) :: nBnds Number of fluid elements which has boundary in dumped mesh Calls proc~~sdr_dumptimers~~CallsGraph proc~sdr_dumptimers sdr_dumptimers newunit newunit proc~sdr_dumptimers->newunit tem_getMaxTimerVal tem_getMaxTimerVal proc~sdr_dumptimers->tem_getMaxTimerVal tem_getTimerName tem_getTimerName proc~sdr_dumptimers->tem_getTimerName Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_dumptimers~~CalledByGraph proc~sdr_dumptimers sdr_dumptimers program~seeder seeder program~seeder->proc~sdr_dumptimers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_dumptimers.html"},{"title":"isEqual – Seeder","text":"private pure function isEqual(left, right) result(equality) This function provides the test for equality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? Called by proc~~isequal~3~~CalledByGraph proc~isequal~3 isEqual interface~operator(==)~3 operator(==) interface~operator(==)~3->proc~isequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isequal~3.html"},{"title":"isUnequal – Seeder","text":"private pure function isUnequal(left, right) result(unequality) This function provides the test for unequality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? Called by proc~~isunequal~3~~CalledByGraph proc~isunequal~3 isUnequal interface~operator(SLASH=)~3 operator(/=) interface~operator(SLASH=)~3->proc~isunequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isunequal~3.html"},{"title":"isSmaller – Seeder","text":"private pure function isSmaller(left, right) result(small) This function provides a < comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmaller~3~~CalledByGraph proc~issmaller~3 isSmaller interface~operator(lt)~3 operator(<) interface~operator(lt)~3->proc~issmaller~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmaller~3.html"},{"title":"isSmallerOrEqual – Seeder","text":"private pure function isSmallerOrEqual(left, right) result(small) This function provides a <= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmallerorequal~3~~CalledByGraph proc~issmallerorequal~3 isSmallerOrEqual interface~operator(lt=)~3 operator(<=) interface~operator(lt=)~3->proc~issmallerorequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmallerorequal~3.html"},{"title":"isGreater – Seeder","text":"private pure function isGreater(left, right) result(great) This function provides a > comparison of nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreater~3~~CalledByGraph proc~isgreater~3 isGreater interface~operator(gt)~3 operator(>) interface~operator(gt)~3->proc~isgreater~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreater~3.html"},{"title":"isGreaterOrEqual – Seeder","text":"private pure function isGreaterOrEqual(left, right) result(great) This function provides a >= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreaterorequal~3~~CalledByGraph proc~isgreaterorequal~3 isGreaterOrEqual interface~operator(gt=)~3 operator(>=) interface~operator(gt=)~3->proc~isgreaterorequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreaterorequal~3.html"},{"title":"Copy_nodes_header – Seeder","text":"private pure subroutine Copy_nodes_header(left, right) Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(out) :: left fpt to copy to type( ply_nodes_header_type ), intent(in) :: right fpt to copy from Called by proc~~copy_nodes_header~~CalledByGraph proc~copy_nodes_header Copy_nodes_header interface~assignment(=)~3 assignment(=) interface~assignment(=)~3->proc~copy_nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/copy_nodes_header.html"},{"title":"assignment(=) – Seeder","text":"public interface assignment(=) Calls interface~~assignment(=)~3~~CallsGraph interface~assignment(=)~3 assignment(=) proc~copy_nodes_header Copy_nodes_header interface~assignment(=)~3->proc~copy_nodes_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine Copy_nodes_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(out) :: left fpt to copy to type( ply_nodes_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"interface/assignment(=)~3.html"},{"title":"operator(==) – Seeder","text":"public interface operator(==) Calls interface~~operator(==)~3~~CallsGraph interface~operator(==)~3 operator(==) proc~isequal~3 isEqual interface~operator(==)~3->proc~isequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isEqual (left, right) result(equality) This function provides the test for equality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is equal??","tags":"","url":"interface/operator(==)~3.html"},{"title":"operator(/=) – Seeder","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~3~~CallsGraph interface~operator(SLASH=)~3 operator(/=) proc~isunequal~3 isUnequal interface~operator(SLASH=)~3->proc~isunequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal??","tags":"","url":"interface/operator(SLASH=)~3.html"},{"title":"operator(<) – Seeder","text":"public interface operator(<) Calls interface~~operator(lt)~3~~CallsGraph interface~operator(lt)~3 operator(<) proc~issmaller~3 isSmaller interface~operator(lt)~3->proc~issmaller~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmaller (left, right) result(small) This function provides a < comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt)~3.html"},{"title":"operator(<=) – Seeder","text":"public interface operator(<=) Calls interface~~operator(lt=)~3~~CallsGraph interface~operator(lt=)~3 operator(<=) proc~issmallerorequal~3 isSmallerOrEqual interface~operator(lt=)~3->proc~issmallerorequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt=)~3.html"},{"title":"operator(>) – Seeder","text":"public interface operator(>) Calls interface~~operator(gt)~3~~CallsGraph interface~operator(gt)~3 operator(>) proc~isgreater~3 isGreater interface~operator(gt)~3->proc~isgreater~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreater (left, right) result(great) This function provides a > comparison of nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt)~3.html"},{"title":"operator(>=) – Seeder","text":"public interface operator(>=) Calls interface~~operator(gt=)~3~~CallsGraph interface~operator(gt=)~3 operator(>=) proc~isgreaterorequal~3 isGreaterOrEqual interface~operator(gt=)~3->proc~isgreaterorequal~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt=)~3.html"},{"title":"sdr_inHerit_distanceRefineObject – Seeder","text":"public  subroutine sdr_inHerit_distanceRefineObject(proto, geometry) This routines inherit distance refine sphere object from root node\ndown to leaf node. \nOnly the object with level greater than node level are inHerited Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data to refine further type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos Calls proc~~sdr_inherit_distancerefineobject~~CallsGraph proc~sdr_inherit_distancerefineobject sdr_inHerit_distanceRefineObject proc~inherit_intersectedobject inHerit_intersectedObject proc~sdr_inherit_distancerefineobject->proc~inherit_intersectedobject tem_FirstIdAtLevel tem_FirstIdAtLevel proc~sdr_inherit_distancerefineobject->tem_FirstIdAtLevel tem_horizontalSpacer tem_horizontalSpacer proc~sdr_inherit_distancerefineobject->tem_horizontalSpacer tem_startTimer tem_startTimer proc~sdr_inherit_distancerefineobject->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_inherit_distancerefineobject->tem_stopTimer val val proc~sdr_inherit_distancerefineobject->val proc~inherit_intersectedobject->val append append proc~inherit_intersectedobject->append proc~is_intersecting is_intersecting proc~inherit_intersectedobject->proc~is_intersecting sdr_append_childintersectedobject sdr_append_childintersectedobject proc~inherit_intersectedobject->sdr_append_childintersectedobject tem_CoordOfId tem_CoordOfId proc~inherit_intersectedobject->tem_CoordOfId tem_sphereCubeOverlap tem_sphereCubeOverlap proc~inherit_intersectedobject->tem_sphereCubeOverlap proc~is_intersecting->val proc~is_intersecting->tem_sphereCubeOverlap sdr_periodicplanecubeoverlap sdr_periodicplanecubeoverlap proc~is_intersecting->sdr_periodicplanecubeoverlap sdr_spacerinterwovencubeoverlap sdr_spacerinterwovencubeoverlap proc~is_intersecting->sdr_spacerinterwovencubeoverlap tem_boxCubeOverlap tem_boxCubeOverlap proc~is_intersecting->tem_boxCubeOverlap tem_cylinderCubeOverlap tem_cylinderCubeOverlap proc~is_intersecting->tem_cylinderCubeOverlap tem_ellipsoidCubeOverlap tem_ellipsoidCubeOverlap proc~is_intersecting->tem_ellipsoidCubeOverlap tem_lineCubeOverlap tem_lineCubeOverlap proc~is_intersecting->tem_lineCubeOverlap tem_pointCubeOverlap tem_pointCubeOverlap proc~is_intersecting->tem_pointCubeOverlap tem_triangleCubeOverlap tem_triangleCubeOverlap proc~is_intersecting->tem_triangleCubeOverlap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_inherit_distancerefineobject~~CalledByGraph proc~sdr_inherit_distancerefineobject sdr_inHerit_distanceRefineObject program~seeder seeder program~seeder->proc~sdr_inherit_distancerefineobject Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_inherit_distancerefineobject.html"},{"title":"sdr_refine_leaf – Seeder","text":"public  subroutine sdr_refine_leaf(proto, geometry) This routine extends the protoTree with max of minlevel or level of\nrefinement object. If it is a leaf, check for intersected objects, and keep\non refining accordingly down to the maximum requested level.\nWhen the desired level is reached (no refinement object,\nor desired level of intersected refinement object reached, check all\n(26) direct neigbors. If there is a neighbor intersected by a boundary\ncheck its refinement level, if it is higher then the current one,\ndo another refinement step. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data to refine further type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos Calls proc~~sdr_refine_leaf~~CallsGraph proc~sdr_refine_leaf sdr_refine_leaf append append proc~sdr_refine_leaf->append destroy destroy proc~sdr_refine_leaf->destroy init init proc~sdr_refine_leaf->init proc~check_bndlevel check_bndLevel proc~sdr_refine_leaf->proc~check_bndlevel proc~create_children~2 create_children proc~sdr_refine_leaf->proc~create_children~2 proc~inherit_intersectedobject inHerit_intersectedObject proc~sdr_refine_leaf->proc~inherit_intersectedobject sdr_set_nodeprop_bit sdr_set_nodeprop_bit proc~sdr_refine_leaf->sdr_set_nodeprop_bit sorted sorted proc~sdr_refine_leaf->sorted tem_FirstIdAtLevel tem_FirstIdAtLevel proc~sdr_refine_leaf->tem_FirstIdAtLevel tem_horizontalSpacer tem_horizontalSpacer proc~sdr_refine_leaf->tem_horizontalSpacer tem_startTimer tem_startTimer proc~sdr_refine_leaf->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_refine_leaf->tem_stopTimer truncate truncate proc~sdr_refine_leaf->truncate val val proc~sdr_refine_leaf->val proc~check_bndlevel->val proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~check_bndlevel->proc~sdr_neighbor_in_proto sdr_nodeprop_btest sdr_nodeprop_btest proc~check_bndlevel->sdr_nodeprop_btest tem_CoordOfId tem_CoordOfId proc~check_bndlevel->tem_CoordOfId proc~create_children~2->append proc~create_children~2->sdr_set_nodeprop_bit proc~create_children~2->val sdr_clear_nodeprop_bit sdr_clear_nodeprop_bit proc~create_children~2->sdr_clear_nodeprop_bit sdr_inheritbnd_eligiblechildren sdr_inheritbnd_eligiblechildren proc~create_children~2->sdr_inheritbnd_eligiblechildren tem_directChildren tem_directChildren proc~create_children~2->tem_directChildren proc~inherit_intersectedobject->append proc~inherit_intersectedobject->val proc~is_intersecting is_intersecting proc~inherit_intersectedobject->proc~is_intersecting sdr_append_childintersectedobject sdr_append_childintersectedobject proc~inherit_intersectedobject->sdr_append_childintersectedobject proc~inherit_intersectedobject->tem_CoordOfId tem_sphereCubeOverlap tem_sphereCubeOverlap proc~inherit_intersectedobject->tem_sphereCubeOverlap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_refine_leaf~~CalledByGraph proc~sdr_refine_leaf sdr_refine_leaf program~seeder seeder program~seeder->proc~sdr_refine_leaf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_refine_leaf.html"},{"title":"sdr_smooth_leaf – Seeder","text":"public  subroutine sdr_smooth_leaf(proto, header, maxLevel) This routine smoothens fluid domain with maximum level jumps of 1. This is done by running over all leaf, flooded, non-intersected node\nat each level and check for neighbor in all 26 directions.\nIf neighbor exist in protoTree and is not a leaf then get eligible\nchildren of neighbor in the inverse direction of iDir and check \nif any of eligible children is not a leaf then refine myself. Algorithm:\nIterate over minLevel, maxLevel-2\n- Iterate over all nodes in iLevel\n  + if iNode is leaf, flooded and non intersected boundary\n    * Iterate over 26 directions\n      ++ if neighbor in iDir exist in protoTree and not a leaf\n         ** get eligible children of neighbor in inverse iDir\n           -- if any of eligible children in protoTree is not a leaf\n              +++ refine iNode Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree on which childern are created type( sdr_confHead_type ), intent(inout) :: header some global information on solver name and version integer, intent(in) :: maxLevel Maximum level in the fluid domain Calls proc~~sdr_smooth_leaf~~CallsGraph proc~sdr_smooth_leaf sdr_smooth_leaf append append proc~sdr_smooth_leaf->append destroy destroy proc~sdr_smooth_leaf->destroy init init proc~sdr_smooth_leaf->init positionofval positionofval proc~sdr_smooth_leaf->positionofval proc~create_children~2 create_children proc~sdr_smooth_leaf->proc~create_children~2 sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_smooth_leaf->sdr_nodeprop_btest sorted sorted proc~sdr_smooth_leaf->sorted tem_CoordOfId tem_CoordOfId proc~sdr_smooth_leaf->tem_CoordOfId tem_FirstIdAtLevel tem_FirstIdAtLevel proc~sdr_smooth_leaf->tem_FirstIdAtLevel tem_IdOfCoord tem_IdOfCoord proc~sdr_smooth_leaf->tem_IdOfCoord tem_eligibleChildren tem_eligibleChildren proc~sdr_smooth_leaf->tem_eligibleChildren tem_horizontalSpacer tem_horizontalSpacer proc~sdr_smooth_leaf->tem_horizontalSpacer tem_startTimer tem_startTimer proc~sdr_smooth_leaf->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_smooth_leaf->tem_stopTimer val val proc~sdr_smooth_leaf->val proc~create_children~2->append proc~create_children~2->val sdr_clear_nodeprop_bit sdr_clear_nodeprop_bit proc~create_children~2->sdr_clear_nodeprop_bit sdr_inheritbnd_eligiblechildren sdr_inheritbnd_eligiblechildren proc~create_children~2->sdr_inheritbnd_eligiblechildren sdr_set_nodeprop_bit sdr_set_nodeprop_bit proc~create_children~2->sdr_set_nodeprop_bit tem_directChildren tem_directChildren proc~create_children~2->tem_directChildren Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_smooth_leaf~~CalledByGraph proc~sdr_smooth_leaf sdr_smooth_leaf program~seeder seeder program~seeder->proc~sdr_smooth_leaf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_smooth_leaf.html"},{"title":"inHerit_intersectedObject – Seeder","text":"private  subroutine inHerit_intersectedObject(proto, geometry, parent, parentID, testAll, intersected_object, grwObjPos, parent_objPos, leVal, child_intersected_object, child_nodePos, memLeft, isDistRefObj) This routine inherit the intersected boundary objects from parent to\nchildrens Update the intersected_first and last for children Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data to refine further type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos integer, intent(in) :: parent Position of parent node in protoTree integer(kind=long_k), intent(in) :: parentID TreeID of parent logical, intent(in) :: testAll To test all intersected objects type( grw_intarray_type ), intent(inout) :: intersected_object Growing array of intersected objects. \nCould be user defined  or distance refine spatial objects type(grw_intersectObjPosArray_type), intent(inout) :: grwObjPos First and last position of intersected object of all nodes in\nintersected_object list type(sdr_intersectObjPos_type), intent(in) :: parent_objPos Position of first ans last intersected object of parent node \nin intersected_object list type( levelValues_type ), intent(in) :: leVal contains information on current level on which children are created type( grw_intarray_type ), intent(inout) :: child_intersected_object Temporary array of intersected objects for 8 children integer, intent(in) :: child_nodePos (8) 8 children node position in protoTree integer, intent(out) :: memLeft memory of parent intersected object unused by children logical, intent(in) :: isDistRefObj Is this distance refine objects Calls proc~~inherit_intersectedobject~~CallsGraph proc~inherit_intersectedobject inHerit_intersectedObject append append proc~inherit_intersectedobject->append proc~is_intersecting is_intersecting proc~inherit_intersectedobject->proc~is_intersecting sdr_append_childintersectedobject sdr_append_childintersectedobject proc~inherit_intersectedobject->sdr_append_childintersectedobject tem_CoordOfId tem_CoordOfId proc~inherit_intersectedobject->tem_CoordOfId tem_sphereCubeOverlap tem_sphereCubeOverlap proc~inherit_intersectedobject->tem_sphereCubeOverlap val val proc~inherit_intersectedobject->val proc~is_intersecting->tem_sphereCubeOverlap proc~is_intersecting->val sdr_periodicplanecubeoverlap sdr_periodicplanecubeoverlap proc~is_intersecting->sdr_periodicplanecubeoverlap sdr_spacerinterwovencubeoverlap sdr_spacerinterwovencubeoverlap proc~is_intersecting->sdr_spacerinterwovencubeoverlap tem_boxCubeOverlap tem_boxCubeOverlap proc~is_intersecting->tem_boxCubeOverlap tem_cylinderCubeOverlap tem_cylinderCubeOverlap proc~is_intersecting->tem_cylinderCubeOverlap tem_ellipsoidCubeOverlap tem_ellipsoidCubeOverlap proc~is_intersecting->tem_ellipsoidCubeOverlap tem_lineCubeOverlap tem_lineCubeOverlap proc~is_intersecting->tem_lineCubeOverlap tem_pointCubeOverlap tem_pointCubeOverlap proc~is_intersecting->tem_pointCubeOverlap tem_triangleCubeOverlap tem_triangleCubeOverlap proc~is_intersecting->tem_triangleCubeOverlap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~inherit_intersectedobject~~CalledByGraph proc~inherit_intersectedobject inHerit_intersectedObject proc~sdr_inherit_distancerefineobject sdr_inHerit_distanceRefineObject proc~sdr_inherit_distancerefineobject->proc~inherit_intersectedobject proc~sdr_refine_leaf sdr_refine_leaf proc~sdr_refine_leaf->proc~inherit_intersectedobject program~seeder seeder program~seeder->proc~sdr_inherit_distancerefineobject program~seeder->proc~sdr_refine_leaf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/inherit_intersectedobject.html"},{"title":"check_bndLevel – Seeder","text":"private  subroutine check_bndLevel(proto, parent, parent_ID_offset, leVal, maxLevel) This routine checks if neighbor node with intersected boundary is level \nhigher than current node level. If neighbor node is intersected boundary bit but no a leaf or target or\nnode with qVal than refine current node. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree on which childern are created integer, intent(in) :: parent Position of parent node on the dynamic array of node%treeID and node_data\nin preliminary tree integer(kind=long_k), intent(in) :: parent_ID_offset first treeID of the parent type( levelValues_type ), intent(in) :: leVal contains information on current level on which children are created integer, intent(inout) :: maxLevel Maximum level to refine current node Calls proc~~check_bndlevel~~CallsGraph proc~check_bndlevel check_bndLevel proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~check_bndlevel->proc~sdr_neighbor_in_proto sdr_nodeprop_btest sdr_nodeprop_btest proc~check_bndlevel->sdr_nodeprop_btest tem_CoordOfId tem_CoordOfId proc~check_bndlevel->tem_CoordOfId val val proc~check_bndlevel->val positionofval positionofval proc~sdr_neighbor_in_proto->positionofval tem_IdOfCoord tem_IdOfCoord proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_bndlevel~~CalledByGraph proc~check_bndlevel check_bndLevel proc~sdr_refine_leaf sdr_refine_leaf proc~sdr_refine_leaf->proc~check_bndlevel program~seeder seeder program~seeder->proc~sdr_refine_leaf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/check_bndlevel.html"},{"title":"create_children – Seeder","text":"private  subroutine create_children(proto, parent, child_nodePos, grwTreeID) This routine append 8 children to protoTree and inherit property bits from \nparent. leaf bit is removed from parent. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree on which childern are created integer, intent(in) :: parent Position of parent node on the dynamic array of node%treeID and node_data\nin preliminary tree integer, intent(out) :: child_nodePos (8) 8 children node position in protoTree type( grw_longarray_type ), intent(inout) :: grwTreeID Temporary growing array of TreeID contains new leaf nodes in current level Calls proc~~create_children~2~~CallsGraph proc~create_children~2 create_children append append proc~create_children~2->append sdr_clear_nodeprop_bit sdr_clear_nodeprop_bit proc~create_children~2->sdr_clear_nodeprop_bit sdr_inheritbnd_eligiblechildren sdr_inheritbnd_eligiblechildren proc~create_children~2->sdr_inheritbnd_eligiblechildren sdr_set_nodeprop_bit sdr_set_nodeprop_bit proc~create_children~2->sdr_set_nodeprop_bit tem_directChildren tem_directChildren proc~create_children~2->tem_directChildren val val proc~create_children~2->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_children~2~~CalledByGraph proc~create_children~2 create_children proc~sdr_refine_leaf sdr_refine_leaf proc~sdr_refine_leaf->proc~create_children~2 proc~sdr_smooth_leaf sdr_smooth_leaf proc~sdr_smooth_leaf->proc~create_children~2 program~seeder seeder program~seeder->proc~sdr_refine_leaf program~seeder->proc~sdr_smooth_leaf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/create_children~2.html"},{"title":"sdr_subres_fills_add – Seeder","text":"public  subroutine sdr_subres_fills_add(fills, colorname, fill_value, void_value, pos, wasAdded) Add a value definition for a color to the list of fillings. Arguments Type Intent Optional Attributes Name type( sdr_subres_fills_type ), intent(inout) :: fills Table of color values to add a color definition to. character(len=*), intent(in) :: colorname Name of the color to define values for. real(kind=rk), intent(in) :: fill_value Value to use, where the domain is flooded by color. real(kind=rk), intent(in) :: void_value Value to use, where the domain is NOT flooded by color. integer, intent(out) :: pos Position of this color in the list of color values. logical, intent(out) :: wasAdded Indicator, if this value definition was added to the list. Calls proc~~sdr_subres_fills_add~~CallsGraph proc~sdr_subres_fills_add sdr_subres_fills_add append append proc~sdr_subres_fills_add->append upper_to_lower upper_to_lower proc~sdr_subres_fills_add->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_subres_fills_add~~CalledByGraph proc~sdr_subres_fills_add sdr_subres_fills_add proc~load_single_fill load_single_fill proc~load_single_fill->proc~sdr_subres_fills_add proc~sdr_subresolution_encolor sdr_subresolution_encolor proc~sdr_subresolution_encolor->proc~sdr_subres_fills_add proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_encolor proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_load_config->proc~sdr_subresolution_load proc~sdr_subres_fills_load sdr_subres_fills_load proc~sdr_subres_fills_load->proc~load_single_fill proc~sdr_subresolution_load->proc~sdr_subres_fills_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_subres_fills_add.html"},{"title":"sdr_subres_fills_load – Seeder","text":"public  subroutine sdr_subres_fills_load(fills, conf, parent) Load the filling definition for subresolved colors. A filling is defined by a value for the area where the domain is flooded\nby the color specified in the label and a value for the remaining part\nof the domain without flooding. The filling information has to be provided as a list of tables in the\nfollowing form within the subresolution definition:\n\\code{.lua}\nvalues = {\n           { label = 'colA', fill = 1.0, void = 0.0 },\n           { label = 'colB', fill = 9.0, void = 0.1 }\n         }\n\\endcode\nDefaults are: fill=1.0, void=0.0. Arguments Type Intent Optional Attributes Name type( sdr_subres_fills_type ), intent(out) :: fills Value definitions for individual colors. type( flu_State ) :: conf Handle for the Lua script. integer, intent(in) :: parent Parent table, within which to open the fills table. Calls proc~~sdr_subres_fills_load~~CallsGraph proc~sdr_subres_fills_load sdr_subres_fills_load aot_table_length aot_table_length proc~sdr_subres_fills_load->aot_table_length aot_table_open aot_table_open proc~sdr_subres_fills_load->aot_table_open init init proc~sdr_subres_fills_load->init proc~load_single_fill load_single_fill proc~sdr_subres_fills_load->proc~load_single_fill proc~load_single_fill->aot_table_open aot_get_val aot_get_val proc~load_single_fill->aot_get_val aot_table_close aot_table_close proc~load_single_fill->aot_table_close proc~sdr_subres_fills_add sdr_subres_fills_add proc~load_single_fill->proc~sdr_subres_fills_add tem_abort tem_abort proc~load_single_fill->tem_abort append append proc~sdr_subres_fills_add->append upper_to_lower upper_to_lower proc~sdr_subres_fills_add->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_subres_fills_load~~CalledByGraph proc~sdr_subres_fills_load sdr_subres_fills_load proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~sdr_subres_fills_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_subres_fills_load.html"},{"title":"load_single_fill – Seeder","text":"public  subroutine load_single_fill(fills, conf, parent, pos) Load the value fill definition for a single color. The filling information has to be provided as a table with the label of\nthe color, the fill value to use, where the color is present and the void\nvalue for the rest of the domain:\n\\code{.lua}\n           { label = 'colA', fill = 1.0, void = 0.0 },\n\\endcode Defaults are: fill=1.0, void=0.0.\nNote that the keys can be left out, and assignment by position is possible. Arguments Type Intent Optional Attributes Name type( sdr_subres_fills_type ), intent(inout) :: fills Value definitions for individual colors. type( flu_State ) :: conf Handle for the Lua script. integer, intent(in) :: parent Parent table, within which to open the fills table. integer, intent(in) :: pos Position in the table of fills to load. Calls proc~~load_single_fill~~CallsGraph proc~load_single_fill load_single_fill aot_get_val aot_get_val proc~load_single_fill->aot_get_val aot_table_close aot_table_close proc~load_single_fill->aot_table_close aot_table_open aot_table_open proc~load_single_fill->aot_table_open proc~sdr_subres_fills_add sdr_subres_fills_add proc~load_single_fill->proc~sdr_subres_fills_add tem_abort tem_abort proc~load_single_fill->tem_abort append append proc~sdr_subres_fills_add->append upper_to_lower upper_to_lower proc~sdr_subres_fills_add->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~load_single_fill~~CalledByGraph proc~load_single_fill load_single_fill proc~sdr_subres_fills_load sdr_subres_fills_load proc~sdr_subres_fills_load->proc~load_single_fill proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~sdr_subres_fills_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/load_single_fill.html"},{"title":"ply_sampled_tracking_load – Seeder","text":"public  subroutine ply_sampled_tracking_load(me, conf) Load the configuration of sampled tracking objects. Arguments Type Intent Optional Attributes Name type( ply_sampled_tracking_type ), intent(out) :: me Sampled tracking data to load from the config type( flu_State ) :: conf Lua config to load the tracking from Calls proc~~ply_sampled_tracking_load~~CallsGraph proc~ply_sampled_tracking_load ply_sampled_tracking_load ply_sampling_load ply_sampling_load proc~ply_sampled_tracking_load->ply_sampling_load tem_load_tracking tem_load_tracking proc~ply_sampled_tracking_load->tem_load_tracking Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_sampled_tracking_load~~CalledByGraph proc~ply_sampled_tracking_load ply_sampled_tracking_load proc~sdr_hvs_config_load sdr_hvs_config_load proc~sdr_hvs_config_load->proc~ply_sampled_tracking_load program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~sdr_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampled_tracking_load.html"},{"title":"ply_sampled_track_init – Seeder","text":"public  subroutine ply_sampled_track_init(me, mesh, solver, varSys, bc, stencil, proc, nDofs, nDims) Initialize the sampled tracking entities. This is necessary to properly setup the tem_tracking data.\nIt includes building the subtree and the varmap. Arguments Type Intent Optional Attributes Name type( ply_sampled_tracking_type ), intent(inout) :: me Sampled tracking variable to initialize. It has to be configured by ply_sampled_tracking_load beforehand. type( treelmesh_type ), intent(in) :: mesh The global mesh. type( tem_solveHead_type ), intent(in) :: solver Information about the solver (used to construct file name strings). type( tem_varSys_type ), intent(in) :: varSys Global variable system with description of the data to get the\ntracking variables from. type( tem_BC_prop_type ), intent(in) :: bc Boundary condition properties, used to identify elements close to\nthe boundary. type( tem_stencilHeader_type ), intent(in), optional :: stencil Description of the stencil in the numerical scheme. This is needed to describe elements adjacent to specific boundary\nlabels. type( tem_comm_env_type ), intent(in) :: proc General communication environment integer, intent(in) :: nDofs Number of degrees of freedom to use in the output. integer, intent(in) :: nDims Number of dimensions in the polynomial representations. Calls proc~~ply_sampled_track_init~~CallsGraph proc~ply_sampled_track_init ply_sampled_track_init config config proc~ply_sampled_track_init->config hvs_output_init hvs_output_init proc~ply_sampled_track_init->hvs_output_init instance instance proc~ply_sampled_track_init->instance tem_abort tem_abort proc~ply_sampled_track_init->tem_abort tem_create_varMap tem_create_varMap proc~ply_sampled_track_init->tem_create_varMap tem_init_tracker tem_init_tracker proc~ply_sampled_track_init->tem_init_tracker tem_init_tracker_subTree tem_init_tracker_subTree proc~ply_sampled_track_init->tem_init_tracker_subTree tem_reduction_spatial_init tem_reduction_spatial_init proc~ply_sampled_track_init->tem_reduction_spatial_init val val proc~ply_sampled_track_init->val varname varname proc~ply_sampled_track_init->varname Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_sampled_track_init~~CalledByGraph proc~ply_sampled_track_init ply_sampled_track_init program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~ply_sampled_track_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampled_track_init.html"},{"title":"ply_sampled_track_output – Seeder","text":"public  subroutine ply_sampled_track_output(me, mesh, bc, solver, proc, varSys, var_degree, lvl_degree, var_space, simControl, time) Output sampled tracking data. Iterates over all tracking instances in the given me variable, checks\n whether it should be written at the current point in time (if simControl\n is provided), subsamples the data and performs the hvs_output for the\n subsampled data. Todo Instead of recreating the sampled varsys and mesh everytime the\n      tracking is written, store them in the ply_sampled_tracking_type . Get the communicator description for the subsampled mesh. Arguments Type Intent Optional Attributes Name type( ply_sampled_tracking_type ), intent(inout) :: me Sampled tracking instances. type( treelmesh_type ), intent(in) :: mesh Global mesh, required for the sampling. type( tem_BC_prop_type ), intent(in) :: bc Boundary properties, needed to inherit boundary information to refined\nmeshes and allow the extraction of boundary shape geometries. type( tem_solveHead_type ), intent(in) :: solver Information about the solver, needed for the output file name. type( tem_comm_env_type ), intent(in) :: proc General communication environment type( tem_varSys_type ), intent(in) :: varSys Original variable system integer, intent(in) :: var_degree (:) Maximal polynomial degree for each variable Needs to match the size of the variable system. integer, intent(in) :: lvl_degree (:) Maximal polynomial degree for each level integer, intent(in) :: var_space (:) Maximal polynomial space for each variable Needs to match the size of the variable system. type( tem_simControl_type ), intent(in), optional :: simControl Simulation control to determine, whether trackings should be written If not provided, all trackings will be written unconditionally. type( tem_time_type ), intent(in), optional :: time Provide a time for the current data set to write in tracking. This only is respected if no simControl is provided. If simControl\nis present the time information from it will be used instead. Calls proc~~ply_sampled_track_output~~CallsGraph proc~ply_sampled_track_output ply_sampled_track_output config config proc~ply_sampled_track_output->config free_treelmesh free_treelmesh proc~ply_sampled_track_output->free_treelmesh hvs_output_close hvs_output_close proc~ply_sampled_track_output->hvs_output_close hvs_output_init hvs_output_init proc~ply_sampled_track_output->hvs_output_init hvs_output_open hvs_output_open proc~ply_sampled_track_output->hvs_output_open hvs_output_write hvs_output_write proc~ply_sampled_track_output->hvs_output_write instance instance proc~ply_sampled_track_output->instance ply_sample_data ply_sample_data proc~ply_sampled_track_output->ply_sample_data ply_sampling_free_methoddata ply_sampling_free_methoddata proc~ply_sampled_track_output->ply_sampling_free_methoddata tem_empty_varsys tem_empty_varsys proc~ply_sampled_track_output->tem_empty_varsys tem_time_reset tem_time_reset proc~ply_sampled_track_output->tem_time_reset tem_tracker tem_tracker proc~ply_sampled_track_output->tem_tracker tem_tracking_has_triggered tem_tracking_has_triggered proc~ply_sampled_track_output->tem_tracking_has_triggered val val proc~ply_sampled_track_output->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_sampled_track_output~~CalledByGraph proc~ply_sampled_track_output ply_sampled_track_output program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~ply_sampled_track_output Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampled_track_output.html"},{"title":"ply_alpha – Seeder","text":"private  function ply_alpha(mode) result(alpha) Coefficients from the recursive formulation of legendre polynomials.\nL_n = alpha * x * L_n-1 + beta * L_n-2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The current mode in the polynomial representation. Return Value real(kind=rk) Alpha coefficient from the recursive formulation of legendre\npolynomials. Called by proc~~ply_alpha~~CalledByGraph proc~ply_alpha ply_alpha proc~ply_transform_matrix ply_transform_matrix proc~ply_transform_matrix->proc~ply_alpha proc~ply_subsampledata~2 ply_subsampleData proc~ply_subsampledata~2->proc~ply_transform_matrix proc~ply_poly_transformation ply_Poly_Transformation proc~ply_poly_transformation->proc~ply_subsampledata~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_alpha.html"},{"title":"ply_beta – Seeder","text":"private  function ply_beta(mode) result(beta) Coefficients from the recursive formulation of legendre polynomials.\nL_n = alpha * x * L_n-1 + beta * L_n-2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The current mode in the polynomial representation. Return Value real(kind=rk) Beta coefficient from the recursive formulation of legendre\npolynomials. Called by proc~~ply_beta~~CalledByGraph proc~ply_beta ply_beta proc~ply_transform_matrix ply_transform_matrix proc~ply_transform_matrix->proc~ply_beta proc~ply_subsampledata~2 ply_subsampleData proc~ply_subsampledata~2->proc~ply_transform_matrix proc~ply_poly_transformation ply_Poly_Transformation proc~ply_poly_transformation->proc~ply_subsampledata~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_beta.html"},{"title":"ply_alpha_frac – Seeder","text":"private  function ply_alpha_frac(denominator, numerator) result(alpha_frac) Quotient of two alpha values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Denominator integer, intent(in) :: numerator Numerator Return Value real(kind=rk) The quotient of two alpha values. Called by proc~~ply_alpha_frac~~CalledByGraph proc~ply_alpha_frac ply_alpha_frac proc~ply_transform_matrix ply_transform_matrix proc~ply_transform_matrix->proc~ply_alpha_frac proc~ply_subsampledata~2 ply_subsampleData proc~ply_subsampledata~2->proc~ply_transform_matrix proc~ply_poly_transformation ply_Poly_Transformation proc~ply_poly_transformation->proc~ply_subsampledata~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_alpha_frac.html"},{"title":"ply_alpha_beta – Seeder","text":"private  function ply_alpha_beta(denominator, numerator) result(alpha_beta) Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Denominator integer, intent(in) :: numerator Numerator Return Value real(kind=rk) The product of alpha(n) * beta(d) / alpha(d) Called by proc~~ply_alpha_beta~~CalledByGraph proc~ply_alpha_beta ply_alpha_beta proc~ply_transform_matrix ply_transform_matrix proc~ply_transform_matrix->proc~ply_alpha_beta proc~ply_subsampledata~2 ply_subsampleData proc~ply_subsampledata~2->proc~ply_transform_matrix proc~ply_poly_transformation ply_Poly_Transformation proc~ply_poly_transformation->proc~ply_subsampledata~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_alpha_beta.html"},{"title":"ply_Poly_Transformation – Seeder","text":"public  subroutine ply_Poly_Transformation(subsamp, dofReduction, mesh, meshData, varDofs, varComps, ndims, refine_tree, new_refine_tree, newMeshData, newVarDofs) Projection of polynomial data from parent elements to child elements.\nThe projection is done by a direct transformation of the modal\ncoeffiecients to another coordinate system with z=ax+b. Arguments Type Intent Optional Attributes Name type( ply_subsample_type ), intent(in) :: subsamp Parameters for the subsampling real(kind=rk), intent(in) :: dofReduction (:) Factor for reduction of degrees of freedom. type( treelmesh_type ), intent(in) :: mesh The mesh related to meshData. type( ply_array_type ), intent(in) :: meshData (:) The data for subsampling. integer, intent(in) :: varDofs (:) The number of degrees of freedom for every variable. integer, intent(in) :: varComps (:) The number of components for every variable. integer, intent(in) :: ndims Number of dimensions in the polynomial representation. logical, intent(in) :: refine_tree (:) Logical array that marks elements for refinement\nof the previous sampling level. logical, intent(in) :: new_refine_tree (:) Logical array that marks elements for refinement. type( ply_array_type ), intent(out), allocatable :: newMeshData (:) The subsampled data for new_refine_tree. integer, intent(out), allocatable :: newVarDofs (:) The number of dofs for the subsampled data. Calls proc~~ply_poly_transformation~~CallsGraph proc~ply_poly_transformation ply_Poly_Transformation proc~ply_subsampledata~2 ply_subsampleData proc~ply_poly_transformation->proc~ply_subsampledata~2 proc~ply_projdatatochild~2 ply_projDataToChild proc~ply_subsampledata~2->proc~ply_projdatatochild~2 proc~ply_transform_matrix ply_transform_matrix proc~ply_subsampledata~2->proc~ply_transform_matrix proc~ply_alpha ply_alpha proc~ply_transform_matrix->proc~ply_alpha proc~ply_alpha_beta ply_alpha_beta proc~ply_transform_matrix->proc~ply_alpha_beta proc~ply_alpha_frac ply_alpha_frac proc~ply_transform_matrix->proc~ply_alpha_frac proc~ply_beta ply_beta proc~ply_transform_matrix->proc~ply_beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_poly_transformation.html"},{"title":"ply_subsampleData – Seeder","text":"private  subroutine ply_subsampleData(mesh, meshData, nDofs, nChildDofs, nComponents, refine_tree, new_refine_tree, nDims, subsamp, newMeshData) Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(in) :: mesh The mesh for the data. real(kind=rk), intent(in) :: meshData (:) The data to subsample integer, intent(in) :: nDofs The number of degrees of freedom. integer, intent(in) :: nChildDofs The number of degrees of freedom for the child elements. integer, intent(in) :: nComponents Number of Components. logical, intent(in) :: refine_tree (:) Logical array that marks all elements for refinement for the previous\nsampling level. logical, intent(in) :: new_refine_tree (:) Logical array that marks all elements for refinement for the current\nsampling level. integer, intent(in) :: nDims The number of dimensions in the polynomial representation. type( ply_subsample_type ), intent(in) :: subsamp Parameters for subsampling. real(kind=rk), intent(out), allocatable :: newMeshData (:) The subsampled Data. Calls proc~~ply_subsampledata~2~~CallsGraph proc~ply_subsampledata~2 ply_subsampleData proc~ply_projdatatochild~2 ply_projDataToChild proc~ply_subsampledata~2->proc~ply_projdatatochild~2 proc~ply_transform_matrix ply_transform_matrix proc~ply_subsampledata~2->proc~ply_transform_matrix proc~ply_alpha ply_alpha proc~ply_transform_matrix->proc~ply_alpha proc~ply_alpha_beta ply_alpha_beta proc~ply_transform_matrix->proc~ply_alpha_beta proc~ply_alpha_frac ply_alpha_frac proc~ply_transform_matrix->proc~ply_alpha_frac proc~ply_beta ply_beta proc~ply_transform_matrix->proc~ply_beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_subsampledata~2~~CalledByGraph proc~ply_subsampledata~2 ply_subsampleData proc~ply_poly_transformation ply_Poly_Transformation proc~ply_poly_transformation->proc~ply_subsampledata~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_subsampledata~2.html"},{"title":"ply_projDataToChild – Seeder","text":"private  subroutine ply_projDataToChild(parentData, nParentDofs, nChildDofs, nComponents, nDimensions, nChilds, transform_matrix, childData) Subroutine to project element data from a parent cell to its children. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: parentData (:) The polynomial data for a single parent element. integer, intent(in) :: nParentDofs The number of dofs of the parent element. integer, intent(in) :: nChildDofs The total number of dofs for the child cells. integer, intent(in) :: nComponents The number of componentns for the given variable. integer, intent(in) :: nDimensions The number of dimensions. integer, intent(in) :: nChilds The number of child elements. real(kind=rk), intent(in) :: transform_matrix (:,:) The transformation matrix for the linear coordinate transformation. real(kind=rk), intent(out), allocatable :: childData (:) The new data representation for all child cell of the parent cell. Called by proc~~ply_projdatatochild~2~~CalledByGraph proc~ply_projdatatochild~2 ply_projDataToChild proc~ply_subsampledata~2 ply_subsampleData proc~ply_subsampledata~2->proc~ply_projdatatochild~2 proc~ply_poly_transformation ply_Poly_Transformation proc~ply_poly_transformation->proc~ply_subsampledata~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_projdatatochild~2.html"},{"title":"ply_transform_matrix – Seeder","text":"private  subroutine ply_transform_matrix(max_modes, v) Compute the transformation matrix for a projection to the left and right\nhalf-interval of Legendre polynomials for the given maximal number of\nmodes. Note: The transformation matrices to each subinterval are triangular, and\n      the diagonal entries are the same. To save memory both matrices are\n      stored in a single 2 dimensional array of size\n      (max_modes, max_modes). This matrix only needs to be computed once for a sufficiently high order,\nas submatices out of it can by used to perform the transformation for\nany lower polynomial degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: max_modes The maximal number of modes to compute the transformation for. The resulting matrix v will be max_modes x max_modes large and can\nbe used for the transformation of all polynomials with up to this\nmany modes. real(kind=rk), intent(out), allocatable :: v (:,:) The transformation matrix. Upper triangular matrix is created for shifting and lower triangular\nfor (-1) * shifting.\nFor the right interval we interpret the first index as row index\nand the second as column. For the left interval this is reverted and\nwe interpret the first index as columns of the matrix. Calls proc~~ply_transform_matrix~~CallsGraph proc~ply_transform_matrix ply_transform_matrix proc~ply_alpha ply_alpha proc~ply_transform_matrix->proc~ply_alpha proc~ply_alpha_beta ply_alpha_beta proc~ply_transform_matrix->proc~ply_alpha_beta proc~ply_alpha_frac ply_alpha_frac proc~ply_transform_matrix->proc~ply_alpha_frac proc~ply_beta ply_beta proc~ply_transform_matrix->proc~ply_beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_transform_matrix~~CalledByGraph proc~ply_transform_matrix ply_transform_matrix proc~ply_subsampledata~2 ply_subsampleData proc~ply_subsampledata~2->proc~ply_transform_matrix proc~ply_poly_transformation ply_Poly_Transformation proc~ply_poly_transformation->proc~ply_subsampledata~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_transform_matrix.html"},{"title":"ply_sampling_varsys_for_track – Seeder","text":"public  subroutine ply_sampling_varsys_for_track(varsys, trackInst, mesh, nDims, lvl_degree, sample_varsys, var, time) Create a variable system for the given tracking instance. Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(in) :: varsys Variable system describing the access to the original data to sample. type( tem_tracking_instance_type ), intent(in) :: trackInst The tracking object that should be sampled. type( treelmesh_type ), intent(in) :: mesh Original mesh describing the spatial organisation of the data to\nsample. integer, intent(in) :: nDims Dimensionality of the data to sample. integer, intent(in) :: lvl_degree (:) Maximal polynomial degree for each level. type( tem_varSys_type ), intent(out) :: sample_varsys Variable system for the sampled data. type( ply_sampling_var_type ), pointer :: var (:) Extracted data for all the variables requested in the given tracking\ninstance. type( tem_time_type ), intent(in) :: time Point in time to get the data for. Calls proc~~ply_sampling_varsys_for_track~~CallsGraph proc~ply_sampling_varsys_for_track ply_sampling_varsys_for_track get_element get_element proc~ply_sampling_varsys_for_track->get_element proc~ply_sampling_var_allocate ply_sampling_var_allocate proc~ply_sampling_varsys_for_track->proc~ply_sampling_var_allocate tem_LevelOf tem_LevelOf proc~ply_sampling_varsys_for_track->tem_LevelOf tem_varSys_init tem_varSys_init proc~ply_sampling_varsys_for_track->tem_varSys_init val val proc~ply_sampling_varsys_for_track->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_sampling_varsys_for_track~~CalledByGraph proc~ply_sampling_varsys_for_track ply_sampling_varsys_for_track proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_sampling_varsys_for_track Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampling_varsys_for_track.html"},{"title":"ply_sampling_var_allocate – Seeder","text":"public  subroutine ply_sampling_var_allocate(var, nElems, datalen) Allocate memory for a sampled variable. Arguments Type Intent Optional Attributes Name type( ply_sampling_var_type ), intent(inout) :: var The variable to allocate the space for. integer, intent(in) :: nElems Number of elements the data lives in. integer, intent(in) :: datalen Size of the container to use for representation of the polynomial\ndata across all elements. Called by proc~~ply_sampling_var_allocate~~CalledByGraph proc~ply_sampling_var_allocate ply_sampling_var_allocate proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_sampling_var_allocate proc~ply_sampling_varsys_for_track ply_sampling_varsys_for_track proc~ply_sample_adaptive->proc~ply_sampling_varsys_for_track proc~ply_sampling_varsys_for_track->proc~ply_sampling_var_allocate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampling_var_allocate.html"},{"title":"ply_sampling_var_move – Seeder","text":"public  subroutine ply_sampling_var_move(source, destination) Move the variable data from source to destination. If there is data in destination, it will be discarded.\nThe data in source becomes accessible via destination and source\nitself gets nullified. Arguments Type Intent Optional Attributes Name type( ply_sampling_var_type ), pointer :: source (:) Variable data to move (and make accessible via destination). Source itself will be null after moving. type( ply_sampling_var_type ), pointer :: destination (:) Pointer to refer to the data in source. If destination already\ncontains data, this data will be discarded. Called by proc~~ply_sampling_var_move~~CalledByGraph proc~ply_sampling_var_move ply_sampling_var_move proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_sampling_var_move Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampling_var_move.html"},{"title":"ply_sampling_var_compute_elemdev – Seeder","text":"public  subroutine ply_sampling_var_compute_elemdev(var, threshold, min_mean) This routine computes for each element whether the solution in it is\nconsidered to be deviating from the mean above the given threshold or\nnot. The logical result is stored in var%deviates for each element. The total number of deviating elements is stored in var%nDeviating . The variation is computed by the sum of the absolute values of all higher\nmodes divided by the first mode.\nAs we are using series of Legendre polynomials this also is a\nbounding estimation for the maximal (relative) deviation from the mean in\nthis element. A variation of 0.01 for example would imply that the state in the element\nis guaranteed to nowhere deviate from the mean by more than 1 percent.\nHowever, this is a very rough estimation and the actual maximal deviation\nfrom the mean is probably much lower (at least for sufficiently high\npolynomial degrees). If the mean is too close to 0, we use epsilon for the normalization\ninstead of the actual mean. The computation is done for the current data found in var%dat , any\nprevious computations of these flags will be discarded by this routine. Arguments Type Intent Optional Attributes Name type( ply_sampling_var_type ), intent(inout) :: var Variable data to compute the deviation for. real(kind=rk), intent(in) :: threshold Relative threshold to use as decision whether an element has a high\ndeviation or not. If the absolute value of higher modes sums to a larger value than\nthreshold times the first mode (integral mean), the element is marked\nas deviating. real(kind=rk), intent(in) :: min_mean A minimal mean value to use as comparison (to cut off changes that are\ntoo close to 0). This should be small but has to be larger than 0. Called by proc~~ply_sampling_var_compute_elemdev~~CalledByGraph proc~ply_sampling_var_compute_elemdev ply_sampling_var_compute_elemdev proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_sampling_var_compute_elemdev Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_sampling_var_compute_elemdev.html"},{"title":"ply_subresolution_load – Seeder","text":"public  subroutine ply_subresolution_load(me, tree, proc, coloring) Subroutine to load subresolution information for a given tree. Arguments Type Intent Optional Attributes Name type( ply_subresolution_type ), intent(out) :: me type( treelmesh_type ), intent(in) :: tree type( tem_comm_env_type ), intent(in) :: proc type( tem_color_prop_type ), intent(in) :: coloring Calls proc~~ply_subresolution_load~~CallsGraph proc~ply_subresolution_load ply_subresolution_load aot_get_val aot_get_val proc~ply_subresolution_load->aot_get_val close_config close_config proc~ply_subresolution_load->close_config tem_abort tem_abort proc~ply_subresolution_load->tem_abort tem_open_distconf tem_open_distconf proc~ply_subresolution_load->tem_open_distconf tem_subres_prop_load tem_subres_prop_load proc~ply_subresolution_load->tem_subres_prop_load upper_to_lower upper_to_lower proc~ply_subresolution_load->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_subresolution_load~~CalledByGraph proc~ply_subresolution_load ply_subresolution_load proc~sdr_hvs_props_load sdr_hvs_props_load proc~sdr_hvs_props_load->proc~ply_subresolution_load proc~sdr_hvs_config_load sdr_hvs_config_load proc~sdr_hvs_config_load->proc~sdr_hvs_props_load program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~sdr_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_subresolution_load.html"},{"title":"ply_subres_import_color – Seeder","text":"public  subroutine ply_subres_import_color(me, tree, coloring, iColor, target_degree, target_space, target_dim, subresdat) Get the subresolution data for all elements for a given color and in the\nrequested format. Arguments Type Intent Optional Attributes Name type( ply_subresolution_type ), intent(in) :: me type( treelmesh_type ), intent(in) :: tree type( tem_color_prop_type ), intent(in) :: coloring integer, intent(in) :: iColor integer, intent(in) :: target_degree integer, intent(in) :: target_space integer, intent(in) :: target_dim real(kind=rk), intent(out), allocatable :: subresdat (:,:) Calls proc~~ply_subres_import_color~~CallsGraph proc~ply_subres_import_color ply_subres_import_color nelems nelems proc~ply_subres_import_color->nelems newunit newunit proc~ply_subres_import_color->newunit offset offset proc~ply_subres_import_color->offset ply_transfer_dofs ply_transfer_dofs proc~ply_subres_import_color->ply_transfer_dofs ply_transfer_p_dim ply_transfer_p_dim proc~ply_subres_import_color->ply_transfer_p_dim tem_abort tem_abort proc~ply_subres_import_color->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_subres_import_color~~CalledByGraph proc~ply_subres_import_color ply_subres_import_color proc~sdr_hvs_props_import_dofs sdr_hvs_props_import_dofs proc~sdr_hvs_props_import_dofs->proc~ply_subres_import_color program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~sdr_hvs_props_import_dofs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_subres_import_color.html"},{"title":"ply_subres_get_elemcolor – Seeder","text":"public  subroutine ply_subres_get_elemcolor(fun, varSys, elempos, time, tree, nElems, nDofs, res) Get the color of an element. This routine provides the get_element for the variable definition.\n It returns the coloring value for the elements in elempos with the given\n number of degrees of freedom. The header of this subroutine must be same as tem_varSys_proc_element end dummy code to touch unused arguments \\todo HK: we could do a binary search on the colpos, to find the next\n          colored element equal or greater to the current element. Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) TreeID of the element to get the variable for. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of elements to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(nComponents of resulting variable) x (nDegrees of freedom) x (nElems)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp Calls proc~~ply_subres_get_elemcolor~~CallsGraph proc~ply_subres_get_elemcolor ply_subres_get_elemcolor color_fill color_fill proc~ply_subres_get_elemcolor->color_fill color_void color_void proc~ply_subres_get_elemcolor->color_void colored_bit colored_bit proc~ply_subres_get_elemcolor->colored_bit elemid elemid proc~ply_subres_get_elemcolor->elemid id id proc~ply_subres_get_elemcolor->id nelems nelems proc~ply_subres_get_elemcolor->nelems subresolved_colors subresolved_colors proc~ply_subres_get_elemcolor->subresolved_colors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_subres_get_elemcolor.html"},{"title":"sdr_load_transformation – Seeder","text":"public  subroutine sdr_load_transformation(transform, conf, thandle) This routine loads the transformation table for each spatial object table\nin config file If single spatial object contains multiple geometry then the transformation\nis applied to all geometries defined in that spatial object Arguments Type Intent Optional Attributes Name type( sdr_transformation_type ), intent(out) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle spatial object parent handle Calls proc~~sdr_load_transformation~~CallsGraph proc~sdr_load_transformation sdr_load_transformation aot_table_close aot_table_close proc~sdr_load_transformation->aot_table_close aot_table_open aot_table_open proc~sdr_load_transformation->aot_table_open proc~sdr_load_deformation sdr_load_deformation proc~sdr_load_transformation->proc~sdr_load_deformation proc~sdr_load_translation sdr_load_translation proc~sdr_load_transformation->proc~sdr_load_translation proc~sdr_load_deformation->aot_table_close proc~sdr_load_deformation->aot_table_open aot_get_val aot_get_val proc~sdr_load_deformation->aot_get_val tem_abort tem_abort proc~sdr_load_deformation->tem_abort proc~sdr_load_translation->aot_table_close proc~sdr_load_translation->aot_table_open proc~sdr_load_translation->aot_get_val proc~sdr_load_translation->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_transformation.html"},{"title":"sdr_load_translation – Seeder","text":"private  subroutine sdr_load_translation(translate, conf, thandle) This routine loads the translation table from transformation table Arguments Type Intent Optional Attributes Name type( sdr_translation_type ), intent(out) :: translate translate for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle spatial object parent handle Calls proc~~sdr_load_translation~~CallsGraph proc~sdr_load_translation sdr_load_translation aot_get_val aot_get_val proc~sdr_load_translation->aot_get_val aot_table_close aot_table_close proc~sdr_load_translation->aot_table_close aot_table_open aot_table_open proc~sdr_load_translation->aot_table_open tem_abort tem_abort proc~sdr_load_translation->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_translation~~CalledByGraph proc~sdr_load_translation sdr_load_translation proc~sdr_load_transformation sdr_load_transformation proc~sdr_load_transformation->proc~sdr_load_translation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_translation.html"},{"title":"sdr_load_deformation – Seeder","text":"private  subroutine sdr_load_deformation(deform, conf, thandle) This routine loads the deformation table from transformation table Arguments Type Intent Optional Attributes Name type( sdr_deformation_type ), intent(out) :: deform deform for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle spatial object parent handle Calls proc~~sdr_load_deformation~~CallsGraph proc~sdr_load_deformation sdr_load_deformation aot_get_val aot_get_val proc~sdr_load_deformation->aot_get_val aot_table_close aot_table_close proc~sdr_load_deformation->aot_table_close aot_table_open aot_table_open proc~sdr_load_deformation->aot_table_open tem_abort tem_abort proc~sdr_load_deformation->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_deformation~~CalledByGraph proc~sdr_load_deformation sdr_load_deformation proc~sdr_load_transformation sdr_load_transformation proc~sdr_load_transformation->proc~sdr_load_deformation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_deformation.html"},{"title":"transformCanoND – Seeder","text":"private  subroutine transformCanoND(canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND (:) canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object Calls proc~~transformcanond~~CallsGraph proc~transformcanond transformCanoND proc~transformcanond_single transformCanoND_single proc~transformcanond->proc~transformcanond_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~transformcanond~~CalledByGraph proc~transformcanond transformCanoND interface~sdr_transformcanond sdr_transformcanoND interface~sdr_transformcanond->proc~transformcanond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/transformcanond.html"},{"title":"transformCanoND_single – Seeder","text":"private  subroutine transformCanoND_single(canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object Called by proc~~transformcanond_single~~CalledByGraph proc~transformcanond_single transformCanoND_single interface~sdr_transformcanond sdr_transformcanoND interface~sdr_transformcanond->proc~transformcanond_single proc~transformcanond transformCanoND interface~sdr_transformcanond->proc~transformcanond proc~transformcanond->proc~transformcanond_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/transformcanond_single.html"},{"title":"sdr_transformcanoND – Seeder","text":"public interface sdr_transformcanoND This routine apply transformations to canonical objects Calls interface~~sdr_transformcanond~~CallsGraph interface~sdr_transformcanond sdr_transformcanoND proc~transformcanond transformCanoND interface~sdr_transformcanond->proc~transformcanond proc~transformcanond_single transformCanoND_single interface~sdr_transformcanond->proc~transformcanond_single proc~transformcanond->proc~transformcanond_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine transformCanoND (canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND (:) canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object private  subroutine transformCanoND_single (canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object","tags":"","url":"interface/sdr_transformcanond.html"},{"title":"sdr_flood_tree – Seeder","text":"public  subroutine sdr_flood_tree(proto, geometry, header, meshUniverse) This routine identifies the nodes, which are supposed to be part of the\ncomputational domain, as defined by the seed objects. Mark all virtual nodes, which contain a flooded child as flooded\nstarting from the second finest level moving up to the root.\nThis allows to easily avoid non-flooded domains later on. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. type( sdr_geometry_type ), intent(in) :: geometry Description of geometric objects. Propably not needed here, remove again\nif this is the case. type( sdr_confHead_type ), intent(inout) :: header some global information on solver name and version type( treelmesh_type ), intent(in) :: meshUniverse treelmesh contains bounding cube info Calls proc~~sdr_flood_tree~~CallsGraph proc~sdr_flood_tree sdr_flood_tree proc~flood_parents flood_parents proc~sdr_flood_tree->proc~flood_parents proc~flood_periphery flood_periphery proc~sdr_flood_tree->proc~flood_periphery proc~floodwaves_tree floodwaves_tree proc~sdr_flood_tree->proc~floodwaves_tree tem_log tem_log proc~sdr_flood_tree->tem_log tem_startTimer tem_startTimer proc~sdr_flood_tree->tem_startTimer tem_stopTimer tem_stopTimer proc~sdr_flood_tree->tem_stopTimer tem_toStr tem_toStr proc~sdr_flood_tree->tem_toStr val val proc~sdr_flood_tree->val proc~flood_parents->val proc~flood_periphery->tem_log proc~flood_periphery->tem_toStr proc~flood_periphery->val proc~flood_periphery_diagonal flood_periphery_diagonal proc~flood_periphery->proc~flood_periphery_diagonal proc~needcalcqvalbybcid needCalcQValByBCID proc~flood_periphery->proc~needcalcqvalbybcid proc~needflddglbybcid needFldDglByBCID proc~flood_periphery->proc~needflddglbybcid proc~sdr_qvalbynode sdr_qValByNode proc~flood_periphery->proc~sdr_qvalbynode sdr_mark_floodnode sdr_mark_floodnode proc~flood_periphery->sdr_mark_floodnode tem_BaryOfId tem_BaryOfId proc~flood_periphery->tem_BaryOfId tem_ElemSize tem_ElemSize proc~flood_periphery->tem_ElemSize proc~floodwaves_tree->tem_log proc~floodwaves_tree->tem_toStr proc~floodwaves_tree->val proc~sdr_write_proto_as_restart sdr_write_proto_as_restart proc~floodwaves_tree->proc~sdr_write_proto_as_restart proc~floodwaves_tree->sdr_mark_floodnode sdr_wetneighborsface sdr_wetneighborsface proc~floodwaves_tree->sdr_wetneighborsface tem_directChildren tem_directChildren proc~floodwaves_tree->tem_directChildren tem_eligibleChildren tem_eligibleChildren proc~floodwaves_tree->tem_eligibleChildren Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_flood_tree~~CalledByGraph proc~sdr_flood_tree sdr_flood_tree program~seeder seeder program~seeder->proc~sdr_flood_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_flood_tree.html"},{"title":"floodwaves_tree – Seeder","text":"private  subroutine floodwaves_tree(proto, header, geometry) This routine loop over all nodes are flood non-interesting leaf node with\nwet face and inherit the wetness of the virtual node to the eligble\nchildrens The algorithm works by flooding the domain, starting from the seed points\nup to boundary elements. This approach is quite robust to broken STL\ndefinitions, as any cracks below the resolution are automatically healed\nand there is no dependece on the orientation of the surfaces.\nTo avoid unintended leaking, the flooding takes only the 6 side neighbors\ninto account, that is the computational domain will always be connected\nby faces, there will be no parts of the domain which are only connected\nby edges or corners. Seeds are already marked as flooded during the previous leaf\nidentification, also the neighboring sides have already been marked as wet.\nNote, that seeds in nodes with boundaries are ignored and not flooded. Several iterations are done, referred to as waves and within each the\nfollowing algorithm is used: Iterate over all nodes.\n- If node is a leaf\n  + If not intersecting boundaries:\n    * Check if any side is wet, and if so, flood yourself.\n      If flooded, mark all neighboring sides as wet.\n  + If intersecting boundaries: nothing to do! For virtual nodes: (if not leaf) Inherit wet sides down to the direct children on this side\n    (eligible children). The procedure is finished, if no property changed during a wave.\n(Flooded status and wet faces are encoded in the PropertyBits field. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. type( sdr_confHead_type ), intent(in), optional :: header some global information on solver name and version type( sdr_geometry_type ), intent(in) :: geometry Calls proc~~floodwaves_tree~~CallsGraph proc~floodwaves_tree floodwaves_tree proc~sdr_write_proto_as_restart sdr_write_proto_as_restart proc~floodwaves_tree->proc~sdr_write_proto_as_restart sdr_mark_floodnode sdr_mark_floodnode proc~floodwaves_tree->sdr_mark_floodnode sdr_wetneighborsface sdr_wetneighborsface proc~floodwaves_tree->sdr_wetneighborsface tem_directChildren tem_directChildren proc~floodwaves_tree->tem_directChildren tem_eligibleChildren tem_eligibleChildren proc~floodwaves_tree->tem_eligibleChildren tem_log tem_log proc~floodwaves_tree->tem_log tem_toStr tem_toStr proc~floodwaves_tree->tem_toStr val val proc~floodwaves_tree->val proc~sdr_write_proto_as_restart->val dump_tem_global dump_tem_global proc~sdr_write_proto_as_restart->dump_tem_global newunit newunit proc~sdr_write_proto_as_restart->newunit proc~protodata_ofnode protoData_ofNode proc~sdr_write_proto_as_restart->proc~protodata_ofnode proc~write_childleaves write_childLeaves proc~sdr_write_proto_as_restart->proc~write_childleaves sdr_append_protovar sdr_append_protovar proc~sdr_write_proto_as_restart->sdr_append_protovar sdr_nodeprop_btest sdr_nodeprop_btest proc~sdr_write_proto_as_restart->sdr_nodeprop_btest tem_create_varMap tem_create_varMap proc~sdr_write_proto_as_restart->tem_create_varMap tem_restart_writeHeader tem_restart_writeHeader proc~sdr_write_proto_as_restart->tem_restart_writeHeader tem_solverTag tem_solverTag proc~sdr_write_proto_as_restart->tem_solverTag tem_varSys_init tem_varSys_init proc~sdr_write_proto_as_restart->tem_varSys_init proc~protodata_ofnode->val proc~protodata_ofnode->sdr_nodeprop_btest proc~write_childleaves->val proc~write_childleaves->proc~protodata_ofnode proc~write_childleaves->proc~write_childleaves proc~write_childleaves->sdr_nodeprop_btest Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~floodwaves_tree~~CalledByGraph proc~floodwaves_tree floodwaves_tree proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~floodwaves_tree program~seeder seeder program~seeder->proc~sdr_flood_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/floodwaves_tree.html"},{"title":"flood_periphery – Seeder","text":"private  subroutine flood_periphery(proto, geometry, meshUniverse) This routine loops over all intersected with geoemtry nodes and fluidify\n some node according to the following rule:\\n\n 1. one of its link does noe intersect with any geometry that requires qVal\n 2. it has fluid neighbor on that direction.\n    i.e. it is wet in that side.\n Jiaxing Qi Todo HK: works for single color only right now!\n          (qvalues are only computed for first color, need to think about\n           what to do for multiple colors.) Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. type( sdr_geometry_type ), intent(in) :: geometry Description of geometric objects. type( treelmesh_type ), intent(in) :: meshUniverse treelmesh contains bounding cube info Calls proc~~flood_periphery~~CallsGraph proc~flood_periphery flood_periphery proc~flood_periphery_diagonal flood_periphery_diagonal proc~flood_periphery->proc~flood_periphery_diagonal proc~needcalcqvalbybcid needCalcQValByBCID proc~flood_periphery->proc~needcalcqvalbybcid proc~needflddglbybcid needFldDglByBCID proc~flood_periphery->proc~needflddglbybcid proc~sdr_qvalbynode sdr_qValByNode proc~flood_periphery->proc~sdr_qvalbynode sdr_mark_floodnode sdr_mark_floodnode proc~flood_periphery->sdr_mark_floodnode tem_BaryOfId tem_BaryOfId proc~flood_periphery->tem_BaryOfId tem_ElemSize tem_ElemSize proc~flood_periphery->tem_ElemSize tem_log tem_log proc~flood_periphery->tem_log tem_toStr tem_toStr proc~flood_periphery->tem_toStr val val proc~flood_periphery->val proc~flood_periphery_diagonal->sdr_mark_floodnode proc~flood_periphery_diagonal->val proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~flood_periphery_diagonal->proc~sdr_neighbor_in_proto tem_CoordOfId tem_CoordOfId proc~flood_periphery_diagonal->tem_CoordOfId proc~needcalcqvalbybcid->val kindpos kindpos proc~needcalcqvalbybcid->kindpos proc~needflddglbybcid->val proc~needflddglbybcid->kindpos proc~sdr_qvalbynode->val fraction_PointLine fraction_PointLine proc~sdr_qvalbynode->fraction_PointLine intersect_RayTriangle intersect_RayTriangle proc~sdr_qvalbynode->intersect_RayTriangle positionofval positionofval proc~sdr_neighbor_in_proto->positionofval tem_IdOfCoord tem_IdOfCoord proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flood_periphery~~CalledByGraph proc~flood_periphery flood_periphery proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~flood_periphery program~seeder seeder program~seeder->proc~sdr_flood_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/flood_periphery.html"},{"title":"flood_periphery_diagonal – Seeder","text":"private  subroutine flood_periphery_diagonal(proto, node_pos, treeID, qVal, iColor) This routine checks for qVal of the periphery and floods if qVal < 0 and\nthe node in that direction is fluid and not intersected by boundary Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. integer, intent(in) :: node_pos node position in protoTree integer(kind=long_k), intent(in) :: treeID treeID of current node real(kind=rk) :: qVal (:) qVal for all 26 neighbor directions, should be calculated already integer, intent(in) :: iColor Color to do the flooding in Calls proc~~flood_periphery_diagonal~~CallsGraph proc~flood_periphery_diagonal flood_periphery_diagonal proc~sdr_neighbor_in_proto sdr_neighbor_in_proto proc~flood_periphery_diagonal->proc~sdr_neighbor_in_proto sdr_mark_floodnode sdr_mark_floodnode proc~flood_periphery_diagonal->sdr_mark_floodnode tem_CoordOfId tem_CoordOfId proc~flood_periphery_diagonal->tem_CoordOfId val val proc~flood_periphery_diagonal->val positionofval positionofval proc~sdr_neighbor_in_proto->positionofval tem_IdOfCoord tem_IdOfCoord proc~sdr_neighbor_in_proto->tem_IdOfCoord tem_ParentOf tem_ParentOf proc~sdr_neighbor_in_proto->tem_ParentOf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flood_periphery_diagonal~~CalledByGraph proc~flood_periphery_diagonal flood_periphery_diagonal proc~flood_periphery flood_periphery proc~flood_periphery->proc~flood_periphery_diagonal proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~flood_periphery program~seeder seeder program~seeder->proc~sdr_flood_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/flood_periphery_diagonal.html"},{"title":"flood_parents – Seeder","text":"private  subroutine flood_parents(proto, color_inverted) Mark all virtual nodes, which contain a flooded child as flooded\nstarting from the second finest level moving up to the root.\nThis allows to easily avoid non-flooded domains later on. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. logical, intent(in) :: color_inverted (:) List of flags for each color to indicate, wether the color should be\ninverted after flooding. Calls proc~~flood_parents~~CallsGraph proc~flood_parents flood_parents val val proc~flood_parents->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flood_parents~~CalledByGraph proc~flood_parents flood_parents proc~sdr_flood_tree sdr_flood_tree proc~sdr_flood_tree->proc~flood_parents program~seeder seeder program~seeder->proc~sdr_flood_tree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/flood_parents.html"},{"title":"sdr_load_cylinder – Seeder","text":"public  subroutine sdr_load_cylinder(cylArray, spaObjArray, attr_pos, transform, conf, thandle) \\brief Loading cylinder information from config file \\n Arguments Type Intent Optional Attributes Name type( grw_cylinderarray_type ), intent(inout) :: cylArray growing array of cylinders type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle Calls proc~~sdr_load_cylinder~~CallsGraph proc~sdr_load_cylinder sdr_load_cylinder proc~append_cylinder2spaobj append_cylinder2SpaObj proc~sdr_load_cylinder->proc~append_cylinder2spaobj tem_load_cylinder tem_load_cylinder proc~sdr_load_cylinder->tem_load_cylinder append append proc~append_cylinder2spaobj->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_cylinder~~CalledByGraph proc~sdr_load_cylinder sdr_load_cylinder proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_cylinder proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_cylinder.html"},{"title":"append_cylinder2SpaObj – Seeder","text":"public  subroutine append_cylinder2SpaObj(cylArray, spaObjArray, attr_pos, loc_cylinder) This routine single cylinder from object table Arguments Type Intent Optional Attributes Name type( grw_cylinderarray_type ), intent(inout) :: cylArray growing array of cylinders type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_cylinder_type ), intent(in) :: loc_cylinder Calls proc~~append_cylinder2spaobj~~CallsGraph proc~append_cylinder2spaobj append_cylinder2SpaObj append append proc~append_cylinder2spaobj->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~append_cylinder2spaobj~~CalledByGraph proc~append_cylinder2spaobj append_cylinder2SpaObj proc~sdr_load_cylinder sdr_load_cylinder proc~sdr_load_cylinder->proc~append_cylinder2spaobj proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_cylinder proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/append_cylinder2spaobj.html"},{"title":"ply_lagrange_define – Seeder","text":"public  function ply_lagrange_define(nPoints, nodeset, values) result(me) Define a new polynomial in the Lagrange basis. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints Number of points to define the polynomial. procedure( ply_nodeset_coords ) :: nodeset The set of nodes where the function assumes the given values. real(kind=rk), intent(in) :: values (nPoints) Function values at all nPoints of the nodeset. Return Value type( ply_lagrange_type ) The newly created Lagrange series describing the polynomial function. Called by proc~~ply_lagrange_define~~CalledByGraph proc~ply_lagrange_define ply_lagrange_define proc~ply_init_l2p ply_init_l2p proc~ply_init_l2p->proc~ply_lagrange_define Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_lagrange_define.html"},{"title":"ply_lagrange_eval – Seeder","text":"public  function ply_lagrange_eval(me, x) result(f) Evaluate a polynomial in the Lagrange basis at some point x. Arguments Type Intent Optional Attributes Name type( ply_lagrange_type ), intent(in) :: me The polynomial in Lagrange basis to evaluate at point x. real(kind=rk), intent(in) :: x Coordinate at which the function is to be evaluated. Return Value real(kind=rk) Value of the polynomial at coordinate x. Calls proc~~ply_lagrange_eval~~CallsGraph proc~ply_lagrange_eval ply_lagrange_eval proc~ply_lagrange_mode_at ply_lagrange_mode_at proc~ply_lagrange_eval->proc~ply_lagrange_mode_at Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_lagrange_eval.html"},{"title":"ply_lagrange_mode_at – Seeder","text":"public  function ply_lagrange_mode_at(me, mode, x) result(f) Evaluate the given Lagrangian mode (which is 1 at coord(mode) and 0 in\nall other points) at a given point x. Arguments Type Intent Optional Attributes Name type( ply_lagrange_type ), intent(in) :: me The polynomial in Lagrange basis. integer, intent(in) :: mode Mode to evaluate at x. Here mode identifies the polynomial that is 1 in me%coord(mode) and\n0 in all other nodes. real(kind=rk), intent(in) :: x Coordinate at which the mode is to be evaluated. Return Value real(kind=rk) Value of the polynomial at coordinate x. Called by proc~~ply_lagrange_mode_at~~CalledByGraph proc~ply_lagrange_mode_at ply_lagrange_mode_at proc~ply_lagrange_1d ply_lagrange_1D proc~ply_lagrange_1d->proc~ply_lagrange_mode_at proc~ply_lagrange_eval ply_lagrange_eval proc~ply_lagrange_eval->proc~ply_lagrange_mode_at proc~ply_init_l2p ply_init_l2p proc~ply_init_l2p->proc~ply_lagrange_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_lagrange_mode_at.html"},{"title":"ply_lagrange_1D – Seeder","text":"public  function ply_lagrange_1D(me, points) result(pointval) Arguments Type Intent Optional Attributes Name type( ply_lagrange_type ), intent(in) :: me Definition of the Lagrange polynomial basis to evaluate at points. real(kind=rk), intent(in) :: points (:) List of points at which the polynomials are to be evaluated. Return Value real(kind=rk), (me%nPoints,size(points)) Resulting Lagrange values at all points. First dimension holds the Lagrange modes, second dimension the\npoints. Calls proc~~ply_lagrange_1d~~CallsGraph proc~ply_lagrange_1d ply_lagrange_1D proc~ply_lagrange_mode_at ply_lagrange_mode_at proc~ply_lagrange_1d->proc~ply_lagrange_mode_at Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_lagrange_1d~~CalledByGraph proc~ply_lagrange_1d ply_lagrange_1D proc~ply_init_l2p ply_init_l2p proc~ply_init_l2p->proc~ply_lagrange_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_lagrange_1d.html"},{"title":"is_intersecting – Seeder","text":"public  function is_intersecting(cube, geometry, obj_pos) result(intersects) Test the intersection between the given cube and the object specified by\nobj_pos. This test obviously depends on the kind of object to intersect, thus a\nselect case has to be used. Alternatively we might think of deploying\nfunction pointers. Arguments Type Intent Optional Attributes Name type( tem_cube_type ), intent(in) :: cube type( sdr_geometry_type ), intent(in) :: geometry integer, intent(in) :: obj_pos Return Value logical Calls proc~~is_intersecting~~CallsGraph proc~is_intersecting is_intersecting sdr_periodicplanecubeoverlap sdr_periodicplanecubeoverlap proc~is_intersecting->sdr_periodicplanecubeoverlap sdr_spacerinterwovencubeoverlap sdr_spacerinterwovencubeoverlap proc~is_intersecting->sdr_spacerinterwovencubeoverlap tem_boxCubeOverlap tem_boxCubeOverlap proc~is_intersecting->tem_boxCubeOverlap tem_cylinderCubeOverlap tem_cylinderCubeOverlap proc~is_intersecting->tem_cylinderCubeOverlap tem_ellipsoidCubeOverlap tem_ellipsoidCubeOverlap proc~is_intersecting->tem_ellipsoidCubeOverlap tem_lineCubeOverlap tem_lineCubeOverlap proc~is_intersecting->tem_lineCubeOverlap tem_pointCubeOverlap tem_pointCubeOverlap proc~is_intersecting->tem_pointCubeOverlap tem_sphereCubeOverlap tem_sphereCubeOverlap proc~is_intersecting->tem_sphereCubeOverlap tem_triangleCubeOverlap tem_triangleCubeOverlap proc~is_intersecting->tem_triangleCubeOverlap val val proc~is_intersecting->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_intersecting~~CalledByGraph proc~is_intersecting is_intersecting proc~create_children create_children proc~create_children->proc~is_intersecting proc~inherit_intersectedobject inHerit_intersectedObject proc~inherit_intersectedobject->proc~is_intersecting proc~sdr_build_prototree sdr_build_protoTree proc~sdr_build_prototree->proc~create_children proc~sdr_inherit_distancerefineobject sdr_inHerit_distanceRefineObject proc~sdr_inherit_distancerefineobject->proc~inherit_intersectedobject proc~sdr_refine_leaf sdr_refine_leaf proc~sdr_refine_leaf->proc~inherit_intersectedobject program~seeder seeder program~seeder->proc~sdr_build_prototree program~seeder->proc~sdr_inherit_distancerefineobject program~seeder->proc~sdr_refine_leaf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/is_intersecting.html"},{"title":"sdr_load_geometry – Seeder","text":"public  subroutine sdr_load_geometry(me, subres_colors, invert_colors, conf) Routine to load spatial object defined in config file and store in \ngeometry type Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(out) :: me contains all geometry infomation type( dyn_labelarray_type ), intent(in) :: subres_colors All the colors, which should be default use subelement resolution for\ntheir boundaries. type( dyn_labelarray_type ), intent(in) :: invert_colors type( flu_State ) :: conf Calls proc~~sdr_load_geometry~~CallsGraph proc~sdr_load_geometry sdr_load_geometry aot_get_val aot_get_val proc~sdr_load_geometry->aot_get_val aot_table_close aot_table_close proc~sdr_load_geometry->aot_table_close aot_table_length aot_table_length proc~sdr_load_geometry->aot_table_length aot_table_open aot_table_open proc~sdr_load_geometry->aot_table_open color_inverted color_inverted proc~sdr_load_geometry->color_inverted init init proc~sdr_load_geometry->init kindpos kindpos proc~sdr_load_geometry->kindpos proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_geometry->proc~sdr_load_spatialobject_single sdr_identify_bc_colors sdr_identify_bc_colors proc~sdr_load_geometry->sdr_identify_bc_colors sdr_identify_inv_colors sdr_identify_inv_colors proc~sdr_load_geometry->sdr_identify_inv_colors sdr_init_attribute sdr_init_attribute proc~sdr_load_geometry->sdr_init_attribute tem_load_cube tem_load_cube proc~sdr_load_geometry->tem_load_cube truncate truncate proc~sdr_load_geometry->truncate uni_name uni_name proc~sdr_load_geometry->uni_name val val proc~sdr_load_geometry->val proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table sdr_load_attribute sdr_load_attribute proc~sdr_load_spatialobject_single->sdr_load_attribute tem_horizontalSpacer tem_horizontalSpacer proc~sdr_load_spatialobject_single->tem_horizontalSpacer tem_load_transformation tem_load_transformation proc~sdr_load_spatialobject_single->tem_load_transformation proc~sdr_load_geom_table->aot_table_close proc~sdr_load_geom_table->aot_table_length proc~sdr_load_geom_table->aot_table_open proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table->proc~sdr_load_geom_table_single tem_abort tem_abort proc~sdr_load_geom_table->tem_abort proc~sdr_load_geom_table_single->aot_get_val proc~sdr_load_geom_table_single->tem_abort proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_cylinder sdr_load_cylinder proc~sdr_load_geom_table_single->proc~sdr_load_cylinder proc~sdr_load_ellipsoid sdr_load_ellipsoid proc~sdr_load_geom_table_single->proc~sdr_load_ellipsoid proc~sdr_load_sphere sdr_load_sphere proc~sdr_load_geom_table_single->proc~sdr_load_sphere proc~sdr_load_stl sdr_load_stl proc~sdr_load_geom_table_single->proc~sdr_load_stl proc~sdr_load_triangle sdr_load_triangle proc~sdr_load_geom_table_single->proc~sdr_load_triangle sdr_load_periodic sdr_load_periodic proc~sdr_load_geom_table_single->sdr_load_periodic sdr_load_spacer sdr_load_spacer proc~sdr_load_geom_table_single->sdr_load_spacer upper_to_lower upper_to_lower proc~sdr_load_geom_table_single->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_geometry~~CalledByGraph proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_load_geometry program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_geometry.html"},{"title":"sdr_load_spatialObject_single – Seeder","text":"public  subroutine sdr_load_spatialObject_single(me, subres_colors, conf, thandle) Routine to load single spatial object table defined in config file Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(inout) :: me contains all geometry infomation type( dyn_labelarray_type ), intent(in) :: subres_colors All the colors, which should be default use subelement resolution for\ntheir boundaries. type( flu_State ) :: conf integer, intent(in) :: thandle Calls proc~~sdr_load_spatialobject_single~~CallsGraph proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table sdr_load_attribute sdr_load_attribute proc~sdr_load_spatialobject_single->sdr_load_attribute tem_horizontalSpacer tem_horizontalSpacer proc~sdr_load_spatialobject_single->tem_horizontalSpacer tem_load_transformation tem_load_transformation proc~sdr_load_spatialobject_single->tem_load_transformation aot_table_close aot_table_close proc~sdr_load_geom_table->aot_table_close aot_table_length aot_table_length proc~sdr_load_geom_table->aot_table_length aot_table_open aot_table_open proc~sdr_load_geom_table->aot_table_open proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table->proc~sdr_load_geom_table_single tem_abort tem_abort proc~sdr_load_geom_table->tem_abort proc~sdr_load_geom_table_single->tem_abort aot_get_val aot_get_val proc~sdr_load_geom_table_single->aot_get_val proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_cylinder sdr_load_cylinder proc~sdr_load_geom_table_single->proc~sdr_load_cylinder proc~sdr_load_ellipsoid sdr_load_ellipsoid proc~sdr_load_geom_table_single->proc~sdr_load_ellipsoid proc~sdr_load_sphere sdr_load_sphere proc~sdr_load_geom_table_single->proc~sdr_load_sphere proc~sdr_load_stl sdr_load_stl proc~sdr_load_geom_table_single->proc~sdr_load_stl proc~sdr_load_triangle sdr_load_triangle proc~sdr_load_geom_table_single->proc~sdr_load_triangle sdr_load_periodic sdr_load_periodic proc~sdr_load_geom_table_single->sdr_load_periodic sdr_load_spacer sdr_load_spacer proc~sdr_load_geom_table_single->sdr_load_spacer upper_to_lower upper_to_lower proc~sdr_load_geom_table_single->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_spatialobject_single~~CalledByGraph proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_load_geometry program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_spatialobject_single.html"},{"title":"sdr_load_geom_table – Seeder","text":"public  subroutine sdr_load_geom_table(me, conf, thandle, attr_pos, transform) This routine loads the geometry table from the config file i.e loading\ndifferent geometry kinds like canoND, cube, periodic, STL etc. Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(inout) :: me type( flu_State ) :: conf integer, intent(in) :: thandle integer, intent(in) :: attr_pos Position of the attribute to connect the geometric objects to. type( tem_transformation_type ), intent(in) :: transform Calls proc~~sdr_load_geom_table~~CallsGraph proc~sdr_load_geom_table sdr_load_geom_table aot_table_close aot_table_close proc~sdr_load_geom_table->aot_table_close aot_table_length aot_table_length proc~sdr_load_geom_table->aot_table_length aot_table_open aot_table_open proc~sdr_load_geom_table->aot_table_open proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table->proc~sdr_load_geom_table_single tem_abort tem_abort proc~sdr_load_geom_table->tem_abort proc~sdr_load_geom_table_single->tem_abort aot_get_val aot_get_val proc~sdr_load_geom_table_single->aot_get_val proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_cylinder sdr_load_cylinder proc~sdr_load_geom_table_single->proc~sdr_load_cylinder proc~sdr_load_ellipsoid sdr_load_ellipsoid proc~sdr_load_geom_table_single->proc~sdr_load_ellipsoid proc~sdr_load_sphere sdr_load_sphere proc~sdr_load_geom_table_single->proc~sdr_load_sphere proc~sdr_load_stl sdr_load_stl proc~sdr_load_geom_table_single->proc~sdr_load_stl proc~sdr_load_triangle sdr_load_triangle proc~sdr_load_geom_table_single->proc~sdr_load_triangle sdr_load_periodic sdr_load_periodic proc~sdr_load_geom_table_single->sdr_load_periodic sdr_load_spacer sdr_load_spacer proc~sdr_load_geom_table_single->sdr_load_spacer upper_to_lower upper_to_lower proc~sdr_load_geom_table_single->upper_to_lower proc~sdr_load_canonicalnd->upper_to_lower proc~append_canondboxtosdrbox append_CanoNDBoxToSdrBox proc~sdr_load_canonicalnd->proc~append_canondboxtosdrbox proc~append_canondboxtotriangle append_CanoNDBoxToTriangle proc~sdr_load_canonicalnd->proc~append_canondboxtotriangle proc~append_canondlinetosdrline append_CanoNDLineToSdrLine proc~sdr_load_canonicalnd->proc~append_canondlinetosdrline proc~append_canondplanetotriangle append_CanoNDPlaneToTriangle proc~sdr_load_canonicalnd->proc~append_canondplanetotriangle proc~append_canondpointtosdrpoint append_CanoNDPointToSdrPoint proc~sdr_load_canonicalnd->proc~append_canondpointtosdrpoint tem_load_canonicalND tem_load_canonicalND proc~sdr_load_canonicalnd->tem_load_canonicalND proc~append_cylinder2spaobj append_cylinder2SpaObj proc~sdr_load_cylinder->proc~append_cylinder2spaobj tem_load_cylinder tem_load_cylinder proc~sdr_load_cylinder->tem_load_cylinder append append proc~sdr_load_ellipsoid->append tem_load_ellipsoid tem_load_ellipsoid proc~sdr_load_ellipsoid->tem_load_ellipsoid proc~sdr_load_sphere->append tem_load_sphere tem_load_sphere proc~sdr_load_sphere->tem_load_sphere proc~sdr_load_stl->append tem_load_stl tem_load_stl proc~sdr_load_stl->tem_load_stl proc~sdr_load_triangle->append tem_load_triangle tem_load_triangle proc~sdr_load_triangle->tem_load_triangle proc~append_canondboxtosdrbox->append proc~append_canondboxtotriangle->proc~append_canondplanetotriangle proc~append_canondlinetosdrline->append proc~append_canondplanetotriangle->append proc~append_canondpointtosdrpoint->append proc~append_cylinder2spaobj->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_geom_table~~CalledByGraph proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_load_geometry program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_geom_table.html"},{"title":"sdr_load_geom_table_single – Seeder","text":"public  subroutine sdr_load_geom_table_single(me, conf, thandle, attr_pos, transform) This routine reads a single geometry table from the config file i.e \nloading different geometry kinds like canoND, cube, periodic, STL etc. Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(inout) :: me type( flu_State ) :: conf integer, intent(in) :: thandle integer, intent(in) :: attr_pos Position of the attribute to connect all primitives to. type( tem_transformation_type ), intent(in) :: transform Calls proc~~sdr_load_geom_table_single~~CallsGraph proc~sdr_load_geom_table_single sdr_load_geom_table_single aot_get_val aot_get_val proc~sdr_load_geom_table_single->aot_get_val proc~sdr_load_canonicalnd sdr_load_canonicalND proc~sdr_load_geom_table_single->proc~sdr_load_canonicalnd proc~sdr_load_cylinder sdr_load_cylinder proc~sdr_load_geom_table_single->proc~sdr_load_cylinder proc~sdr_load_ellipsoid sdr_load_ellipsoid proc~sdr_load_geom_table_single->proc~sdr_load_ellipsoid proc~sdr_load_sphere sdr_load_sphere proc~sdr_load_geom_table_single->proc~sdr_load_sphere proc~sdr_load_stl sdr_load_stl proc~sdr_load_geom_table_single->proc~sdr_load_stl proc~sdr_load_triangle sdr_load_triangle proc~sdr_load_geom_table_single->proc~sdr_load_triangle sdr_load_periodic sdr_load_periodic proc~sdr_load_geom_table_single->sdr_load_periodic sdr_load_spacer sdr_load_spacer proc~sdr_load_geom_table_single->sdr_load_spacer tem_abort tem_abort proc~sdr_load_geom_table_single->tem_abort upper_to_lower upper_to_lower proc~sdr_load_geom_table_single->upper_to_lower proc~sdr_load_canonicalnd->upper_to_lower proc~append_canondboxtosdrbox append_CanoNDBoxToSdrBox proc~sdr_load_canonicalnd->proc~append_canondboxtosdrbox proc~append_canondboxtotriangle append_CanoNDBoxToTriangle proc~sdr_load_canonicalnd->proc~append_canondboxtotriangle proc~append_canondlinetosdrline append_CanoNDLineToSdrLine proc~sdr_load_canonicalnd->proc~append_canondlinetosdrline proc~append_canondplanetotriangle append_CanoNDPlaneToTriangle proc~sdr_load_canonicalnd->proc~append_canondplanetotriangle proc~append_canondpointtosdrpoint append_CanoNDPointToSdrPoint proc~sdr_load_canonicalnd->proc~append_canondpointtosdrpoint tem_load_canonicalND tem_load_canonicalND proc~sdr_load_canonicalnd->tem_load_canonicalND proc~append_cylinder2spaobj append_cylinder2SpaObj proc~sdr_load_cylinder->proc~append_cylinder2spaobj tem_load_cylinder tem_load_cylinder proc~sdr_load_cylinder->tem_load_cylinder append append proc~sdr_load_ellipsoid->append tem_load_ellipsoid tem_load_ellipsoid proc~sdr_load_ellipsoid->tem_load_ellipsoid proc~sdr_load_sphere->append tem_load_sphere tem_load_sphere proc~sdr_load_sphere->tem_load_sphere proc~sdr_load_stl->append tem_load_stl tem_load_stl proc~sdr_load_stl->tem_load_stl proc~sdr_load_triangle->append tem_load_triangle tem_load_triangle proc~sdr_load_triangle->tem_load_triangle proc~append_canondboxtosdrbox->append proc~append_canondboxtotriangle->proc~append_canondplanetotriangle proc~append_canondlinetosdrline->append proc~append_canondplanetotriangle->append proc~append_canondpointtosdrpoint->append proc~append_cylinder2spaobj->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_geom_table_single~~CalledByGraph proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_load_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_geom_table_single.html"},{"title":"sdr_append_distanceRefineObject – Seeder","text":"public  subroutine sdr_append_distanceRefineObject(coord, dx, iLevel, geometry, intersected_first, intersected_last, intersected_object) This routine created sphere objects and new attribute and extend \na list of spatial objects if node intersected boundary has distance \nrefine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: coord (4) Coordinate of current node real(kind=rk), intent(in) :: dx integer, intent(in) :: iLevel Current node level type( sdr_geometry_type ), intent(inout) :: geometry type which contains all geometry object infos integer, intent(in) :: intersected_first This node's first position in intersected_object integer, intent(in) :: intersected_last This node's last position in intersected_object type( grw_intarray_type ), intent(in) :: intersected_object Growing array of intersected_objects Calls proc~~sdr_append_distancerefineobject~~CallsGraph proc~sdr_append_distancerefineobject sdr_append_distanceRefineObject append append proc~sdr_append_distancerefineobject->append kindpos kindpos proc~sdr_append_distancerefineobject->kindpos uni_name uni_name proc~sdr_append_distancerefineobject->uni_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_append_distancerefineobject~~CalledByGraph proc~sdr_append_distancerefineobject sdr_append_distanceRefineObject proc~sdr_build_prototree sdr_build_protoTree proc~sdr_build_prototree->proc~sdr_append_distancerefineobject program~seeder seeder program~seeder->proc~sdr_build_prototree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_append_distancerefineobject.html"},{"title":"ply_nodeset_legendre – Seeder","text":"public  function ply_nodeset_legendre(nPoints) result(x) Compute Gauss-Legendre integration points on the interval [-1,1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of integration points. Return Value real(kind=rk), (nPoints) The coordinates of the Legendre points on the interval [-1,1].\nThe array has to have the length nPoints.","tags":"","url":"proc/ply_nodeset_legendre.html"},{"title":"ply_nodeset_chebyshev – Seeder","text":"public  function ply_nodeset_chebyshev(nPoints) result(x) Generates a given number of Chebyshev points on the unit interval [-1;+1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of points to generate Return Value real(kind=rk), (nPoints) The coordinates of the Chebyshev points on the interval [-1,1].\nThe array has to have the length nPoints.","tags":"","url":"proc/ply_nodeset_chebyshev.html"},{"title":"ply_nodeset_chebyloba – Seeder","text":"public  function ply_nodeset_chebyloba(nPoints) result(x) Generates a given number of Chebyshev-Lobatto points on the unit interval\n[-1;+1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of points to generate Return Value real(kind=rk), (nPoints) The coordinates of the Chebyshev-Lobatto points on the interval [-1,1].\nThe array has to have the length nPoints.","tags":"","url":"proc/ply_nodeset_chebyloba.html"},{"title":"ply_nodeset_coords – Seeder","text":"interface public  function ply_nodeset_coords(nPoints) result(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of points to create. Return Value real(kind=rk)(nPoints) The coordinates of the nodeset in the interval [-1,1].\nThe array has to have the length nPoints.","tags":"","url":"interface/ply_nodeset_coords.html"},{"title":"sdr_load_triangle – Seeder","text":"public  subroutine sdr_load_triangle(triArray, spaObjArray, attr_pos, transform, conf, thandle) Load triangle information from config file. Arguments Type Intent Optional Attributes Name type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle Calls proc~~sdr_load_triangle~~CallsGraph proc~sdr_load_triangle sdr_load_triangle append append proc~sdr_load_triangle->append tem_load_triangle tem_load_triangle proc~sdr_load_triangle->tem_load_triangle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_load_triangle~~CalledByGraph proc~sdr_load_triangle sdr_load_triangle proc~sdr_load_geom_table_single sdr_load_geom_table_single proc~sdr_load_geom_table_single->proc~sdr_load_triangle proc~sdr_load_geom_table sdr_load_geom_table proc~sdr_load_geom_table->proc~sdr_load_geom_table_single proc~sdr_load_spatialobject_single sdr_load_spatialObject_single proc~sdr_load_spatialobject_single->proc~sdr_load_geom_table proc~sdr_load_geometry sdr_load_geometry proc~sdr_load_geometry->proc~sdr_load_spatialobject_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_load_triangle.html"},{"title":"ply_split_element_init – Seeder","text":"public  subroutine ply_split_element_init(nMaxModes) Initialization of the module.\nThis needs to be performed before any call of the actual transformation ply_split_element_1D . The initialization will compute the transformation matrix for Legendre\npolynomials with at least nMaxModes. If the initialization was already\ncalled before with the same or larger nMaxModes, the matrix will not be\nchanged. Thus, calling this routine will only increase the size of the\nmodule variable split_legendre, never decrease it. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nMaxModes Maximal number of expected modes to perform the splitting for. Calls proc~~ply_split_element_init~~CallsGraph proc~ply_split_element_init ply_split_element_init proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~alpha alpha proc~ply_split_legendre_matrix->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix->proc~alpha_frac proc~beta beta proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_split_element_init~~CalledByGraph proc~ply_split_element_init ply_split_element_init proc~ply_sample_adaptive ply_sample_adaptive proc~ply_sample_adaptive->proc~ply_split_element_init proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_1d_test->proc~ply_split_element_init proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_init proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_init.html"},{"title":"ply_split_element_singleD – Seeder","text":"public  subroutine ply_split_element_singleD(nDims, inLen, outLen, parent_data, child_data, ignore) Project a polynomial representation in elements in one dimension to its\n two halves in that direction. For each parent element the projection on the two respective child elements\n (half intervals) are computed for one dimension. Note Preliminary data layout and interface planning.\n It might be that we should rather split the index into the direction\n in which we perform the operation and all the other directions normal\n to that. For a dense matrix this may allow the compiler to detect\n the matrix multiply. However, here for the triangular matrix it is not\n so sure, whether this would be possible. Note After discussions with Stephan Walter, it looks like the separate\n indices would most likely be better.\n Maybe, using explicit shaped arrays and therby allowing more dimensions\n in the input, while keeping the interface to two dimensions for all\n cases (the normal direction and all independent degrees of freedom).\n For vectorization on x86 it also is necessary to have a stride-1 access\n only in reading and writing.\n The rotation of data might not be the best option because of this.\n Instead, it may be that we need to have different routines for each\n direction.\n Or, maybe, we need to use the elements as first index and vectorize\n over those. As we need to perform this operation in all dimensions, it would be good\n to shift the indices around. When doing this, we can stick to the same\n implementation for all directions, without the need to put any logic in\n here to decide on the current direction.\n In 3D we would end up with this chain:\n (x,y,z) -> split_element for Z -> (z,x,y)\n         -> split_element for Y -> (y,z,x)\n         -> split_element for X -> (x,y,z)\n Thus, the logic is that we perform the split on the last dimension, and\n cycle the indices in the output. We can generalize this to arbitrary dimensions.\n In 2D it would look like this:\n (x,y) -> split_element for Y -> (y,x)\n       -> split_element for X -> (x,y)\n And in 1D, we just need to perform one transformation:\n (x) -> split_element for X -> (x) As we allow for a changed number of polynomial degrees in the input and\n output, we need to take care of different lengths for each direction.\n Thus, we need: the dimensionality, two 1D arrays with the length of this\n dimensionality to provide the number of degrees of freedom for each\n direction (once for the input, and once for the output). We need: nDofs in the direction where the transformation is to be done\n          and the nDofs for all normal directions. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDims Number of dimensions of the polynomial data. integer, intent(in) :: inLen (nDims) Number degrees of freedom for each direction in parent_Data. The first index of parent_data needs to have a length equal to the\nproduct of all inLen components.\nThe splitting operation will be done in the last dimension. integer, intent(in) :: outLen (nDims) Number degrees of freedom for each direction in child_Data. The first index of child_data needs to have a length equal to the\nproduct of all outLen components.\nThe data will be cyclicly exchanged. Thus, the last dimension in\nparent_data corresponds to the first in one in child_data and all\nother components are shifted once to the right. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial representation in the parent elements. The first index are the degrees of freedom in elements, the second index\nare the elements.\nIn the first index the shape of data has to be in the form\n(inLen(1), inLen(2), ... , inLen(nDims)).\nThe splitting operation is performed on the last dimension in that\ndata. real(kind=rk), intent(out) :: child_data (:,:) Computed projection of the polynomial representation in the child\nelements. Again, the first index refers to the degrees of freedom, while the\nsecond index are the elements. There need to be twice as many elements\nas in the parent_data.\nLeft childs are stored in iChild = (iParent 2 - 1), and the right\nchilds in iParent 2. In the first index the shape of the data has to be in the form\n(outLen(1), outLen(2), ... , outLen(nDims)), the data is rotated\nin comparison to parent_data and the splitted direction has to be\nthe first one in child_data (while it was the last in parent_data),\nand all other dimensions are shifted by one to the right. logical, intent(in) :: ignore Whether to ignore high modes that exceed the target maximal polynomial\ndegree. This can be used as a simple lowpass filter that cuts off the highest\nmodes in the parent elements prior to mapping to child elements. Called by proc~~ply_split_element_singled~~CalledByGraph proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_1d ply_split_element_1D proc~ply_split_element_1d->proc~ply_split_element_singled proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_1d_test->proc~ply_split_element_singled proc~ply_split_element_2d ply_split_element_2D proc~ply_split_element_2d->proc~ply_split_element_singled proc~ply_split_element_3d ply_split_element_3D proc~ply_split_element_3d->proc~ply_split_element_singled proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_2d proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_3d proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_singled.html"},{"title":"ply_split_element_1D – Seeder","text":"public  subroutine ply_split_element_1D(parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Split one-dimensional elements of degree parent_degree into two elements\nwith polynomials of degree child_degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Elements follow the ordering of the Z space filling curve. logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. This can be used as a simple lowpass filter by ignoring all higher\nmodes from the parent element, that exceed the target polynomial\ndegree. Thus, the polynomials are filtered before projection,\ninstead of cutting them only of after refinement.\nDefaults to false (no filtering). Calls proc~~ply_split_element_1d~~CallsGraph proc~ply_split_element_1d ply_split_element_1D proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_1d->proc~ply_split_element_singled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_1d.html"},{"title":"ply_split_element_2D – Seeder","text":"public  subroutine ply_split_element_2D(parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Split two-dimensional elements of degree parent_degree into four elements\nwith polynomials of degree child_degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Elements follow the ordering of the Z space filling curve. logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. This can be used as a simple lowpass filter by ignoring all higher\nmodes from the parent element, that exceed the target polynomial\ndegree. Thus, the polynomials are filtered before projection,\ninstead of cutting them only of after refinement.\nDefaults to false (no filtering). Calls proc~~ply_split_element_2d~~CallsGraph proc~ply_split_element_2d ply_split_element_2D proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_2d->proc~ply_split_element_singled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_split_element_2d~~CalledByGraph proc~ply_split_element_2d ply_split_element_2D proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_2d_test->proc~ply_split_element_2d proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_2d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_2d.html"},{"title":"ply_split_element_3D – Seeder","text":"public  subroutine ply_split_element_3D(parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Split three-dimensional elements of degree parent_degree into eight\nelements with polynomials of degree child_degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Elements follow the ordering of the Z space filling curve. logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. This can be used as a simple lowpass filter by ignoring all higher\nmodes from the parent element, that exceed the target polynomial\ndegree. Thus, the polynomials are filtered before projection,\ninstead of cutting them only of after refinement.\nDefaults to false (no filtering). Calls proc~~ply_split_element_3d~~CallsGraph proc~ply_split_element_3d ply_split_element_3D proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_3d->proc~ply_split_element_singled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_split_element_3d~~CalledByGraph proc~ply_split_element_3d ply_split_element_3D proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_3d_test->proc~ply_split_element_3d proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_3d.html"},{"title":"ply_split_element_test – Seeder","text":"public  subroutine ply_split_element_test(success) Testing routine for the functions of this module. Arguments Type Intent Optional Attributes Name logical, intent(out) :: success Indication whether the tests were completed successfully. Calls proc~~ply_split_element_test~~CallsGraph proc~ply_split_element_test ply_split_element_test proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_test->proc~ply_split_element_1d_test proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_test->proc~ply_split_element_2d_test proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_test->proc~ply_split_element_3d_test proc~ply_split_element_init ply_split_element_init proc~ply_split_element_test->proc~ply_split_element_init proc~ply_split_element_1d_test->proc~ply_split_element_init ply_legendre_1d ply_legendre_1d proc~ply_split_element_1d_test->ply_legendre_1d proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_1d_test->proc~ply_split_element_singled proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_2d_test->ply_legendre_1d proc~ply_split_element_2d ply_split_element_2D proc~ply_split_element_2d_test->proc~ply_split_element_2d proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_3d_test->ply_legendre_1d proc~ply_split_element_3d ply_split_element_3D proc~ply_split_element_3d_test->proc~ply_split_element_3d proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~ply_split_element_2d->proc~ply_split_element_singled proc~ply_split_element_3d->proc~ply_split_element_singled proc~alpha alpha proc~ply_split_legendre_matrix->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix->proc~alpha_frac proc~beta beta proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_test.html"},{"title":"ply_split_element_1D_test – Seeder","text":"private  subroutine ply_split_element_1D_test(nModes, success) Testing the 1D splitting. We test all combinations, even though a higher number of modes in the\nchildren is probably not that relevant, it should still be possible. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of modes in the (1D) polynomials to use in the check. logical, intent(out) :: success Indication whether the tests were completed successfully. Calls proc~~ply_split_element_1d_test~~CallsGraph proc~ply_split_element_1d_test ply_split_element_1D_test ply_legendre_1d ply_legendre_1d proc~ply_split_element_1d_test->ply_legendre_1d proc~ply_split_element_init ply_split_element_init proc~ply_split_element_1d_test->proc~ply_split_element_init proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_1d_test->proc~ply_split_element_singled proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~alpha alpha proc~ply_split_legendre_matrix->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix->proc~alpha_frac proc~beta beta proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_split_element_1d_test~~CalledByGraph proc~ply_split_element_1d_test ply_split_element_1D_test proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_1d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_1d_test.html"},{"title":"ply_split_element_2D_test – Seeder","text":"private  subroutine ply_split_element_2D_test(nModes, success) Testing the 2D splitting. In two dimensions we only check the downsized polynomial splitting\n(child_degree <= parent_degree), upsized splitting is checked for 1D\noperations already.\nFor child_degree == parent_degree the resulting polynomials are probed\nat a set of random points to ensure the polynomials coincide with the\nparent polynomial.\nFor those, where modes are cut off, we check the integral mean to be\nmaintained. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of modes in the (1D) polynomials to use in the check. logical, intent(out) :: success Indication whether the tests were completed successfully. Calls proc~~ply_split_element_2d_test~~CallsGraph proc~ply_split_element_2d_test ply_split_element_2D_test ply_legendre_1d ply_legendre_1d proc~ply_split_element_2d_test->ply_legendre_1d proc~ply_split_element_2d ply_split_element_2D proc~ply_split_element_2d_test->proc~ply_split_element_2d proc~ply_split_element_init ply_split_element_init proc~ply_split_element_2d_test->proc~ply_split_element_init proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_2d->proc~ply_split_element_singled proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~alpha alpha proc~ply_split_legendre_matrix->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix->proc~alpha_frac proc~beta beta proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_split_element_2d_test~~CalledByGraph proc~ply_split_element_2d_test ply_split_element_2D_test proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_2d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_2d_test.html"},{"title":"ply_split_element_3D_test – Seeder","text":"private  subroutine ply_split_element_3D_test(nModes, success) Testing the 3D splitting. In three dimensions we only check the splitting to polynomials of same\npolynomial degree.\nDownsizing is checked in 2D, and upsizing is only checked for 1D.\nThe resulting polynomials are probed at a set of random points to ensure Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of modes in the (1D) polynomials to use in the check. logical, intent(out) :: success Indication whether the tests were completed successfully. Calls proc~~ply_split_element_3d_test~~CallsGraph proc~ply_split_element_3d_test ply_split_element_3D_test ply_legendre_1d ply_legendre_1d proc~ply_split_element_3d_test->ply_legendre_1d proc~ply_split_element_3d ply_split_element_3D proc~ply_split_element_3d_test->proc~ply_split_element_3d proc~ply_split_element_init ply_split_element_init proc~ply_split_element_3d_test->proc~ply_split_element_init proc~ply_split_element_singled ply_split_element_singleD proc~ply_split_element_3d->proc~ply_split_element_singled proc~ply_split_legendre_matrix ply_split_legendre_matrix proc~ply_split_element_init->proc~ply_split_legendre_matrix proc~alpha alpha proc~ply_split_legendre_matrix->proc~alpha proc~alpha_beta alpha_beta proc~ply_split_legendre_matrix->proc~alpha_beta proc~alpha_frac alpha_frac proc~ply_split_legendre_matrix->proc~alpha_frac proc~beta beta proc~ply_split_legendre_matrix->proc~beta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_split_element_3d_test~~CalledByGraph proc~ply_split_element_3d_test ply_split_element_3D_test proc~ply_split_element_test ply_split_element_test proc~ply_split_element_test->proc~ply_split_element_3d_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_split_element_3d_test.html"},{"title":"ply_init_l2p – Seeder","text":"public  subroutine ply_init_l2p(l2p, header, degree) Initialize the transformations via L2 projections. Arguments Type Intent Optional Attributes Name type( ply_l2p_type ), intent(out) :: l2p type( ply_l2p_header_type ), intent(in) :: header integer, intent(in) :: degree Calls proc~~ply_init_l2p~~CallsGraph proc~ply_init_l2p ply_init_l2p ply_legendre_1d ply_legendre_1d proc~ply_init_l2p->ply_legendre_1d ply_scalprodleg ply_scalprodleg proc~ply_init_l2p->ply_scalprodleg proc~ply_gausslegpoints ply_gaussLegPoints proc~ply_init_l2p->proc~ply_gausslegpoints proc~ply_lagrange_1d ply_lagrange_1D proc~ply_init_l2p->proc~ply_lagrange_1d proc~ply_lagrange_define ply_lagrange_define proc~ply_init_l2p->proc~ply_lagrange_define tem_abort tem_abort proc~ply_init_l2p->tem_abort proc~ply_lagrange_mode_at ply_lagrange_mode_at proc~ply_lagrange_1d->proc~ply_lagrange_mode_at Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_init_l2p.html"},{"title":"ply_l2p_trafo_1D – Seeder","text":"public  subroutine ply_l2p_trafo_1D(trafo, projected, original) Transformation between modal and nodal values in 1D via L2 projection. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: trafo (:,:) L2 Projection matrix, this determines the direction of the trafo at hand l2p%leg2node = modal to nodal\nl2p%node2leg = nodal to modal real(kind=rk), intent(inout) :: projected (:) Projected coefficients. real(kind=rk), intent(inout) :: original (:) Original coefficients to project. Calls proc~~ply_l2p_trafo_1d~~CallsGraph proc~ply_l2p_trafo_1d ply_l2p_trafo_1D proc~ply_l2_projection ply_l2_projection proc~ply_l2p_trafo_1d->proc~ply_l2_projection Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2p_trafo_1d.html"},{"title":"ply_l2p_trafo_2D – Seeder","text":"public  subroutine ply_l2p_trafo_2D(trafo, projected, original) Transformation between modal and nodal values in 2D via L2 projection. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: trafo (:,:) L2 Projection matrix, this determines the direction of the trafo at hand l2p%leg2node = modal to nodal\nl2p%node2leg = nodal to modal real(kind=rk), intent(inout) :: projected (:) Projected coefficients. real(kind=rk), intent(inout) :: original (:) Original coefficients to project. Calls proc~~ply_l2p_trafo_2d~~CallsGraph proc~ply_l2p_trafo_2d ply_l2p_trafo_2D proc~ply_l2_projection ply_l2_projection proc~ply_l2p_trafo_2d->proc~ply_l2_projection Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2p_trafo_2d.html"},{"title":"ply_l2p_trafo_3D – Seeder","text":"public  subroutine ply_l2p_trafo_3D(trafo, projected, original) Transformation between modal and nodal values in 3D via L2 projection. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: trafo (:,:) L2 Projection matrix, this determines the direction of the trafo at hand l2p%leg2node = modal to nodal\nl2p%node2leg = nodal to modal real(kind=rk), intent(inout) :: projected (:) Projected coefficients. real(kind=rk), intent(inout) :: original (:) Original coefficients to project. Calls proc~~ply_l2p_trafo_3d~~CallsGraph proc~ply_l2p_trafo_3d ply_l2p_trafo_3D proc~ply_l2_projection ply_l2_projection proc~ply_l2p_trafo_3d->proc~ply_l2_projection Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2p_trafo_3d.html"},{"title":"Copy_ply_l2p – Seeder","text":"private  subroutine Copy_ply_l2p(left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_type ), intent(out) :: left fpt to copy to type( ply_l2p_type ), intent(in) :: right fpt to copy from Called by proc~~copy_ply_l2p~~CalledByGraph proc~copy_ply_l2p Copy_ply_l2p interface~assignment(=)~4 assignment(=) interface~assignment(=)~4->proc~copy_ply_l2p Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/copy_ply_l2p.html"},{"title":"ply_l2_projection – Seeder","text":"private  subroutine ply_l2_projection(nDofs, nIndeps, projected, original, matrix) Actual implementation of the matrix operation to change between nodal\nand modal representations. The operation is applied simultaneously to nIndeps 1D sections of the\nprovided original data.\nThese 1D sections have to run fastest in the original array and will be\ntransposed (running slowest in the projected array).\nThe actual direction of the operation depends on the passed matrix.\nmatrix = l2p%leg2node will do the modal to nodal transformation\nmatrix = l2p%node2leg will do the nodal to modal transformation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDofs Number of degree of freedoms integer, intent(in) :: nIndeps Number of values that can be computed independently. real(kind=rk), intent(out) :: projected (nIndeps,nDofs) Projected data. Size has to be nIndeps*size(matrix,1), and the layout is changed here\nwhen compared to the original array, as the projected direction moves\nto the end. real(kind=rk), intent(in) :: original (nDofs,nIndeps) Original data. Size has to be size(matrix,1) and the direction to be projected has to\nbe the fastest running one. real(kind=rk), intent(in) :: matrix (nDofs,nDofs) Matrix to apply in this operation. The matrix defines wether this is a modal to nodal transformation or the\nother way around. Called by proc~~ply_l2_projection~~CalledByGraph proc~ply_l2_projection ply_l2_projection proc~ply_l2p_trafo_1d ply_l2p_trafo_1D proc~ply_l2p_trafo_1d->proc~ply_l2_projection proc~ply_l2p_trafo_2d ply_l2p_trafo_2D proc~ply_l2p_trafo_2d->proc~ply_l2_projection proc~ply_l2p_trafo_3d ply_l2p_trafo_3D proc~ply_l2p_trafo_3d->proc~ply_l2_projection Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_l2_projection.html"},{"title":"assignment(=) – Seeder","text":"public interface assignment(=) Calls interface~~assignment(=)~4~~CallsGraph interface~assignment(=)~4 assignment(=) proc~copy_ply_l2p Copy_ply_l2p interface~assignment(=)~4->proc~copy_ply_l2p Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine Copy_ply_l2p (left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_type ), intent(out) :: left fpt to copy to type( ply_l2p_type ), intent(in) :: right fpt to copy from","tags":"","url":"interface/assignment(=)~4.html"},{"title":"isEqual – Seeder","text":"private pure function isEqual(left, right) result(equality) This function provides the test for equality of two projections. Two fxt header are considered to be equal, if their node_header,\nand the factor are equal. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? Called by proc~~isequal~4~~CalledByGraph proc~isequal~4 isEqual interface~operator(==)~4 operator(==) interface~operator(==)~4->proc~isequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isequal~4.html"},{"title":"isUnequal – Seeder","text":"private pure function isUnequal(left, right) result(unequality) This function provides the test for unequality of two projections. Two fxt header are considered to be unequal, if their node_header,\nor the factor are not equal. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? Called by proc~~isunequal~4~~CalledByGraph proc~isunequal~4 isUnequal interface~operator(SLASH=)~4 operator(/=) interface~operator(SLASH=)~4->proc~isunequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isunequal~4.html"},{"title":"isSmaller – Seeder","text":"private pure function isSmaller(left, right) result(small) This function provides a < comparison of two projections. Sorting of fxt header is given by node_header and by the factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmaller~4~~CalledByGraph proc~issmaller~4 isSmaller interface~operator(lt)~4 operator(<) interface~operator(lt)~4->proc~issmaller~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmaller~4.html"},{"title":"isSmallerOrEqual – Seeder","text":"private pure function isSmallerOrEqual(left, right) result(small) This function provides a <= comparison of two projections. Sorting of fxt header is given by node_header, fxt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmallerorequal~4~~CalledByGraph proc~issmallerorequal~4 isSmallerOrEqual interface~operator(lt=)~4 operator(<=) interface~operator(lt=)~4->proc~issmallerorequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmallerorequal~4.html"},{"title":"isGreater – Seeder","text":"private pure function isGreater(left, right) result(great) This function provides a > comparison of two projections. Sorting of fxt header is given by node_header, fxt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreater~4~~CalledByGraph proc~isgreater~4 isGreater interface~operator(gt)~4 operator(>) interface~operator(gt)~4->proc~isgreater~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreater~4.html"},{"title":"isGreaterOrEqual – Seeder","text":"private pure function isGreaterOrEqual(left, right) result(great) This function provides a >= comparison of two projections. Sorting of fxt header is given by node_header, fxt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreaterorequal~4~~CalledByGraph proc~isgreaterorequal~4 isGreaterOrEqual interface~operator(gt=)~4 operator(>=) interface~operator(gt=)~4->proc~isgreaterorequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreaterorequal~4.html"},{"title":"ply_fxt_header_load – Seeder","text":"public  subroutine ply_fxt_header_load(me, conf, thandle) Load settings to describe a projection method from a Lua table. \\todo Check, wether Lobatto Points could be used with FXTPACK.\ncall aot_get_val(L       = conf,                          &\n  &              thandle = thandle,                       &\n  &              key     = 'lobattoPoints',               &\n  &              val     = me%nodes_header%lobattoPoints, &\n  &              ErrCode = iError,                        &\n  &              default = .false.                        ) Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in) :: thandle Calls proc~~ply_fxt_header_load~~CallsGraph proc~ply_fxt_header_load ply_fxt_header_load aot_get_val aot_get_val proc~ply_fxt_header_load->aot_get_val tem_abort tem_abort proc~ply_fxt_header_load->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_fxt_header_load~~CalledByGraph proc~ply_fxt_header_load ply_fxt_header_load proc~ply_prj_header_load ply_prj_header_load proc~ply_prj_header_load->proc~ply_fxt_header_load proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_header_load.html"},{"title":"ply_fxt_header_out – Seeder","text":"public  subroutine ply_fxt_header_out(me, conf) Write FXT settings into a Lua table. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: me type( aot_out_type ) :: conf Calls proc~~ply_fxt_header_out~~CallsGraph proc~ply_fxt_header_out ply_fxt_header_out aot_out_val aot_out_val proc~ply_fxt_header_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_fxt_header_out~~CalledByGraph proc~ply_fxt_header_out ply_fxt_header_out proc~ply_prj_header_out ply_prj_header_out proc~ply_prj_header_out->proc~ply_fxt_header_out proc~sdr_dump_treelm sdr_dump_treelm proc~sdr_dump_treelm->proc~ply_prj_header_out program~seeder seeder program~seeder->proc~sdr_dump_treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_header_out.html"},{"title":"ply_fxt_header_display – Seeder","text":"public  subroutine ply_fxt_header_display(me) Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: me Called by proc~~ply_fxt_header_display~~CalledByGraph proc~ply_fxt_header_display ply_fxt_header_display proc~ply_prj_header_load ply_prj_header_load proc~ply_prj_header_load->proc~ply_fxt_header_display proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fxt_header_display.html"},{"title":"Copy_fxt_header – Seeder","text":"private pure subroutine Copy_fxt_header(left, right) Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(out) :: left fpt to copy to type( ply_fxt_header_type ), intent(in) :: right fpt to copy from Called by proc~~copy_fxt_header~~CalledByGraph proc~copy_fxt_header Copy_fxt_header interface~assignment(=)~5 assignment(=) interface~assignment(=)~5->proc~copy_fxt_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/copy_fxt_header.html"},{"title":"assignment(=) – Seeder","text":"public interface assignment(=) Calls interface~~assignment(=)~5~~CallsGraph interface~assignment(=)~5 assignment(=) proc~copy_fxt_header Copy_fxt_header interface~assignment(=)~5->proc~copy_fxt_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine Copy_fxt_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(out) :: left fpt to copy to type( ply_fxt_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"interface/assignment(=)~5.html"},{"title":"operator(==) – Seeder","text":"public interface operator(==) Calls interface~~operator(==)~4~~CallsGraph interface~operator(==)~4 operator(==) proc~isequal~4 isEqual interface~operator(==)~4->proc~isequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal??","tags":"","url":"interface/operator(==)~4.html"},{"title":"operator(/=) – Seeder","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~4~~CallsGraph interface~operator(SLASH=)~4 operator(/=) proc~isunequal~4 isUnequal interface~operator(SLASH=)~4->proc~isunequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal??","tags":"","url":"interface/operator(SLASH=)~4.html"},{"title":"operator(<) – Seeder","text":"public interface operator(<) Calls interface~~operator(lt)~4~~CallsGraph interface~operator(lt)~4 operator(<) proc~issmaller~4 isSmaller interface~operator(lt)~4->proc~issmaller~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt)~4.html"},{"title":"operator(<=) – Seeder","text":"public interface operator(<=) Calls interface~~operator(lt=)~4~~CallsGraph interface~operator(lt=)~4 operator(<=) proc~issmallerorequal~4 isSmallerOrEqual interface~operator(lt=)~4->proc~issmallerorequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt=)~4.html"},{"title":"operator(>) – Seeder","text":"public interface operator(>) Calls interface~~operator(gt)~4~~CallsGraph interface~operator(gt)~4 operator(>) proc~isgreater~4 isGreater interface~operator(gt)~4->proc~isgreater~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt)~4.html"},{"title":"operator(>=) – Seeder","text":"public interface operator(>=) Calls interface~~operator(gt=)~4~~CallsGraph interface~operator(gt=)~4 operator(>=) proc~isgreaterorequal~4 isGreaterOrEqual interface~operator(gt=)~4->proc~isgreaterorequal~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt=)~4.html"},{"title":"sdr_init_global – Seeder","text":"public  subroutine sdr_init_global(solveHead) Prominently let the user now, what he actually is running right now. Also set the solvername and version number in the solveHead. Arguments Type Intent Optional Attributes Name type( tem_solveHead_type ), intent(in) :: solveHead contains solver header information Calls proc~~sdr_init_global~~CallsGraph proc~sdr_init_global sdr_init_global tem_print_execInfo tem_print_execInfo proc~sdr_init_global->tem_print_execInfo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_init_global~~CalledByGraph proc~sdr_init_global sdr_init_global program~seeder seeder program~seeder->proc~sdr_init_global Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_init_global.html"},{"title":"isEqual – Seeder","text":"private pure function isEqual(left, right) result(equality) This function provides the test for equality of two projections. Two fpt header are considered to be equal, if their  node_header,\nfpt_blocksize or the factor are equal. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? Called by proc~~isequal~5~~CalledByGraph proc~isequal~5 isEqual interface~operator(==)~5 operator(==) interface~operator(==)~5->proc~isequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isequal~5.html"},{"title":"isUnequal – Seeder","text":"private pure function isUnequal(left, right) result(unequality) This function provides the test for unequality of two projections. Two fpt header are considered to be unequal, if their  node_header,\nfpt_blocksize or the factor are not equal. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? Called by proc~~isunequal~5~~CalledByGraph proc~isunequal~5 isUnequal interface~operator(SLASH=)~5 operator(/=) interface~operator(SLASH=)~5->proc~isunequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isunequal~5.html"},{"title":"isSmaller – Seeder","text":"private pure function isSmaller(left, right) result(small) This function provides a < comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmaller~5~~CalledByGraph proc~issmaller~5 isSmaller interface~operator(lt)~5 operator(<) interface~operator(lt)~5->proc~issmaller~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmaller~5.html"},{"title":"isSmallerOrEqual – Seeder","text":"private pure function isSmallerOrEqual(left, right) result(small) This function provides a <= comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? Called by proc~~issmallerorequal~5~~CalledByGraph proc~issmallerorequal~5 isSmallerOrEqual interface~operator(lt=)~5 operator(<=) interface~operator(lt=)~5->proc~issmallerorequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/issmallerorequal~5.html"},{"title":"isGreater – Seeder","text":"private pure function isGreater(left, right) result(great) This function provides a > comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreater~5~~CalledByGraph proc~isgreater~5 isGreater interface~operator(gt)~5 operator(>) interface~operator(gt)~5->proc~isgreater~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreater~5.html"},{"title":"isGreaterOrEqual – Seeder","text":"private pure function isGreaterOrEqual(left, right) result(great) This function provides a >= comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Called by proc~~isgreaterorequal~5~~CalledByGraph proc~isgreaterorequal~5 isGreaterOrEqual interface~operator(gt=)~5 operator(>=) interface~operator(gt=)~5->proc~isgreaterorequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/isgreaterorequal~5.html"},{"title":"ply_fpt_header_load – Seeder","text":"public  subroutine ply_fpt_header_load(me, conf, thandle) Read the FPT configuration options from the provided Lua script in conf . Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: me type( flu_State ), intent(inout) :: conf integer, intent(in) :: thandle Calls proc~~ply_fpt_header_load~~CallsGraph proc~ply_fpt_header_load ply_fpt_header_load aot_get_val aot_get_val proc~ply_fpt_header_load->aot_get_val tem_abort tem_abort proc~ply_fpt_header_load->tem_abort upper_to_lower upper_to_lower proc~ply_fpt_header_load->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_fpt_header_load~~CalledByGraph proc~ply_fpt_header_load ply_fpt_header_load proc~ply_prj_header_load ply_prj_header_load proc~ply_prj_header_load->proc~ply_fpt_header_load proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fpt_header_load.html"},{"title":"ply_fpt_header_define – Seeder","text":"public  subroutine ply_fpt_header_define(me, blocksize, factor, approx_terms, implementation, striplen, subBlockingWidth, adapt_factor_pow2, lobattoPoints) Define settings for the Fast Polynomial Transformation. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: me FPT header to hold the defined settings. integer, intent(in), optional :: blocksize Blocksize to use in approximation algorithm. Defaults to ply_fpt_default_blocksize . real(kind=rk), intent(in), optional :: factor Oversampling factor to use. This can be used to reduce aliasing when projecting functions that\nwill be truncated in the polynomial series expansion.\nDefault is a factor of 1, so no oversampling. integer, intent(in), optional :: approx_terms Number of approximation terms to use for the representation of the\nblocks in the Legendre to Chebyshev transformation algorithm.\nDefaults to ply_fpt_default_approx_terms . integer, intent(in), optional :: implementation Implementation to use in the computation. Select the implementation variant to use. Either scalar\n( ply_fpt_scalar ) or vectorized\n( ply_fpt_vector ).\nDefault is ply_fpt_scalar . integer, intent(in), optional :: striplen Length of strips to use in the transformation implementation.\nDefaults to vlen . integer, intent(in), optional :: subBlockingWidth Width for subblocks in unrolling the approximate Legendre to\nChebyshev transformation. Defaults to ply_fpt_default_subblockingWidth . logical, intent(in), optional :: adapt_factor_pow2 Adapt the oversampling factor such, that oversampled space has a\nnumber of degrees of freedoms in one direction that is a power of 2.\nDefault is .false.. logical, intent(in), optional :: lobattoPoints Wether to use Chebyshev-Lobatto points (include boundary points) or\nnot. Defaults to .false.. Calls proc~~ply_fpt_header_define~~CallsGraph proc~ply_fpt_header_define ply_fpt_header_define tem_abort tem_abort proc~ply_fpt_header_define->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fpt_header_define.html"},{"title":"ply_fpt_header_out – Seeder","text":"public  subroutine ply_fpt_header_out(me, conf) Write FPT settings into a Lua table. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: me type( aot_out_type ), intent(inout) :: conf Calls proc~~ply_fpt_header_out~~CallsGraph proc~ply_fpt_header_out ply_fpt_header_out aot_out_val aot_out_val proc~ply_fpt_header_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ply_fpt_header_out~~CalledByGraph proc~ply_fpt_header_out ply_fpt_header_out proc~ply_prj_header_out ply_prj_header_out proc~ply_prj_header_out->proc~ply_fpt_header_out proc~sdr_dump_treelm sdr_dump_treelm proc~sdr_dump_treelm->proc~ply_prj_header_out program~seeder seeder program~seeder->proc~sdr_dump_treelm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fpt_header_out.html"},{"title":"ply_fpt_header_display – Seeder","text":"public  subroutine ply_fpt_header_display(me) Print the FPT settings to the log output. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: me Called by proc~~ply_fpt_header_display~~CalledByGraph proc~ply_fpt_header_display ply_fpt_header_display proc~ply_prj_header_load ply_prj_header_load proc~ply_prj_header_load->proc~ply_fpt_header_display proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_fpt_header_display.html"},{"title":"Copy_fpt_header – Seeder","text":"private pure subroutine Copy_fpt_header(left, right) Copy the FPT header information. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: left fpt to copy to type( ply_fpt_header_type ), intent(in) :: right fpt to copy from Called by proc~~copy_fpt_header~~CalledByGraph proc~copy_fpt_header Copy_fpt_header interface~assignment(=)~6 assignment(=) interface~assignment(=)~6->proc~copy_fpt_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/copy_fpt_header.html"},{"title":"assignment(=) – Seeder","text":"public interface assignment(=) Calls interface~~assignment(=)~6~~CallsGraph interface~assignment(=)~6 assignment(=) proc~copy_fpt_header Copy_fpt_header interface~assignment(=)~6->proc~copy_fpt_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine Copy_fpt_header (left, right) Copy the FPT header information. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: left fpt to copy to type( ply_fpt_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"interface/assignment(=)~6.html"},{"title":"operator(==) – Seeder","text":"public interface operator(==) Calls interface~~operator(==)~5~~CallsGraph interface~operator(==)~5 operator(==) proc~isequal~5 isEqual interface~operator(==)~5->proc~isequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal??","tags":"","url":"interface/operator(==)~5.html"},{"title":"operator(/=) – Seeder","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~5~~CallsGraph interface~operator(SLASH=)~5 operator(/=) proc~isunequal~5 isUnequal interface~operator(SLASH=)~5->proc~isunequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal??","tags":"","url":"interface/operator(SLASH=)~5.html"},{"title":"operator(<) – Seeder","text":"public interface operator(<) Calls interface~~operator(lt)~5~~CallsGraph interface~operator(lt)~5 operator(<) proc~issmaller~5 isSmaller interface~operator(lt)~5->proc~issmaller~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt)~5.html"},{"title":"operator(<=) – Seeder","text":"public interface operator(<=) Calls interface~~operator(lt=)~5~~CallsGraph interface~operator(lt=)~5 operator(<=) proc~issmallerorequal~5 isSmallerOrEqual interface~operator(lt=)~5->proc~issmallerorequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller??","tags":"","url":"interface/operator(lt=)~5.html"},{"title":"operator(>) – Seeder","text":"public interface operator(>) Calls interface~~operator(gt)~5~~CallsGraph interface~operator(gt)~5 operator(>) proc~isgreater~5 isGreater interface~operator(gt)~5->proc~isgreater~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt)~5.html"},{"title":"operator(>=) – Seeder","text":"public interface operator(>=) Calls interface~~operator(gt=)~5~~CallsGraph interface~operator(gt=)~5 operator(>=) proc~isgreaterorequal~5 isGreaterOrEqual interface~operator(gt=)~5->proc~isgreaterorequal~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater??","tags":"","url":"interface/operator(gt=)~5.html"},{"title":"ply_init_legFpt – Seeder","text":"public  subroutine ply_init_legFpt(maxPolyDegree, nIndeps, fpt, header, fft_flags) Subroutine to initialize the fast polynomial transformation\n for Legendre expansion. fpt%planPntToCheb = fftw_plan_r2r_1d( n     = n,             &\n  &                                   in    = tmpIn,         &\n  &                                   out   = tmpOut,        &\n  &                                   kind  = FFTW_REDFT10,  &\n  &                                   flags = planning_flags )\nfpt%planPntToCheb = fftw_plan_r2r_1d( n     = n,             &\n  &                                   in    = tmpIn,         &\n  &                                   out   = tmpOut,        &\n  &                                   kind  = FFTW_REDFT10,  &\n  &                                   flags = planning_flags )\nfpt%planChebToPnt = fftw_plan_r2r_1d( n     = n,             &\n  &                                   in    = tmpIn,         &\n  &                                   out   = tmpOut,        &\n  &                                   kind  = FFTW_REDFT00,  &\n  &                                   flags = planning_flags ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxPolyDegree Maximal polynomial degree for the transformation. integer, intent(in) :: nIndeps Number of independent values that can be computed simultaneously. type( ply_legFpt_type ), intent(inout) :: fpt The Fast Polynomial Transformation setting to initialize. type( ply_fpt_header_type ), intent(in) :: header Configuration settings for the projection. integer, intent(in), optional :: fft_flags Planning flags for the FFT. Configuration to how much time to spend on finding an optimal FFT\nimplementation in the FFTW.\nSee: http://www.fftw.org/doc/Planner-Flags.html#Planner-Flags Defaults to FFTW_MEASURE. Calls proc~~ply_init_legfpt~~CallsGraph proc~ply_init_legfpt ply_init_legFpt fftw_plan_many_r2r fftw_plan_many_r2r proc~ply_init_legfpt->fftw_plan_many_r2r fftw_plan_r2r_1d fftw_plan_r2r_1d proc~ply_init_legfpt->fftw_plan_r2r_1d ply_fpt_init ply_fpt_init proc~ply_init_legfpt->ply_fpt_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_init_legfpt.html"},{"title":"Copy_fpt – Seeder","text":"private  subroutine Copy_fpt(left, right) Arguments Type Intent Optional Attributes Name type( ply_legFpt_type ), intent(out) :: left fpt to copy to type( ply_legFpt_type ), intent(in) :: right fpt to copy from Called by proc~~copy_fpt~~CalledByGraph proc~copy_fpt Copy_fpt interface~assignment(=)~7 assignment(=) interface~assignment(=)~7->proc~copy_fpt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/copy_fpt.html"},{"title":"ply_legToPnt_single – Seeder","text":"private  subroutine ply_legToPnt_single(fpt, legCoeffs, pntVal, nIndeps) Subroutine to transform Legendre expansion to point values\nat Chebyshev nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps Calls proc~~ply_legtopnt_single~~CallsGraph proc~ply_legtopnt_single ply_legToPnt_single fftw_execute_r2r fftw_execute_r2r proc~ply_legtopnt_single->fftw_execute_r2r ply_fpt_single ply_fpt_single proc~ply_legtopnt_single->ply_fpt_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_legtopnt_single.html"},{"title":"ply_legToPnt_vec – Seeder","text":"private  subroutine ply_legToPnt_vec(fpt, legCoeffs, pntVal, nIndeps) Vectorizing subroutine to transform Legendre expansion to point values\nat Chebyshev nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps Calls proc~~ply_legtopnt_vec~~CallsGraph proc~ply_legtopnt_vec ply_legToPnt_vec fftw_execute_r2r fftw_execute_r2r proc~ply_legtopnt_vec->fftw_execute_r2r ply_fpt_exec_striped ply_fpt_exec_striped proc~ply_legtopnt_vec->ply_fpt_exec_striped Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_legtopnt_vec.html"},{"title":"ply_legToPnt_lobatto_single – Seeder","text":"private  subroutine ply_legToPnt_lobatto_single(fpt, legCoeffs, pntVal, nIndeps) Subroutine to transform Legendre expansion to point values\nat Chebyshev-Lobatto nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps Calls proc~~ply_legtopnt_lobatto_single~~CallsGraph proc~ply_legtopnt_lobatto_single ply_legToPnt_lobatto_single fftw_execute_r2r fftw_execute_r2r proc~ply_legtopnt_lobatto_single->fftw_execute_r2r ply_fpt_single ply_fpt_single proc~ply_legtopnt_lobatto_single->ply_fpt_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_legtopnt_lobatto_single.html"},{"title":"ply_legToPnt_lobatto_vec – Seeder","text":"private  subroutine ply_legToPnt_lobatto_vec(fpt, legCoeffs, pntVal, nIndeps) Vectorizing subroutine to transform Legendre expansion to point values\nat Chebyshev-Lobatto nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps Calls proc~~ply_legtopnt_lobatto_vec~~CallsGraph proc~ply_legtopnt_lobatto_vec ply_legToPnt_lobatto_vec fftw_execute_r2r fftw_execute_r2r proc~ply_legtopnt_lobatto_vec->fftw_execute_r2r ply_fpt_exec_striped ply_fpt_exec_striped proc~ply_legtopnt_lobatto_vec->ply_fpt_exec_striped Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_legtopnt_lobatto_vec.html"},{"title":"ply_pntToLeg_single – Seeder","text":"private  subroutine ply_pntToLeg_single(fpt, pntVal, legCoeffs, nIndeps) Subroutine to transform point values at Chebyshev nodes to a Legendre\nexpansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps Calls proc~~ply_pnttoleg_single~~CallsGraph proc~ply_pnttoleg_single ply_pntToLeg_single fftw_execute_r2r fftw_execute_r2r proc~ply_pnttoleg_single->fftw_execute_r2r ply_fpt_single ply_fpt_single proc~ply_pnttoleg_single->ply_fpt_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_pnttoleg_single.html"},{"title":"ply_pntToLeg_vec – Seeder","text":"private  subroutine ply_pntToLeg_vec(fpt, pntVal, legCoeffs, nIndeps) Vectorizing subroutine to transform point values at Chebyshev nodes to a\nLegendre expansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps Calls proc~~ply_pnttoleg_vec~~CallsGraph proc~ply_pnttoleg_vec ply_pntToLeg_vec fftw_execute_r2r fftw_execute_r2r proc~ply_pnttoleg_vec->fftw_execute_r2r ply_fpt_exec_striped ply_fpt_exec_striped proc~ply_pnttoleg_vec->ply_fpt_exec_striped Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_pnttoleg_vec.html"},{"title":"ply_pntToLeg_lobatto_single – Seeder","text":"private  subroutine ply_pntToLeg_lobatto_single(fpt, pntVal, legCoeffs, nIndeps) Subroutine to transform point values at Chebyshev-Lobatto nodes to a\nLegendre expansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps Calls proc~~ply_pnttoleg_lobatto_single~~CallsGraph proc~ply_pnttoleg_lobatto_single ply_pntToLeg_lobatto_single fftw_execute_r2r fftw_execute_r2r proc~ply_pnttoleg_lobatto_single->fftw_execute_r2r ply_fpt_single ply_fpt_single proc~ply_pnttoleg_lobatto_single->ply_fpt_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_pnttoleg_lobatto_single.html"},{"title":"ply_pntToLeg_lobatto_vec – Seeder","text":"private  subroutine ply_pntToLeg_lobatto_vec(fpt, pntVal, legCoeffs, nIndeps) Vectorizing subroutine to transform point values at Chebyshev-Lobatto\nnodes to a Legendre expansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps Calls proc~~ply_pnttoleg_lobatto_vec~~CallsGraph proc~ply_pnttoleg_lobatto_vec ply_pntToLeg_lobatto_vec fftw_execute_r2r fftw_execute_r2r proc~ply_pnttoleg_lobatto_vec->fftw_execute_r2r ply_fpt_exec_striped ply_fpt_exec_striped proc~ply_pnttoleg_lobatto_vec->ply_fpt_exec_striped Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ply_pnttoleg_lobatto_vec.html"},{"title":"assignment(=) – Seeder","text":"public interface assignment(=) Calls interface~~assignment(=)~7~~CallsGraph interface~assignment(=)~7 assignment(=) proc~copy_fpt Copy_fpt interface~assignment(=)~7->proc~copy_fpt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine Copy_fpt (left, right) Arguments Type Intent Optional Attributes Name type( ply_legFpt_type ), intent(out) :: left fpt to copy to type( ply_legFpt_type ), intent(in) :: right fpt to copy from","tags":"","url":"interface/assignment(=)~7.html"},{"title":"ply_fptm2n – Seeder","text":"interface private  subroutine ply_fptm2n(fpt, legCoeffs, pntVal, nIndeps) Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps","tags":"","url":"interface/ply_fptm2n.html"},{"title":"ply_fptn2m – Seeder","text":"interface private  subroutine ply_fptn2m(fpt, pntVal, legCoeffs, nIndeps) Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps","tags":"","url":"interface/ply_fptn2m.html"},{"title":"sdr_hvs_props_load – Seeder","text":"public  subroutine sdr_hvs_props_load(me, varsys, mesh, proc) Load the properties from the mesh. Arguments Type Intent Optional Attributes Name type( sdr_hvs_props_type ), intent(out) :: me Properties to load. type( tem_varSys_type ), intent(inout) :: varsys A variable system, to which the colors should be appended. type( treelmesh_type ), intent(in) :: mesh Mesh to load the properties for. type( tem_comm_env_type ), intent(in) :: proc Process description for MPI-IO Calls proc~~sdr_hvs_props_load~~CallsGraph proc~sdr_hvs_props_load sdr_hvs_props_load color_label color_label proc~sdr_hvs_props_load->color_label init_tem_bc_prop init_tem_bc_prop proc~sdr_hvs_props_load->init_tem_bc_prop proc~ply_subresolution_load ply_subresolution_load proc~sdr_hvs_props_load->proc~ply_subresolution_load proc~sdr_hvs_props_clean sdr_hvs_props_clean proc~sdr_hvs_props_load->proc~sdr_hvs_props_clean tem_color_prop_load tem_color_prop_load proc~sdr_hvs_props_load->tem_color_prop_load tem_varSys_append_derVar tem_varSys_append_derVar proc~sdr_hvs_props_load->tem_varSys_append_derVar aot_get_val aot_get_val proc~ply_subresolution_load->aot_get_val close_config close_config proc~ply_subresolution_load->close_config tem_abort tem_abort proc~ply_subresolution_load->tem_abort tem_open_distconf tem_open_distconf proc~ply_subresolution_load->tem_open_distconf tem_subres_prop_load tem_subres_prop_load proc~ply_subresolution_load->tem_subres_prop_load upper_to_lower upper_to_lower proc~ply_subresolution_load->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_hvs_props_load~~CalledByGraph proc~sdr_hvs_props_load sdr_hvs_props_load proc~sdr_hvs_config_load sdr_hvs_config_load proc~sdr_hvs_config_load->proc~sdr_hvs_props_load program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~sdr_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_hvs_props_load.html"},{"title":"sdr_hvs_props_import_dofs – Seeder","text":"public  subroutine sdr_hvs_props_import_dofs(me, mesh, proc, maxdegree, ndims) Import subresolved color data. Arguments Type Intent Optional Attributes Name type( sdr_hvs_props_type ), intent(inout) :: me Properties to get the subresolution dofs for. type( treelmesh_type ), intent(in) :: mesh Mesh definition, these properties belong to. type( tem_comm_env_type ), intent(in) :: proc Communicating environment. integer, intent(in) :: maxdegree Maximal polynomial degree to import. Set to 0, if only the integral mean value is to be loaded. integer, intent(in) :: ndims Dimensions of the polynomials after importing. Calls proc~~sdr_hvs_props_import_dofs~~CallsGraph proc~sdr_hvs_props_import_dofs sdr_hvs_props_import_dofs proc~ply_subres_import_color ply_subres_import_color proc~sdr_hvs_props_import_dofs->proc~ply_subres_import_color nelems nelems proc~ply_subres_import_color->nelems newunit newunit proc~ply_subres_import_color->newunit offset offset proc~ply_subres_import_color->offset ply_transfer_dofs ply_transfer_dofs proc~ply_subres_import_color->ply_transfer_dofs ply_transfer_p_dim ply_transfer_p_dim proc~ply_subres_import_color->ply_transfer_p_dim tem_abort tem_abort proc~ply_subres_import_color->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_hvs_props_import_dofs~~CalledByGraph proc~sdr_hvs_props_import_dofs sdr_hvs_props_import_dofs program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~sdr_hvs_props_import_dofs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_hvs_props_import_dofs.html"},{"title":"sdr_hvs_props_clean – Seeder","text":"private  subroutine sdr_hvs_props_clean(me) Clean up the properties data type. Takes care of the pointers, nullifies and deallocates them properly. Arguments Type Intent Optional Attributes Name type( sdr_hvs_props_type ), intent(out) :: me Called by proc~~sdr_hvs_props_clean~~CalledByGraph proc~sdr_hvs_props_clean sdr_hvs_props_clean proc~sdr_hvs_props_load sdr_hvs_props_load proc~sdr_hvs_props_load->proc~sdr_hvs_props_clean proc~sdr_hvs_config_load sdr_hvs_config_load proc~sdr_hvs_config_load->proc~sdr_hvs_props_load program~sdr_harvesting sdr_harvesting program~sdr_harvesting->proc~sdr_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_hvs_props_clean.html"},{"title":"sdr_subresolution_load – Seeder","text":"public  subroutine sdr_subresolution_load(subres, conf, parent) Loading the settings for the subresolution in the mesh. Arguments Type Intent Optional Attributes Name type( sdr_subresolution_type ), intent(out) :: subres The subresolution data structure to fill. type( flu_State ) :: conf Handle to the Lua configuration script. integer, intent(in), optional :: parent Handle to a possible parent table. Calls proc~~sdr_subresolution_load~~CallsGraph proc~sdr_subresolution_load sdr_subresolution_load aot_get_val aot_get_val proc~sdr_subresolution_load->aot_get_val aot_table_close aot_table_close proc~sdr_subresolution_load->aot_table_close aot_table_open aot_table_open proc~sdr_subresolution_load->aot_table_open ply_prj_init_define ply_prj_init_define proc~sdr_subresolution_load->ply_prj_init_define proc~ply_prj_header_load ply_prj_header_load proc~sdr_subresolution_load->proc~ply_prj_header_load proc~sdr_subres_fills_load sdr_subres_fills_load proc~sdr_subresolution_load->proc~sdr_subres_fills_load proc~subres_load_color_defaults subres_load_color_defaults proc~sdr_subresolution_load->proc~subres_load_color_defaults tem_abort tem_abort proc~sdr_subresolution_load->tem_abort upper_to_lower upper_to_lower proc~sdr_subresolution_load->upper_to_lower proc~ply_prj_header_load->aot_get_val proc~ply_prj_header_load->tem_abort proc~ply_prj_header_load->upper_to_lower proc~ply_fpt_header_display ply_fpt_header_display proc~ply_prj_header_load->proc~ply_fpt_header_display proc~ply_fpt_header_load ply_fpt_header_load proc~ply_prj_header_load->proc~ply_fpt_header_load proc~ply_fxt_header_display ply_fxt_header_display proc~ply_prj_header_load->proc~ply_fxt_header_display proc~ply_fxt_header_load ply_fxt_header_load proc~ply_prj_header_load->proc~ply_fxt_header_load proc~ply_l2p_header_display ply_l2p_header_display proc~ply_prj_header_load->proc~ply_l2p_header_display proc~ply_l2p_header_load ply_l2p_header_load proc~ply_prj_header_load->proc~ply_l2p_header_load proc~sdr_subres_fills_load->aot_table_open aot_table_length aot_table_length proc~sdr_subres_fills_load->aot_table_length init init proc~sdr_subres_fills_load->init proc~load_single_fill load_single_fill proc~sdr_subres_fills_load->proc~load_single_fill proc~subres_load_color_defaults->aot_get_val proc~subres_load_color_defaults->aot_table_close proc~subres_load_color_defaults->aot_table_open proc~subres_load_color_defaults->tem_abort proc~subres_load_color_defaults->upper_to_lower proc~subres_load_color_defaults->aot_table_length append append proc~subres_load_color_defaults->append proc~subres_load_color_defaults->init proc~load_single_fill->aot_get_val proc~load_single_fill->aot_table_close proc~load_single_fill->aot_table_open proc~load_single_fill->tem_abort proc~sdr_subres_fills_add sdr_subres_fills_add proc~load_single_fill->proc~sdr_subres_fills_add proc~ply_fpt_header_load->aot_get_val proc~ply_fpt_header_load->tem_abort proc~ply_fpt_header_load->upper_to_lower proc~ply_fxt_header_load->aot_get_val proc~ply_fxt_header_load->tem_abort proc~ply_l2p_header_load->aot_get_val proc~ply_l2p_header_load->tem_abort proc~ply_l2p_header_load->upper_to_lower proc~sdr_subres_fills_add->upper_to_lower proc~sdr_subres_fills_add->append Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_subresolution_load~~CalledByGraph proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_subresolution_load.html"},{"title":"subres_load_color_defaults – Seeder","text":"public  subroutine subres_load_color_defaults(label, conf, parent) Internal subroutine to load the list of colors, which by default should\napply subelement resolution to its boundaries. This list is provided in the subresolution table by:\n\\code{.lua}\ndefault_colors = { 'colA', 'colB' }\n\\endcode\nThis table is read by this routine. Arguments Type Intent Optional Attributes Name type( dyn_labelarray_type ), intent(out) :: label Labels of the colors, for which a default setting is given. type( flu_State ) :: conf Handle for the Lua script. integer, intent(in) :: parent Parent table, within which to open the color_default table. Calls proc~~subres_load_color_defaults~~CallsGraph proc~subres_load_color_defaults subres_load_color_defaults aot_get_val aot_get_val proc~subres_load_color_defaults->aot_get_val aot_table_close aot_table_close proc~subres_load_color_defaults->aot_table_close aot_table_length aot_table_length proc~subres_load_color_defaults->aot_table_length aot_table_open aot_table_open proc~subres_load_color_defaults->aot_table_open append append proc~subres_load_color_defaults->append init init proc~subres_load_color_defaults->init tem_abort tem_abort proc~subres_load_color_defaults->tem_abort upper_to_lower upper_to_lower proc~subres_load_color_defaults->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~subres_load_color_defaults~~CalledByGraph proc~subres_load_color_defaults subres_load_color_defaults proc~sdr_subresolution_load sdr_subresolution_load proc~sdr_subresolution_load->proc~subres_load_color_defaults proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_load program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/subres_load_color_defaults.html"},{"title":"sdr_subresolution_encolor – Seeder","text":"public  subroutine sdr_subresolution_encolor(me, colors) Find the value definitions for all unique colors. Arguments Type Intent Optional Attributes Name type( sdr_subresolution_type ), intent(inout) :: me type( dyn_labelarray_type ), intent(in) :: colors Calls proc~~sdr_subresolution_encolor~~CallsGraph proc~sdr_subresolution_encolor sdr_subresolution_encolor proc~sdr_subres_fills_add sdr_subres_fills_add proc~sdr_subresolution_encolor->proc~sdr_subres_fills_add append append proc~sdr_subres_fills_add->append upper_to_lower upper_to_lower proc~sdr_subres_fills_add->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sdr_subresolution_encolor~~CalledByGraph proc~sdr_subresolution_encolor sdr_subresolution_encolor proc~sdr_load_config sdr_load_config proc~sdr_load_config->proc~sdr_subresolution_encolor program~seeder seeder program~seeder->proc~sdr_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sdr_subresolution_encolor.html"},{"title":"sdr_ellipsoid_module – Seeder","text":"This module contain adapter routine to load ellipsoid objects and add them to\nlist of spatial objects Uses tem_logging_module aot_table_module env_module tem_ellipsoid_module aotus_module tem_aux_module sdr_spatialObj_module tem_transformation_module module~~sdr_ellipsoid_module~~UsesGraph module~sdr_ellipsoid_module sdr_ellipsoid_module aot_table_module aot_table_module module~sdr_ellipsoid_module->aot_table_module aotus_module aotus_module module~sdr_ellipsoid_module->aotus_module env_module env_module module~sdr_ellipsoid_module->env_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_ellipsoid_module->sdr_spatialObj_module tem_aux_module tem_aux_module module~sdr_ellipsoid_module->tem_aux_module tem_ellipsoid_module tem_ellipsoid_module module~sdr_ellipsoid_module->tem_ellipsoid_module tem_logging_module tem_logging_module module~sdr_ellipsoid_module->tem_logging_module tem_transformation_module tem_transformation_module module~sdr_ellipsoid_module->tem_transformation_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_ellipsoid_module~~UsedByGraph module~sdr_ellipsoid_module sdr_ellipsoid_module module~sdr_geometry_module sdr_geometry_module module~sdr_geometry_module->module~sdr_ellipsoid_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_geometry_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_geometry_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_load_ellipsoid (sphArray, spaObjArray, attr_pos, transform, conf, thandle) Load ellipsoid information from config file. Arguments Type Intent Optional Attributes Name type( grw_ellipsoidarray_type ), intent(inout) :: sphArray growing array of ellipsoids type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle","tags":"","url":"module/sdr_ellipsoid_module.html"},{"title":"ply_l2p_header_module – Seeder","text":"Parameters for the plain L2 projection method to transform between Legendre\n modes and nodal representation. This method utilizes the L2 projection from Legendre to Lagrange polynomials\n or the other way around. A numerical Gauss-Legendre Quadrature is used to\n compute the integral over the product of both functions.\n The Lagrange polynomials can be defined on any nodeset, see also ply_nodeset_module . Available options for the nodes to project onto are: 'gauss-legendre' these are the Gauss-Legendre integration points that\n   are also used for the numerical integration (this is the default). 'chebyshev' these are the nodes from the Chebyshev integration. The set of nodes to use is configured by the nodes_kind option, and if nodes_kind = 'chebyshev' it is also possible to make use of Lobatto points\n to include the interval boundaries in the nodal representation.\n This is achieved by setting lobattoPoints = true , by default this is false. The configuration table for a projection with L2P may, for example, look as\n follows: projection = { kind = 'l2p' , factor = 1.5 , nodes_kind = 'chebyshev' , lobattoPoints = true } The example illustrates the three possible settings for the L2P\n transformation method: factor - Oversampling factor to avoid aliasing. nodes_kind - Selection of set of nodes to use in the nodal\n   representation. lobattoPoints - Whether to include interval bounds, only\n   available for Chebyshev nodes. Uses tem_tools_module aot_out_module tem_float_module tem_logging_module env_module aotus_module tem_aux_module ply_nodes_header_module module~~ply_l2p_header_module~~UsesGraph module~ply_l2p_header_module ply_l2p_header_module aot_out_module aot_out_module module~ply_l2p_header_module->aot_out_module aotus_module aotus_module module~ply_l2p_header_module->aotus_module env_module env_module module~ply_l2p_header_module->env_module module~ply_nodes_header_module ply_nodes_header_module module~ply_l2p_header_module->module~ply_nodes_header_module tem_aux_module tem_aux_module module~ply_l2p_header_module->tem_aux_module tem_float_module tem_float_module module~ply_l2p_header_module->tem_float_module tem_logging_module tem_logging_module module~ply_l2p_header_module->tem_logging_module tem_tools_module tem_tools_module module~ply_l2p_header_module->tem_tools_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_l2p_header_module~~UsedByGraph module~ply_l2p_header_module ply_l2p_header_module module~ply_l2p_module ply_l2p_module module~ply_l2p_module->module~ply_l2p_header_module module~ply_prj_header_module ply_prj_header_module module~ply_prj_header_module->module~ply_l2p_header_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~ply_prj_header_module module~sdr_config_module sdr_config_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_subresolution_module sdr_subresolution_module module~sdr_subresolution_module->module~ply_prj_header_module module~sdr_config_module->module~sdr_subresolution_module program~seeder seeder program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_config_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assignment(=) private pure subroutine Copy_l2p_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: left fpt to copy to type( ply_l2p_header_type ), intent(in) :: right fpt to copy from public        interface operator(==) private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Two l2p header are considered to be equal, if their node_header,\nand the factor are equal. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? public        interface operator(/=) private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Two l2p header are considered to be unequal, if their node_header,\nor the factor are not equal. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? public        interface operator(<) private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Sorting of l2p header is given by node_header and by the factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(<=) private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Sorting of l2p header is given by node_header, l2p_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(>) private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Sorting of l2p header is given by node_header, l2p_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? public        interface operator(>=) private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Sorting of l2p header is given by node_header, l2p_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Derived Types type, public :: ply_l2p_header_type l2p projection header type, consisting of the node header which give\ninformation about the type and number of points for the projection Components Type Visibility Attributes Name Initial type( ply_nodes_header_type ), public :: nodes_header real(kind=rk), public :: factor Functions private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: left projection to compare type( ply_l2p_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Subroutines public  subroutine ply_l2p_header_load (me, conf, thandle) Load settings to describe a projection method from a Lua table. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: me type( flu_State ), intent(inout) :: conf integer, intent(in) :: thandle public  subroutine ply_l2p_header_define (me, factor, nodes_kind, lobattoPoints) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: me L2P header to define. integer, intent(in), optional :: factor Oversampling factor to use in the projection, defaults to 1. character(len=*), optional :: nodes_kind Set of nodes to use in the nodal representation. Read more… logical, intent(in), optional :: lobattoPoints Wether to use Lobatto points (include interval bounds) when using the\nchebyshev nodes, defaults to .false.. public  subroutine ply_l2p_header_out (me, conf) Write L2P settings into a Lua table. Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: me type( aot_out_type ), intent(inout) :: conf public  subroutine ply_l2p_header_display (me) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(in) :: me private pure subroutine Copy_l2p_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_header_type ), intent(out) :: left fpt to copy to type( ply_l2p_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"module/ply_l2p_header_module.html"},{"title":"sdr_sphere_module – Seeder","text":"This module contain adapter routine to load sphere objects and add them to\nlist of spatial objects Uses tem_logging_module tem_sphere_module aot_table_module env_module aotus_module tem_aux_module sdr_spatialObj_module tem_transformation_module module~~sdr_sphere_module~~UsesGraph module~sdr_sphere_module sdr_sphere_module aot_table_module aot_table_module module~sdr_sphere_module->aot_table_module aotus_module aotus_module module~sdr_sphere_module->aotus_module env_module env_module module~sdr_sphere_module->env_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_sphere_module->sdr_spatialObj_module tem_aux_module tem_aux_module module~sdr_sphere_module->tem_aux_module tem_logging_module tem_logging_module module~sdr_sphere_module->tem_logging_module tem_sphere_module tem_sphere_module module~sdr_sphere_module->tem_sphere_module tem_transformation_module tem_transformation_module module~sdr_sphere_module->tem_transformation_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_sphere_module~~UsedByGraph module~sdr_sphere_module sdr_sphere_module module~sdr_geometry_module sdr_geometry_module module~sdr_geometry_module->module~sdr_sphere_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_geometry_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_geometry_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_load_sphere (sphArray, spaObjArray, attr_pos, transform, conf, thandle) Load sphere information from config file. Arguments Type Intent Optional Attributes Name type( grw_spherearray_type ), intent(inout) :: sphArray growing array of spheres type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle","tags":"","url":"module/sdr_sphere_module.html"},{"title":"sdr_protoTree_module – Seeder","text":"This module provides the description of the evolving tree, as it is built\nup to match the given geometry. The concept used here, is a proposal for an algorithm, following a\nlevel-wise iterative approach instead of an recursive one.\nThis is better suited for parallel processing.\nAlso it tries to follow more closely the principals from tem_construction\nand the solver layout.\nThat is, treating seeder more like a solver in itself. For flooding a concept of wet sides on coarser levels is used, all elements\nneed to track just a single neighbor in each direction in this case.\nAnd the coarse ghost elements take care of flooding their children\naccordingly themselves. Uses tem_param_module tem_topology_module sdr_attribute_module iso_c_binding tem_aux_module tem_cube_module tem_varMap_module tem_dyn_array_module tem_tools_module tem_solveHead_module env_module sdr_config_module sdr_spatialObj_module sdr_geometry_module tem_logging_module tem_time_module tem_timer_module treelmesh_module tem_restart_module tem_varSys_module tem_grow_array_module tem_debug_module sdr_protoData_module tem_global_module sdr_timer_module sdr_node_module module~~sdr_prototree_module~~UsesGraph module~sdr_prototree_module sdr_protoTree_module env_module env_module module~sdr_prototree_module->env_module iso_c_binding iso_c_binding module~sdr_prototree_module->iso_c_binding module~sdr_config_module sdr_config_module module~sdr_prototree_module->module~sdr_config_module module~sdr_geometry_module sdr_geometry_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_timer_module sdr_timer_module module~sdr_prototree_module->module~sdr_timer_module sdr_attribute_module sdr_attribute_module module~sdr_prototree_module->sdr_attribute_module sdr_node_module sdr_node_module module~sdr_prototree_module->sdr_node_module sdr_protoData_module sdr_protoData_module module~sdr_prototree_module->sdr_protoData_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_prototree_module->sdr_spatialObj_module tem_aux_module tem_aux_module module~sdr_prototree_module->tem_aux_module tem_cube_module tem_cube_module module~sdr_prototree_module->tem_cube_module tem_debug_module tem_debug_module module~sdr_prototree_module->tem_debug_module tem_dyn_array_module tem_dyn_array_module module~sdr_prototree_module->tem_dyn_array_module tem_global_module tem_global_module module~sdr_prototree_module->tem_global_module tem_grow_array_module tem_grow_array_module module~sdr_prototree_module->tem_grow_array_module tem_logging_module tem_logging_module module~sdr_prototree_module->tem_logging_module tem_param_module tem_param_module module~sdr_prototree_module->tem_param_module tem_restart_module tem_restart_module module~sdr_prototree_module->tem_restart_module tem_solveHead_module tem_solveHead_module module~sdr_prototree_module->tem_solveHead_module tem_time_module tem_time_module module~sdr_prototree_module->tem_time_module tem_timer_module tem_timer_module module~sdr_prototree_module->tem_timer_module tem_tools_module tem_tools_module module~sdr_prototree_module->tem_tools_module tem_topology_module tem_topology_module module~sdr_prototree_module->tem_topology_module tem_varMap_module tem_varMap_module module~sdr_prototree_module->tem_varMap_module tem_varSys_module tem_varSys_module module~sdr_prototree_module->tem_varSys_module treelmesh_module treelmesh_module module~sdr_prototree_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_prototree_module~~UsedByGraph module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_prototree_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_protoTree_type The protoTree is used to describe the preliminary tree, before it\nis actually extended to the full information of the mesh. Read more… Components Type Visibility Attributes Name Initial integer, public :: nLevels Keep track of the deepest level in the tree. integer, public :: nLeafNodes Number of leaf nodes. integer, public :: nFloodedLeaves Number of flooded leaves. type(sdr_node_type), public :: node List of all nodes in the tree, each node contains a list of the\nobjects it is intersecting and a property bit mask.\nIt is identified by its treeID. Read more… integer, public :: levelNode_first (0:globalMaxLevels) The index of the first node on a given level in node%treeID%sorted. integer, public :: levelNode_last (0:globalMaxLevels) The index of the last node on a given level in node%treeID%sorted. type( grw_intarray_type ), public :: child_intersected_object Temporary array intersected objects of 8 children which will later\nbe copied to intersected_object in node_type. Read more… type, public :: levelValues_type Auxilary data type to provide data on the current level iteration. Components Type Visibility Attributes Name Initial integer(kind=long_k), public :: ID_offset First treeID on current level real(kind=rk), public :: dx Node cube length on current level integer, public :: level Number of the level itself. Functions public  function sdr_node_neighbors (me, level_offset, iNode, coord) result(neighbors) This routine identifies the 6 direct neighbors of a node in the prototree Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: me neighbors are identified for this tree and neighbor of each node\nare stored at link_pos of each node in node_data type integer(kind=long_k), intent(in), optional :: level_offset First treeID on level integer, intent(in) :: iNode Node position in protoTree integer, intent(in), optional :: coord (4) if coord is present, no need to compute using tem_coordOfID Return Value integer, (6) public  function sdr_neighbor_in_proto (proto, coord, iDir, neighbor_level) result(pos) Find the neighbor position in protoTree for iDir on the same level \nor on any one above. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree integer, intent(in) :: coord (4) integer, intent(in) :: iDir integer, intent(out) :: neighbor_level Return Value integer private  function protoData_ofNode (node_pos, proto, geometry, level) result(protodata) Small helping routine to get the variable data from a leaf. Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos type( sdr_protoTree_type ), intent(in) :: proto type( sdr_geometry_type ), intent(in) :: geometry integer, intent(in) :: level Return Value real(kind=rk), (11+proto%node%nColors) Subroutines public  subroutine sdr_build_protoTree (me, geometry, header) This routine builds the preliminary tree with geometry intersection and\nneighbor identification Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(out) :: me preliminary tree created by this routine type( sdr_geometry_type ), intent(inout) :: geometry type which contains all geometry object infos type( sdr_confHead_type ), intent(inout) :: header some global information on solver name and version public  subroutine sdr_write_proto_as_restart (proto, geometry, itime, header, prefix) Write current leaves of the prototree as treelm restart. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto The prototree to output. type( sdr_geometry_type ), intent(in) :: geometry Bounding cube, the prototree lives in. integer, intent(in) :: itime wave number in character format to prepend to filenames and timestamp type( sdr_confHead_type ), intent(in) :: header some global information on solver name and version character(len=*), intent(in), optional :: prefix prefix for filenames private  subroutine create_children (me, parent, geometry, leVal, testAll, minlevel) This routine creates children for each parent if children\n intersect with boundary object. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: me preliminary tree on which childern are created integer, intent(in) :: parent Position of parent node on the growing array of node_treeID and node_data\nin preliminary tree type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos type( levelValues_type ), intent(in) :: leVal contains information on current level on which children are created logical, intent(in) :: testAll testAll objects only for root node integer, intent(in) :: minlevel private  subroutine mark_leafNode (me, node_pos) Small helping routine to keep track of leaf nodes. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: me Property bit mask to set the leaf bit in integer, intent(in) :: node_pos private  subroutine sdr_mark_neighborHasBnd (proto, coord) This routine marks 26 direct neighbors as has boundary bit Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto neighbors are identified for this tree and neighbors\nas marked with hasBoundary_bit integer, intent(in) :: coord (4) Coordinate of current node private recursive subroutine write_childLeaves (meshunit, restunit, iLeaf, node_pos, proto, geometry, level) Small helping routine to write leaves in order into a treelmesh formatted\nfile. Arguments Type Intent Optional Attributes Name integer, intent(in) :: meshunit integer, intent(in) :: restunit integer, intent(inout) :: iLeaf integer, intent(in) :: node_pos type( sdr_protoTree_type ), intent(in) :: proto type( sdr_geometry_type ), intent(in) :: geometry integer, intent(in) :: level","tags":"","url":"module/sdr_prototree_module.html"},{"title":"ply_sampling_adaptive_module – Seeder","text":"Adaptive sampling of polynomial data. This module implements the sampling of polynomials with data dependent\nrefinement.\nElements, where the polynomials vary above a certain threshold, will be\nsplit into their eight children and the polynomial data will be projected\nonto those.\nThe polynomials in the children can be restricted in their order to limit\nthe memory consumption.\nIn the end only one degree of freedom will be returned for each (refined)\nelement, these are always the mean of the solution in those (refined)\nelements. The module provides a data type to describe the configuration of the\nadaptive sampling: ply_sampling_adaptive_type ,\none routine to load this configuration ply_sampling_adaptive_load and\none routine to actually perform the adaptive sampling ply_sample_adaptive . Uses tem_topology_module mpi iso_c_binding tem_aux_module ply_filter_element_module tem_tools_module env_module ply_split_element_module tem_refining_module tem_bc_prop_module tem_logging_module tem_time_module tem_subTree_module treelmesh_module aotus_module ply_sampling_varsys_module tem_varSys_module tem_subTree_type_module tem_tracking_module module~~ply_sampling_adaptive_module~~UsesGraph module~ply_sampling_adaptive_module ply_sampling_adaptive_module aotus_module aotus_module module~ply_sampling_adaptive_module->aotus_module env_module env_module module~ply_sampling_adaptive_module->env_module iso_c_binding iso_c_binding module~ply_sampling_adaptive_module->iso_c_binding module~ply_filter_element_module ply_filter_element_module module~ply_sampling_adaptive_module->module~ply_filter_element_module module~ply_sampling_varsys_module ply_sampling_varsys_module module~ply_sampling_adaptive_module->module~ply_sampling_varsys_module module~ply_split_element_module ply_split_element_module module~ply_sampling_adaptive_module->module~ply_split_element_module mpi mpi module~ply_sampling_adaptive_module->mpi tem_aux_module tem_aux_module module~ply_sampling_adaptive_module->tem_aux_module tem_bc_prop_module tem_bc_prop_module module~ply_sampling_adaptive_module->tem_bc_prop_module tem_logging_module tem_logging_module module~ply_sampling_adaptive_module->tem_logging_module tem_refining_module tem_refining_module module~ply_sampling_adaptive_module->tem_refining_module tem_subTree_module tem_subTree_module module~ply_sampling_adaptive_module->tem_subTree_module tem_subTree_type_module tem_subTree_type_module module~ply_sampling_adaptive_module->tem_subTree_type_module tem_time_module tem_time_module module~ply_sampling_adaptive_module->tem_time_module tem_tools_module tem_tools_module module~ply_sampling_adaptive_module->tem_tools_module tem_topology_module tem_topology_module module~ply_sampling_adaptive_module->tem_topology_module tem_tracking_module tem_tracking_module module~ply_sampling_adaptive_module->tem_tracking_module tem_varSys_module tem_varSys_module module~ply_sampling_adaptive_module->tem_varSys_module treelmesh_module treelmesh_module module~ply_sampling_adaptive_module->treelmesh_module module~ply_filter_element_module->aotus_module module~ply_filter_element_module->env_module module~ply_filter_element_module->tem_aux_module module~ply_filter_element_module->tem_logging_module module~ply_filter_element_module->tem_tools_module aot_err_module aot_err_module module~ply_filter_element_module->aot_err_module aot_table_module aot_table_module module~ply_filter_element_module->aot_table_module module~ply_sampling_varsys_module->env_module module~ply_sampling_varsys_module->tem_time_module module~ply_sampling_varsys_module->tem_topology_module module~ply_sampling_varsys_module->tem_tracking_module module~ply_sampling_varsys_module->tem_varSys_module module~ply_sampling_varsys_module->treelmesh_module module~ply_split_element_module->env_module module~ply_split_legendre_module ply_split_legendre_module module~ply_split_element_module->module~ply_split_legendre_module ply_modg_basis_module ply_modg_basis_module module~ply_split_element_module->ply_modg_basis_module module~ply_split_legendre_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: redux_factor = 1 Constant to indicate the factor reduction mode. integer, private, parameter :: redux_decrement = 2 Constant to indicate the decrement reduction mode. Derived Types type, public :: ply_sampling_adaptive_type Configuration of the adaptive sampling. Read more… Components Type Visibility Attributes Name Initial integer, public :: max_nlevels = 0 Maximal number of levels by which any mesh element should be refined. Read more… real(kind=rk), public :: eps_osci Maximum allowed oscillation of the solution.\nFor adaptive subsampling only. integer, public :: reduction_mode Method to use for the reduction. Read more… logical, public :: ignore_highmodes = .false. Indication whether to filter modes during refinement by ignoring\nall modes in the parent, that exceed the target polynomial degree\nof the child elements. Read more… integer, public :: dof_decrement = 1 Number of modes to cut off in each refinement. Read more… real(kind=rk), public :: dofReducFactor Factor to Reduce dofs for every sampling level.\nCan be used to avoid too drastic increase of memory consumption.\nFor adaptive subsampling only. logical, public :: adaptiveDofReduction Indicator for the limitation of memory consumption. integer, public :: AbsUpperBoundLevel Absolute upper bound level to refine to. type( ply_filter_element_type ), public :: filter_element Filtering the poylnomial modes during adaptive refinement. Read more… type, private :: realarray_type Small helping type to allow arrays of arrays for the variable data. Components Type Visibility Attributes Name Initial real(kind=rk), public, pointer :: dat (:) => NULL() type, private :: sampled_method_data_type A container for the method data to hold the data in a scalar pointer for\nthe C-pointer conversion. Components Type Visibility Attributes Name Initial type( realarray_type ), public, allocatable :: component (:) Subroutines public  subroutine ply_sampling_adaptive_load (me, conf, parent) Load the configuration for adaptive subsampling. Arguments Type Intent Optional Attributes Name type( ply_sampling_adaptive_type ), intent(out) :: me Sampling definition to load. type( flu_State ), intent(in) :: conf Configuration to read the sampling settings from. integer, intent(in), optional :: parent Parent table in which to look for the adaptive sampling settings. public  subroutine ply_sample_adaptive (me, ndims, orig_mesh, orig_bcs, varsys, var_degree, lvl_degree, trackInst, trackConfig, time, new_mesh, resvars) Sample data described by varsys in orig_mesh according to the tracking\nobject trackInst with adaptive refinements. Read more… Arguments Type Intent Optional Attributes Name type( ply_sampling_adaptive_type ), intent(in) :: me A ply_sampling_type to describe the sampling method. integer, intent(in) :: ndims Number of dimensions in the polynomial representation. type( treelmesh_type ), intent(in) :: orig_mesh The original mesh to be refined. type( tem_BC_prop_type ), intent(in) :: orig_bcs Boundary conditions for the original mesh. type( tem_varSys_type ), intent(in) :: varsys Variable system of the original data to do the sampling on. integer, intent(in) :: var_degree (:) Maximal polynomial degree for each variable. Read more… integer, intent(in) :: lvl_degree (:) Maximal polynomial degree for each level. type( tem_tracking_instance_type ), intent(in) :: trackInst Tracking object describing what to sample. type( tem_tracking_config_type ), intent(in) :: trackConfig Tracking configuration with the geometry to obtain from the overall mesh. type( tem_time_type ), intent(in) :: time Point in time to get the data for. type( treelmesh_type ), intent(out) :: new_mesh The new mesh with the refined elements. type( tem_varSys_type ), intent(out) :: resvars Resulting system of variables describing the data in the arrays of\nsubsampled elements. private  subroutine get_sampled_element (fun, varSys, elempos, time, tree, n, nDofs, res) Get sampled data. Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) TreeID of the element to get the variable for. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: n Number of elements to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more…","tags":"","url":"module/ply_sampling_adaptive_module.html"},{"title":"sdr_canonicalND_module – Seeder","text":"This module provides the routine to load canonical geometrical objects \nto growing array of geometries and their positions in growing array in\ngrowing array of spatialObj Uses tem_tools_module tem_line_module tem_plane_module tem_box_module flu_binding env_module aot_table_module tem_triangle_module tem_point_module tem_canonicalND_module aotus_module sdr_spatialObj_module tem_transformation_module module~~sdr_canonicalnd_module~~UsesGraph module~sdr_canonicalnd_module sdr_canonicalND_module aot_table_module aot_table_module module~sdr_canonicalnd_module->aot_table_module aotus_module aotus_module module~sdr_canonicalnd_module->aotus_module env_module env_module module~sdr_canonicalnd_module->env_module flu_binding flu_binding module~sdr_canonicalnd_module->flu_binding sdr_spatialObj_module sdr_spatialObj_module module~sdr_canonicalnd_module->sdr_spatialObj_module tem_box_module tem_box_module module~sdr_canonicalnd_module->tem_box_module tem_canonicalND_module tem_canonicalND_module module~sdr_canonicalnd_module->tem_canonicalND_module tem_line_module tem_line_module module~sdr_canonicalnd_module->tem_line_module tem_plane_module tem_plane_module module~sdr_canonicalnd_module->tem_plane_module tem_point_module tem_point_module module~sdr_canonicalnd_module->tem_point_module tem_tools_module tem_tools_module module~sdr_canonicalnd_module->tem_tools_module tem_transformation_module tem_transformation_module module~sdr_canonicalnd_module->tem_transformation_module tem_triangle_module tem_triangle_module module~sdr_canonicalnd_module->tem_triangle_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_canonicalnd_module~~UsedByGraph module~sdr_canonicalnd_module sdr_canonicalND_module module~sdr_geometry_module sdr_geometry_module module~sdr_geometry_module->module~sdr_canonicalnd_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_geometry_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_geometry_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_load_canonicalND (pntArray, lineArray, triArray, boxArray, spaObjArray, attr_pos, transform, conf, thandle) This routine loads canonical geometrial objects like point, line, plane \nand box and add them to the growing array of each primitive geometries\nand the position of this geometries are stored in the growing array\nof spatialObject Arguments Type Intent Optional Attributes Name type( grw_pointarray_type ), intent(inout) :: pntArray growing array of points type( grw_linearray_type ), intent(inout) :: lineArray growing array of line type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type( grw_boxarray_type ), intent(inout) :: boxArray growing array of boxes type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle public  subroutine append_CanoNDPointToSdrPoint (canopoint, pntArray, spaObjArray, attr_pos) This routine convert canonical point to seeder point array Arguments Type Intent Optional Attributes Name type( tem_point_type ), intent(in) :: canopoint canonical point object type type( grw_pointarray_type ), intent(inout) :: pntArray growing array of points type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type public  subroutine append_CanoNDLineToSdrLine (canoline, lineArray, spaObjArray, attr_pos) This routine convert canonical line to seeder line array Arguments Type Intent Optional Attributes Name type( tem_line_type ), intent(in) :: canoline canonical geometry line object type type( grw_linearray_type ), intent(inout) :: lineArray growing array of line type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type public  subroutine append_CanoNDBoxToTriangle (canoBox, triArray, spaObjArray, attr_pos) This routine convert box to planes and then planes to triangles\nand add triangle to growing array and add position of triangle into \nspatialObj%primitive_position Arguments Type Intent Optional Attributes Name type( tem_box_type ), intent(in) :: canoBox canonical geometry box object type type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type public  subroutine append_CanoNDPlaneToTriangle (plane, triArray, spaObjArray, attr_pos) This routine convert plane to triangle and add triangle to \ngrowing array and add position of triangle into \nspatialObj%primitive_position Arguments Type Intent Optional Attributes Name type( tem_plane_type ), intent(in) :: plane canonical plane geometry object type type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type public  subroutine append_CanoNDBoxToSdrBox (canobox, boxArray, spaObjArray, attr_pos) This routine convert plane to triangle and add triangle to \ngrowing array and add position of triangle into \nspatialObj%primitive_position Arguments Type Intent Optional Attributes Name type( tem_box_type ), intent(in) :: canobox canonical geometry object type type( grw_boxarray_type ), intent(inout) :: boxArray growing array of boxes type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos spatial object type","tags":"","url":"module/sdr_canonicalnd_module.html"},{"title":"sdr_config_module – Seeder","text":"This module provides the configuration of the mesh generation. Uses tem_tools_module tem_dyn_array_module sdr_geometry_module flu_binding tem_logging_module aot_table_module env_module tem_debug_module tem_timer_module tem_comm_module sdr_subresolution_module aotus_module sdr_attribute_module sdr_timer_module tem_aux_module tem_general_module module~~sdr_config_module~~UsesGraph module~sdr_config_module sdr_config_module aot_table_module aot_table_module module~sdr_config_module->aot_table_module aotus_module aotus_module module~sdr_config_module->aotus_module env_module env_module module~sdr_config_module->env_module flu_binding flu_binding module~sdr_config_module->flu_binding module~sdr_geometry_module sdr_geometry_module module~sdr_config_module->module~sdr_geometry_module module~sdr_subresolution_module sdr_subresolution_module module~sdr_config_module->module~sdr_subresolution_module module~sdr_timer_module sdr_timer_module module~sdr_config_module->module~sdr_timer_module sdr_attribute_module sdr_attribute_module module~sdr_config_module->sdr_attribute_module tem_aux_module tem_aux_module module~sdr_config_module->tem_aux_module tem_comm_module tem_comm_module module~sdr_config_module->tem_comm_module tem_debug_module tem_debug_module module~sdr_config_module->tem_debug_module tem_dyn_array_module tem_dyn_array_module module~sdr_config_module->tem_dyn_array_module tem_general_module tem_general_module module~sdr_config_module->tem_general_module tem_logging_module tem_logging_module module~sdr_config_module->tem_logging_module tem_timer_module tem_timer_module module~sdr_config_module->tem_timer_module tem_tools_module tem_tools_module module~sdr_config_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_config_module~~UsedByGraph module~sdr_config_module sdr_config_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_boundary_module sdr_boundary_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module module~sdr_boundary_module->module~sdr_prototree_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_confHead_type This type contains basic information loaded from the config file. Components Type Visibility Attributes Name Initial character(len=PathLen), public :: comment character(len=PathLen), public :: folder integer, public :: minlevel type( tem_general_type ), public :: general type( sdr_subresolution_type ), public :: subresolution Information on resolution of boundaries within elements using\npolynomials. type( dyn_labelarray_type ), public :: inverted_colors List of colors to invert. Read more… Subroutines public  subroutine sdr_load_config (me, geometry) Load the configuration from the Lua script provided on the command line\nor from seeder.lua by default, if no file name is given as program\nargument. Read more… Arguments Type Intent Optional Attributes Name type( sdr_confHead_type ), intent(inout) :: me contains basic information from config file type( sdr_geometry_type ), intent(out) :: geometry contains all geometry object defined in the config file private  subroutine sdr_load_inverted (invlist, conf) Arguments Type Intent Optional Attributes Name type( dyn_labelarray_type ), intent(out) :: invlist List of labels for inverted colors. type( flu_State ) :: conf Lua script handle to read the inversion list from.","tags":"","url":"module/sdr_config_module.html"},{"title":"sdr_boundary_module – Seeder","text":"This module contains routines for boundary identification\n and qVal computation Todo HK: This module is utterly confusing, I do not really understand what\n          all this code is actually doing, and it is hard to parse it.\n          The module needs to be redesigned and cleaned up! Uses tem_param_module tem_plane_module tem_triangle_module tem_topology_module sdr_attribute_module tem_aux_module tem_cube_module tem_mergesort_module tem_dyn_array_module tem_line_module sdr_protoTree_module env_module tem_geometry_module tem_point_module sdr_spatialObj_module sdr_geometry_module tem_logging_module treelmesh_module sdr_periodic_module tem_grow_array_module tem_debug_module sdr_node_module module~~sdr_boundary_module~~UsesGraph module~sdr_boundary_module sdr_boundary_module env_module env_module module~sdr_boundary_module->env_module module~sdr_geometry_module sdr_geometry_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module sdr_attribute_module sdr_attribute_module module~sdr_boundary_module->sdr_attribute_module sdr_node_module sdr_node_module module~sdr_boundary_module->sdr_node_module sdr_periodic_module sdr_periodic_module module~sdr_boundary_module->sdr_periodic_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_boundary_module->sdr_spatialObj_module tem_aux_module tem_aux_module module~sdr_boundary_module->tem_aux_module tem_cube_module tem_cube_module module~sdr_boundary_module->tem_cube_module tem_debug_module tem_debug_module module~sdr_boundary_module->tem_debug_module tem_dyn_array_module tem_dyn_array_module module~sdr_boundary_module->tem_dyn_array_module tem_geometry_module tem_geometry_module module~sdr_boundary_module->tem_geometry_module tem_grow_array_module tem_grow_array_module module~sdr_boundary_module->tem_grow_array_module tem_line_module tem_line_module module~sdr_boundary_module->tem_line_module tem_logging_module tem_logging_module module~sdr_boundary_module->tem_logging_module tem_mergesort_module tem_mergesort_module module~sdr_boundary_module->tem_mergesort_module tem_param_module tem_param_module module~sdr_boundary_module->tem_param_module tem_plane_module tem_plane_module module~sdr_boundary_module->tem_plane_module tem_point_module tem_point_module module~sdr_boundary_module->tem_point_module tem_topology_module tem_topology_module module~sdr_boundary_module->tem_topology_module tem_triangle_module tem_triangle_module module~sdr_boundary_module->tem_triangle_module treelmesh_module treelmesh_module module~sdr_boundary_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_boundary_module~~UsedByGraph module~sdr_boundary_module sdr_boundary_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_boundary_module program~seeder seeder program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: sdr_qVal_no_intersection = -1._rk default qVal when no intersection Functions public  function needCalcQValByBCID (attribute, bcid) result(calc_qVal) This routine checks if a boundary need calc qVal for a given BCID\nIt is used in identify_boundary routine Arguments Type Intent Optional Attributes Name type(sdr_attrList_type), intent(in) :: attribute integer, intent(in) :: bcid Return Value logical public  function needFldDglByBCID (attribute, bcid) result(flood_diagonal) This routine checks if a boundary need flood periphery for diagonal\ndirections for a given BCID.\nIt is used in identify_boundary routine Arguments Type Intent Optional Attributes Name type(sdr_attrList_type), intent(in) :: attribute integer, intent(in) :: bcid Return Value logical private  function getTreeIDPosOfCoord (coordReal, mesh, minLevel, maxLevel, leafLevel, leafTreeID, proto) result(pos) This function returns the position of treeID of given coordReal in the\nthe given mesh\nStart from minLevel which is the level of neighbor and find the treeID\nwhich is a leaf in protoTree Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: coordReal (3) type( treelmesh_type ), intent(in) :: mesh Mesh contain geometry universe (bounding cube) info integer, intent(in) :: minLevel minlevel integer, intent(in) :: maxLevel maxlevel integer, intent(out) :: leafLevel level in which leaf node is found integer(kind=long_k), intent(inout) :: leafTreeID type( sdr_protoTree_type ), intent(in) :: proto preliminary tree Return Value integer position of treeID in proto tree private  function projectVecOnPlane (vecU, plane) result(res) This function project given vector on an given plane Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vecU (3) vector to project type( tem_plane_type ), intent(in) :: plane plane on which vecU will be projected Return Value real(kind=rk), (3) output projected value private  function getNormal (geometry, elemBary, node, node_pos, bcid) result(normal) Obtain the surface normal of the chosen boundary if the boundary has store_normal set. Otherwise a null vector is returned. Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(in) :: geometry real(kind=rk), intent(in) :: elemBary (3) type(sdr_node_type), intent(in) :: node integer, intent(in) :: node_pos integer, intent(in) :: bcid Return Value real(kind=rk), (3) Subroutines public  subroutine sdr_identify_boundary (node_pos, treeID, coord, leVal, proto, geometry, BC_ID, qVal, bc_normal, meshUniverse) This routine checks for boundary neighbors and level of the boundary\nnode Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree integer(kind=long_k), intent(in) :: treeID treeID of parent node integer, intent(in) :: coord (4) Coordinate of treeID type( levelValues_type ), intent(in) :: leVal level value of parent node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects integer(kind=long_k), intent(out) :: BC_ID (qQQQ) Boundary ID for all 26 neighbor directions real(kind=rk), intent(out) :: qVal (qQQQ) distance from boundary for all 26 neighbor directions real(kind=rk), intent(out) :: bc_normal (3) Wall normal pointing from the surface to the barycenter of the\nboundary element type( treelmesh_type ), intent(in) :: meshUniverse contains bounding cube information public  subroutine sdr_find_periodic_neighbor (elemBary, iDir, bc_ID, qVal, unKnownBnd, neighbor_pos, neighbor_level, leVal, proto, geometry, meshUniverse) This routine find the treeID on the opposite side neighbor of the\n periodic plane for current leaf node Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: elemBary (3) current element barycenter integer, intent(in) :: iDir Current boundary neighbor direction integer(kind=long_k), intent(inout) :: bc_ID treeiD of opposite neighbor with periodic plane real(kind=rk), intent(out) :: qVal distance from boundary for direction iDir Read more… logical, intent(inout) :: unKnownBnd Set to true if a neighbor with no property is encountered integer, intent(in) :: neighbor_pos position of neighbor treeID in the proto%node list integer, intent(in) :: neighbor_level level of the periodic boundary neighbor node type( levelValues_type ), intent(in) :: leVal level value of parent node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( treelmesh_type ), intent(in) :: meshUniverse contains bounding cube information public  subroutine sdr_qValByNode (proto, geometry, dx, iDir, origin, node_pos, qVal) This routine computes the minimum distance of a given link and all the\ngeometries in a given node:\\n\nthe link is given by a vector and a origin point.\\n\nthe node is given by the node position in the protoTree.\\n\nIf there is no intersection, qVal returns -1.0 Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects real(kind=rk), intent(in) :: dx dx of current level integer, intent(in) :: iDir Direction real(kind=rk), intent(in) :: origin (3) current element barycenter integer :: node_pos position of node to find the geometries real(kind=rk), intent(out) :: qVal distance from boundary for all 26 neighbor directions private  subroutine getBCID_and_calcQval (proto, geometry, elemBary, iDir, bndnode_pos, level, leVal, meshUniverse, BC_ID, minBCID, qVal, unKnownBnd) This routine gets minBCID of the given node position in the protoTree.\n If the minBcid is periodic then it bcID is set to treeID of fluid node\n on the opposite side of periodic plane.\n It also computes the qVal if calc_dist = true. If qVal = -1 then\n there is no intersection and if qVal > 1 then the geometry is intersected\n after the link distance. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects real(kind=rk), intent(in) :: elemBary (3) current element barycenter integer, intent(in) :: iDir Current boundary neighbor direction integer, intent(in) :: bndnode_pos position of node treeID in the proto%node list integer, intent(in) :: level level of the node type( levelValues_type ), intent(in) :: leVal level value of parent node type( treelmesh_type ), intent(in) :: meshUniverse contains bounding cube information integer(kind=long_k), intent(out) :: BC_ID Boundary ID for direction iDir integer(kind=long_k), intent(inout) :: minBCID minimum boundary id of current node before truncation real(kind=rk), intent(out) :: qVal distance from boundary for direction iDir logical, intent(inout) :: unKnownBnd Is true if a neighbor with no property is encountered private  subroutine sdr_truncate_qVal (proto, qVal, BCID, neighPos, treeID_periodic) This routine gives special treatment when qVal > 1.0 or qVal == -1.0\nfor flooded neighbor, treat it as normal fluid: clean BCID,\nset qVal to -1 (no itersection).\nfor non-flooded neighbor, treat it as high order wall: set qVal to 1 Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(in) :: proto preliminary tree real(kind=rk), intent(inout) :: qVal qValue integer(kind=long_k), intent(inout) :: BCID boundary id integer, intent(in) :: neighPos neighbor position in proto tree integer(kind=long_k), intent(in), optional :: treeID_periodic negative treeID of periodic domain","tags":"","url":"module/sdr_boundary_module.html"},{"title":"sdr_hvs_config_module – Seeder","text":"Harvesting configuration module for seeder. The configuration consists of the mesh to read and visualize, the output\ndefinition providing the format to write, data extraction via trackings\nand the configuration for the sampling of polynomials. Uses tem_bc_prop_module sdr_hvs_props_module flu_binding tem_color_prop_module tem_logging_module ply_sampled_tracking_module env_module tem_tracking_module tem_time_module tem_debug_module aotus_module treelmesh_module hvs_output_module tem_aux_module tem_restart_module tem_general_module tem_varSys_module module~~sdr_hvs_config_module~~UsesGraph module~sdr_hvs_config_module sdr_hvs_config_module aotus_module aotus_module module~sdr_hvs_config_module->aotus_module env_module env_module module~sdr_hvs_config_module->env_module flu_binding flu_binding module~sdr_hvs_config_module->flu_binding hvs_output_module hvs_output_module module~sdr_hvs_config_module->hvs_output_module module~ply_sampled_tracking_module ply_sampled_tracking_module module~sdr_hvs_config_module->module~ply_sampled_tracking_module module~sdr_hvs_props_module sdr_hvs_props_module module~sdr_hvs_config_module->module~sdr_hvs_props_module tem_aux_module tem_aux_module module~sdr_hvs_config_module->tem_aux_module tem_bc_prop_module tem_bc_prop_module module~sdr_hvs_config_module->tem_bc_prop_module tem_color_prop_module tem_color_prop_module module~sdr_hvs_config_module->tem_color_prop_module tem_debug_module tem_debug_module module~sdr_hvs_config_module->tem_debug_module tem_general_module tem_general_module module~sdr_hvs_config_module->tem_general_module tem_logging_module tem_logging_module module~sdr_hvs_config_module->tem_logging_module tem_restart_module tem_restart_module module~sdr_hvs_config_module->tem_restart_module tem_time_module tem_time_module module~sdr_hvs_config_module->tem_time_module tem_tracking_module tem_tracking_module module~sdr_hvs_config_module->tem_tracking_module tem_varSys_module tem_varSys_module module~sdr_hvs_config_module->tem_varSys_module treelmesh_module treelmesh_module module~sdr_hvs_config_module->treelmesh_module module~ply_sampled_tracking_module->aotus_module module~ply_sampled_tracking_module->env_module module~ply_sampled_tracking_module->hvs_output_module module~ply_sampled_tracking_module->tem_aux_module module~ply_sampled_tracking_module->tem_bc_prop_module module~ply_sampled_tracking_module->tem_logging_module module~ply_sampled_tracking_module->tem_time_module module~ply_sampled_tracking_module->tem_tracking_module module~ply_sampled_tracking_module->tem_varSys_module module~ply_sampled_tracking_module->treelmesh_module ply_sampling_module ply_sampling_module module~ply_sampled_tracking_module->ply_sampling_module tem_comm_env_module tem_comm_env_module module~ply_sampled_tracking_module->tem_comm_env_module tem_reduction_spatial_module tem_reduction_spatial_module module~ply_sampled_tracking_module->tem_reduction_spatial_module tem_simControl_module tem_simControl_module module~ply_sampled_tracking_module->tem_simControl_module tem_solveHead_module tem_solveHead_module module~ply_sampled_tracking_module->tem_solveHead_module tem_stencil_module tem_stencil_module module~ply_sampled_tracking_module->tem_stencil_module tem_varMap_module tem_varMap_module module~ply_sampled_tracking_module->tem_varMap_module module~sdr_hvs_props_module->env_module module~sdr_hvs_props_module->tem_bc_prop_module module~sdr_hvs_props_module->tem_color_prop_module module~sdr_hvs_props_module->tem_logging_module module~sdr_hvs_props_module->tem_time_module module~sdr_hvs_props_module->tem_varSys_module module~sdr_hvs_props_module->treelmesh_module iso_c_binding iso_c_binding module~sdr_hvs_props_module->iso_c_binding module~ply_subresolution_module ply_subresolution_module module~sdr_hvs_props_module->module~ply_subresolution_module ply_dof_module ply_dof_module module~sdr_hvs_props_module->ply_dof_module module~sdr_hvs_props_module->tem_comm_env_module module~ply_subresolution_module->aotus_module module~ply_subresolution_module->env_module module~ply_subresolution_module->tem_aux_module module~ply_subresolution_module->tem_color_prop_module module~ply_subresolution_module->tem_logging_module module~ply_subresolution_module->tem_time_module module~ply_subresolution_module->tem_varSys_module module~ply_subresolution_module->treelmesh_module module~ply_subresolution_module->iso_c_binding module~ply_subresolution_module->ply_dof_module module~ply_subresolution_module->tem_comm_env_module ply_transfer_module ply_transfer_module module~ply_subresolution_module->ply_transfer_module tem_subres_prop_module tem_subres_prop_module module~ply_subresolution_module->tem_subres_prop_module tem_tools_module tem_tools_module module~ply_subresolution_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_hvs_config_module~~UsedByGraph module~sdr_hvs_config_module sdr_hvs_config_module program~sdr_harvesting sdr_harvesting program~sdr_harvesting->module~sdr_hvs_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_hvs_config_type This datatype describes the various settings to load from the configuration\nfile. Components Type Visibility Attributes Name Initial character(len=pathLen), public :: prefix Location on disk to load the mesh data from. Read more… logical, public :: do_subsampling Indication on wether to do subsampling. Read more… type( ply_sampled_tracking_type ), public :: ply_sample_track Definition of trackings to extract only parts of the information. Read more… type( hvs_output_config_type ), public :: output Description of how the visualization output should be done. Subroutines public  subroutine sdr_hvs_config_load (me, mesh, property, varsys, general, restart, time) Read the configuration for the Seeder harvesting from a Lua script. Arguments Type Intent Optional Attributes Name type( sdr_hvs_config_type ), intent(out) :: me Seeder harvesting configuration to load type( treelmesh_type ), intent(out) :: mesh Treelm mesh description as obtained from the user configuration. type( sdr_hvs_props_type ), intent(out) :: property Properties associated with the mesh. type( tem_varSys_type ), intent(inout) :: varsys A variable system, to which the further variables should be appended. type( tem_general_type ), intent(inout) :: general General treelm data to load type( tem_restart_type ), intent(inout) :: restart type( tem_time_type ), intent(out) :: time","tags":"","url":"module/sdr_hvs_config_module.html"},{"title":"sdr_cube_module – Seeder","text":"cube table from config file Uses tem_logging_module aot_table_module env_module aotus_module tem_aux_module module~~sdr_cube_module~~UsesGraph module~sdr_cube_module sdr_cube_module aot_table_module aot_table_module module~sdr_cube_module->aot_table_module aotus_module aotus_module module~sdr_cube_module->aotus_module env_module env_module module~sdr_cube_module->env_module tem_aux_module tem_aux_module module~sdr_cube_module->tem_aux_module tem_logging_module tem_logging_module module~sdr_cube_module->tem_logging_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_cube_module~~UsedByGraph module~sdr_cube_module sdr_cube_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_cube_module program~seeder seeder program~seeder->module~sdr_proto2treelm_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_cube_type An auxilary data type to describe a cube. Read more… Components Type Visibility Attributes Name Initial real(kind=rk), public :: origin (3) real(kind=rk), public :: center (3) real(kind=rk), public :: extent real(kind=rk), public :: halfwidth Subroutines public  subroutine sdr_load_cube (me, conf, key, pos, parent) This routine loads the boundCube table from config file Arguments Type Intent Optional Attributes Name type( sdr_cube_type ), intent(out) :: me type( flu_State ) :: conf character(len=*), intent(in), optional :: key open cube table by given key integer, intent(in), optional :: pos open cube table by position integer, intent(in), optional :: parent if cube is to be load from pos, parent handle is required","tags":"","url":"module/sdr_cube_module.html"},{"title":"sdr_proto2treelm_module – Seeder","text":"Module to create the actual mesh out of the flooded protoTree. This module provides the functionality to refine the computational domain\ndown to the requested level everywhere and identify the boundary conditions\nin all 26 directions of the elements, which have boundaries. Uses tem_param_module tem_topology_module sdr_attribute_module tem_aux_module tem_dyn_array_module aot_out_module sdr_protoTree_module tem_prophead_module env_module tem_geometry_module sdr_config_module ply_oversample_module tem_bc_prop_module sdr_geometry_module tem_logging_module ply_prj_header_module ply_poly_project_module tem_timer_module treelmesh_module sdr_periodic_module tem_grow_array_module sdr_boundary_module tem_global_module sdr_timer_module tem_property_module sdr_cube_module sdr_node_module module~~sdr_proto2treelm_module~~UsesGraph module~sdr_proto2treelm_module sdr_proto2treelm_module aot_out_module aot_out_module module~sdr_proto2treelm_module->aot_out_module env_module env_module module~sdr_proto2treelm_module->env_module module~ply_prj_header_module ply_prj_header_module module~sdr_proto2treelm_module->module~ply_prj_header_module module~sdr_boundary_module sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_config_module sdr_config_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_cube_module sdr_cube_module module~sdr_proto2treelm_module->module~sdr_cube_module module~sdr_geometry_module sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_timer_module sdr_timer_module module~sdr_proto2treelm_module->module~sdr_timer_module ply_oversample_module ply_oversample_module module~sdr_proto2treelm_module->ply_oversample_module ply_poly_project_module ply_poly_project_module module~sdr_proto2treelm_module->ply_poly_project_module sdr_attribute_module sdr_attribute_module module~sdr_proto2treelm_module->sdr_attribute_module sdr_node_module sdr_node_module module~sdr_proto2treelm_module->sdr_node_module sdr_periodic_module sdr_periodic_module module~sdr_proto2treelm_module->sdr_periodic_module tem_aux_module tem_aux_module module~sdr_proto2treelm_module->tem_aux_module tem_bc_prop_module tem_bc_prop_module module~sdr_proto2treelm_module->tem_bc_prop_module tem_dyn_array_module tem_dyn_array_module module~sdr_proto2treelm_module->tem_dyn_array_module tem_geometry_module tem_geometry_module module~sdr_proto2treelm_module->tem_geometry_module tem_global_module tem_global_module module~sdr_proto2treelm_module->tem_global_module tem_grow_array_module tem_grow_array_module module~sdr_proto2treelm_module->tem_grow_array_module tem_logging_module tem_logging_module module~sdr_proto2treelm_module->tem_logging_module tem_param_module tem_param_module module~sdr_proto2treelm_module->tem_param_module tem_property_module tem_property_module module~sdr_proto2treelm_module->tem_property_module tem_prophead_module tem_prophead_module module~sdr_proto2treelm_module->tem_prophead_module tem_timer_module tem_timer_module module~sdr_proto2treelm_module->tem_timer_module tem_topology_module tem_topology_module module~sdr_proto2treelm_module->tem_topology_module treelmesh_module treelmesh_module module~sdr_proto2treelm_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_proto2treelm_module~~UsedByGraph module~sdr_proto2treelm_module sdr_proto2treelm_module program~seeder seeder program~seeder->module~sdr_proto2treelm_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_temData_type Data type contains final fluid info dumped into mesh file Components Type Visibility Attributes Name Initial type( grw_longarray_type ), public :: treeID list of fluid treeIDs type( grw_longarray_type ), public :: propertyBits list of property bits for fluid nodes type( grw_longarray_type ), public :: bc_ID (qQQQ) list of boundary iDs for fluid nodes in 26 directions type( grw_char2darray_type ), public :: colors list of color characters type( grw_char2darray_type ), public :: subres list of color characters indicating their subresolution status. integer, public, allocatable :: color_subres_count (:) Count number of subresolved elements for each color. integer, public, allocatable :: color_subres_unit (:) File unit for the subresolution information of each color. real(kind=rk), public, allocatable :: color_volume (:) Measure of the volume covered by each color integer, public :: maxLevel maxlevel in the fluid domain integer, public :: minLevel minlevel in the fluid domain type( grw_realarray_type ), public :: qVal (qQQQ) link-wise distances from boundary for fluid nodes in 26 directions type( grw_realarray_type ), public :: bc_normal (3) Surface normals in boundary elements for which it is to be stored type( treelmesh_type ), public :: meshUniverse treelm mesh type contains only bounding cube info\nneeded to identify boundary and compute q-values integer, public :: nSolids = 0 number of fluidifyable ( solids ) integer, public :: nFluids (globalMaxLevels) Number of fluids on each level type(ply_poly_project_type), public :: projection Projection workspace. Subroutines public  subroutine sdr_proto2treelm (proto, geometry, temData, header) This subroutine creates the treelmesh from the flooded prototree. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( sdr_temData_type ), intent(inout) :: temData temData contains final mesh created by this routine type( sdr_confHead_type ), intent(inout) :: header Header data. public recursive subroutine traverse_tree (node_pos, leVal, proto, geometry, temData, header, meshUniverse) Recursively traverse the tree in a depth first manner to obtain the\nthe ordering required by treelm. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree type( levelValues_type ), intent(in) :: leVal level value of current node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( sdr_temData_type ), intent(inout) :: temData temData contains final treelmesh type( sdr_confHead_type ), intent(in) :: header Header information type( treelmesh_type ), intent(inout) :: meshUniverse contains bounding cube information public  subroutine proto2Treelm (node_pos, treeID, leVal, proto, geometry, check_bnd, temData, nodeprops, nodecolors, meshUniverse) Routine to convert protoTree to Treelm data format.\nappend all leaves to the temData%treeID Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree integer(kind=long_k), intent(in) :: treeID treeID of current node type( levelValues_type ), intent(in) :: leVal level value of current node type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects logical, intent(in) :: check_bnd does this node has boundary neighbor type( sdr_temData_type ), intent(inout) :: temData integer, intent(in) :: nodeprops propertyBits of current node character(len=1), intent(in) :: nodecolors (:) Color information of the cuurent node type( treelmesh_type ), intent(inout) :: meshUniverse contains bounding cube information public  subroutine create_target (node_pos, proto, geometry, leVal, meshUniverse, header, temData) Routine to create an element with subelement resolution. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: node_pos Position of leaf in the preliminary tree type( sdr_protoTree_type ), intent(in) :: proto preliminary tree type( sdr_geometry_type ), intent(in) :: geometry contains all geometrical objects type( levelValues_type ), intent(in) :: leVal level value of parent node type( treelmesh_type ), intent(inout) :: meshUniverse contains bounding cube information type( sdr_confHead_type ), intent(in) :: header Configuration header. type( sdr_temData_type ), intent(inout) :: temData Data for the final mesh. public  subroutine sdr_color_points (nodals, nPoints, point, target_pos, fill, void, proto, iColor) Get the color at all given points. Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: nodals (:) integer, intent(in) :: nPoints real(kind=rk), intent(in) :: point (:,:) Point for which to evaluate the color. integer, intent(in) :: target_pos Position of leaf in the preliminary tree real(kind=rk), intent(in) :: fill real(kind=rk), intent(in) :: void type( sdr_protoTree_type ), intent(in) :: proto preliminary tree integer, intent(in) :: iColor public  subroutine sdr_dump_treelm (temData, geometry, confHeader) This routine dumps the final fluid tree leaves in the disk Arguments Type Intent Optional Attributes Name type( sdr_temData_type ), intent(in) :: temData temData contains final treelmesh type( sdr_geometry_type ), intent(in) :: geometry Bounding cube, the prototree lives in. type( sdr_confHead_type ), intent(inout) :: confHeader config header info.","tags":"","url":"module/sdr_proto2treelm_module.html"},{"title":"sdr_stl_module – Seeder","text":"This module provides a adapter rouinte to load stl file and add triangles\nto spatial objects \\author Kannan Masilamani Uses stla_io tem_tools_module tem_logging_module flu_binding aot_table_module env_module tem_triangle_module tem_stl_module aotus_module tem_stlb_io_module tem_aux_module sdr_spatialObj_module tem_transformation_module module~~sdr_stl_module~~UsesGraph module~sdr_stl_module sdr_stl_module aot_table_module aot_table_module module~sdr_stl_module->aot_table_module aotus_module aotus_module module~sdr_stl_module->aotus_module env_module env_module module~sdr_stl_module->env_module flu_binding flu_binding module~sdr_stl_module->flu_binding sdr_spatialObj_module sdr_spatialObj_module module~sdr_stl_module->sdr_spatialObj_module stla_io stla_io module~sdr_stl_module->stla_io tem_aux_module tem_aux_module module~sdr_stl_module->tem_aux_module tem_logging_module tem_logging_module module~sdr_stl_module->tem_logging_module tem_stl_module tem_stl_module module~sdr_stl_module->tem_stl_module tem_stlb_io_module tem_stlb_io_module module~sdr_stl_module->tem_stlb_io_module tem_tools_module tem_tools_module module~sdr_stl_module->tem_tools_module tem_transformation_module tem_transformation_module module~sdr_stl_module->tem_transformation_module tem_triangle_module tem_triangle_module module~sdr_stl_module->tem_triangle_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_stl_module~~UsedByGraph module~sdr_stl_module sdr_stl_module module~sdr_geometry_module sdr_geometry_module module~sdr_geometry_module->module~sdr_stl_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_geometry_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_geometry_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_load_stl (triArray, spaObjArray, attr_pos, transform, conf, thandle) This routine loads STL files from config and reads the triangles from the\nfiles into the dynamic array of triangles. Arguments Type Intent Optional Attributes Name type( grw_trianglearray_type ), intent(inout) :: triArray Dynamic array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray Growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute, this object is connected to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf Lua state integer, intent(in) :: thandle","tags":"","url":"module/sdr_stl_module.html"},{"title":"ply_nodes_module – Seeder","text":"Description of point sets. Uses env_module ply_nodeset_module aotus_module fftw_wrap tem_aux_module ply_nodes_header_module module~~ply_nodes_module~~UsesGraph module~ply_nodes_module ply_nodes_module aotus_module aotus_module module~ply_nodes_module->aotus_module env_module env_module module~ply_nodes_module->env_module fftw_wrap fftw_wrap module~ply_nodes_module->fftw_wrap module~ply_nodes_header_module ply_nodes_header_module module~ply_nodes_module->module~ply_nodes_header_module module~ply_nodeset_module ply_nodeset_module module~ply_nodes_module->module~ply_nodeset_module tem_aux_module tem_aux_module module~ply_nodes_module->tem_aux_module module~ply_nodes_header_module->env_module module~ply_nodeset_module->env_module tem_param_module tem_param_module module~ply_nodeset_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: ply_faceNodes_type Datatype to represent facewise nodes Components Type Visibility Attributes Name Initial integer, public :: nquadPoints The number of face nodes real(kind=rk), public, allocatable :: points (:,:) The face nodes.\nFirst index goes from 1 to nPoints and second index\nfrom 1 to 3 for the 3 spatial coordinates. Subroutines public  subroutine ply_nodes_create (me, nodes, faces, nQuadPointsPerDir, ndims) Initialize points with the Chebyshev quadrature points, 3D Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: me real(kind=rk), intent(out), allocatable :: nodes (:,:) type( ply_faceNodes_type ), intent(out), allocatable :: faces (:,:) integer, intent(in) :: nQuadPointsPerDir integer, intent(in) :: ndims private  subroutine ply_nodes_volume_coords (num_intp_per_direction, nDims, nodeset, points) Create multidimensional points from given 1D set of nodes in the cubic\nreference element. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_intp_per_direction Number auf integration points in each direction. integer, intent(in) :: nDims Number of dimensions to create the points for. procedure( ply_nodeset_coords ) :: nodeset Set of node coordinates to use in the element. real(kind=rk), intent(out), allocatable :: points (:,:) Resulting list of points. First index runs over all points, second\nindicates the coordinate dimension (x=1,y=2,z=3). Read more… private  subroutine ply_nodes_surface_coords (num_intp_per_direction, ndims, nodeset, left, right, dir) Create the integration points on the surface of (cubical) elements. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_intp_per_direction Number of integration points in each direction integer, intent(in) :: ndims Number of dimensions in the element. procedure( ply_nodeset_coords ) :: nodeset Set of node coordinates to use in the element for which the surface\npoints are to be defined. real(kind=rk), intent(out), allocatable :: left (:,:) The points on the left surface. real(kind=rk), intent(out), allocatable :: right (:,:) The points on the right surface. integer :: dir The spatial direction of the face. \\n\n1 -> x direction \\n\n2 -> y direction \\n\n3 -> z direction private  subroutine ply_point_tensor (nPoints1D, nDims, nodeset, points) Compute a multi-dimensional tensor for the given set of nodes. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints1D Number auf integration points in each direction. integer, intent(in) :: nDims Number of dimensions to create the points for. procedure( ply_nodeset_coords ) :: nodeset Set of node coordinates to use in the element. real(kind=rk), intent(out) :: points (nPoints1D**nDims,nDims) Resulting list of points. First index runs over all points, second\nindicates the coordinate dimension (x=1,y=2,z=3).","tags":"","url":"module/ply_nodes_module.html"},{"title":"ply_legser_module – Seeder","text":"This module provides Piessens Algorithm 473 from the Communications of the\nACM, January 1974, Volume 17, Number 1. Its unrestricted use in a computer is permitted. This Algorithm transforms a known Chebyshev expansion into a Legendre\nexpansion in N&#94;2 time complexity. Uses env_module module~~ply_legser_module~~UsesGraph module~ply_legser_module ply_legser_module env_module env_module module~ply_legser_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine ply_legser (A, B, n) Subroutine to convert Chebyshev (A) to Legendre (B) coefficients. Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (n) Known coefficients of the Chebyshev approximation. real(kind=rk), intent(out) :: B (n) Computed corresponding coefficients of the Legendre approximation. integer, intent(in) :: n Number of coefficients.","tags":"","url":"module/ply_legser_module.html"},{"title":"ply_filter_element_module – Seeder","text":"This module provides methods to filter polynomial representation in\nelements based on their shape. The main goal of this filtering is to smooth out Gibbs oscillations while\nmaintaining the strong gradients at discontinuities. Uses tem_tools_module tem_logging_module aot_err_module aot_table_module env_module aotus_module tem_aux_module module~~ply_filter_element_module~~UsesGraph module~ply_filter_element_module ply_filter_element_module aot_err_module aot_err_module module~ply_filter_element_module->aot_err_module aot_table_module aot_table_module module~ply_filter_element_module->aot_table_module aotus_module aotus_module module~ply_filter_element_module->aotus_module env_module env_module module~ply_filter_element_module->env_module tem_aux_module tem_aux_module module~ply_filter_element_module->tem_aux_module tem_logging_module tem_logging_module module~ply_filter_element_module->tem_logging_module tem_tools_module tem_tools_module module~ply_filter_element_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_filter_element_module~~UsedByGraph module~ply_filter_element_module ply_filter_element_module module~ply_sampling_adaptive_module ply_sampling_adaptive_module module~ply_sampling_adaptive_module->module~ply_filter_element_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: filter_strat_none = 0 integer, private, parameter :: filter_strat_oddfract = 1 Abstract Interfaces abstract interface public  subroutine ply_filter_element(me, element_degree, element_data) Filter the polynomial data in a given element. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Parameters of the filter. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in element. The first index describes the\ndegrees of freedom. The second index refers to the elements to filter. Derived Types type, public :: ply_filter_element_type Paramaters describing the filtering to apply to elemental polynomial data. Components Type Visibility Attributes Name Initial integer, public :: strategy = filter_strat_none Filter strategy to use. integer, public :: max_order Maximal order for exponential spectral filtering to use\nwhere little filtering is to be done. integer, public :: min_order Minimal order for exponential spectral filtering to use. integer, public :: fract_exponent Exponent to use for the fraction. procedure( ply_filter_element ), public, pointer :: filter1D => NULL() Function pointer for 1D filtering procedure( ply_filter_element ), public, pointer :: filter2D => NULL() Function pointer for 2D filtering procedure( ply_filter_element ), public, pointer :: filter3D => NULL() Function pointer for 3D filtering Subroutines public  subroutine ply_filter_element_load (me, conf, parent) Loading parameters for the filtering from the configuration script.\nThis needs to be performed before any call of the actual transformation ply_split_element_1D . Read more… Arguments Type Intent Optional Attributes Name type( ply_filter_element_type ), intent(out) :: me Data structure that holds the filter parameters. type( flu_State ) :: conf Lua script to get the filter parameters from. integer, intent(in), optional :: parent Table handle to a possible parent, that contains the filter table\nto load. public  subroutine ply_filter_element_oddfract (me, nDims, inLen, element_data, filtered_data) Filter a polynomial representation in elements in one dimension according\nto its odd mode fraction. Read more… Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: nDims Number of dimensions of the polynomial data. integer, intent(in) :: inLen (nDims) Number degrees of freedom for each direction in element_data. Read more… real(kind=rk), intent(in) :: element_data (:,:) Polynomial representation in the elements. Read more… real(kind=rk), intent(out) :: filtered_data (:,:) The filtered polynomial modes. Read more… private  subroutine ply_filter_oddfract_1D (me, element_degree, element_data) Filter one-dimensional elements of degree element_degree. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. private  subroutine ply_filter_oddfract_2D (me, element_degree, element_data) Filter two-dimensional elements of degree element_degree. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. private  subroutine ply_filter_oddfract_3D (me, element_degree, element_data) Filter three-dimensional elements of degree element_degree. Arguments Type Intent Optional Attributes Name class( ply_filter_element_type ), intent(in) :: me Filter parameters. integer, intent(in) :: element_degree Polynomial degree in the parent element. real(kind=rk), intent(inout) :: element_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split.","tags":"","url":"module/ply_filter_element_module.html"},{"title":"ply_LegPolyProjection_module – Seeder","text":"Module for projection of Q Legendre Polynomials from parent cell\nto child cells. Uses env_module treelmesh_module tem_param_module tem_aux_module module~~ply_legpolyprojection_module~~UsesGraph module~ply_legpolyprojection_module ply_LegPolyProjection_module env_module env_module module~ply_legpolyprojection_module->env_module tem_aux_module tem_aux_module module~ply_legpolyprojection_module->tem_aux_module tem_param_module tem_param_module module~ply_legpolyprojection_module->tem_param_module treelmesh_module treelmesh_module module~ply_legpolyprojection_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: ply_QLegendrePoly_prp = 1 Parameter to specify Legendre polynomials as the degrees of freedoms\nof the elements. The multidimensional polynomias are build as\nQ-polynomials.\nThe projection is a L2-Projection onto the ansatz function of the finer\nelements. Derived Types type, public :: ply_subsample_type Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. Is subsampling active integer, public :: sampling_lvl The current sampling lvl. integer, public :: projectionType = ply_QLegendrePoly_prp The type of projection we use to subsample the elemental data. integer, public :: caplevel = 20 Maximal Level down to which subsampling should be done. integer, public :: minsub = 0 Minimal subsampling depth: integer, public :: maxsub = 0 Maximal subsampling depth: real(kind=rk), public :: eps_osci Maximum allowed oscillation of the solution.\nFor adaptive subsampling only. real(kind=rk), public :: dofReducFactor Factor for the reduction of the degrees of freedom in one subsampling\nstep (per spatial direction). logical, public :: adaptiveDofReduction Indicator for limitation of total memory consumption integer, public :: AbsUpperBoundLevel Absolute upper bound level to refine to. type, public :: ply_array_type Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dat (:) type, private :: ply_ProjCoeff_type Datatype storing the coefficients arising for the projection\nof solutions on a parent cell to its children during the subsampling\nroutines. Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: projCoeff (:,:,:) Array holding all the projection coefficients for the projection\nof a degree of freedom on the parent element (first index) to\na degree of freedom on the child element (second index) for\na given child element (third index).\nTherefore the dimension of this array is (nDofs, nDofs, 8). Functions private  function ply_QLegOneDimCoeff (nDofsOneDim, nChildDofsOneDim) result(projCoeffOneDim) Routine to create one-dimensional projection coefficient for a coarse\nelement to a fine element. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDofsOneDim The number of dofs in one dimension. integer, intent(in) :: nChildDofsOneDim The number of dofs in one dimension for the children. Return Value real(kind=rk), allocatable, (:,:,:) Projected one-dimensional coefficients. First index is Legendre polynomial on the parent element, second index\nis the Legendre polynomial on the child element, third index is left\nor right projection. private  function ply_QLegSqNorm (polyIndex) result(sqNorm) Function to calculate the squared L2-Norm of a given Legendre polynomial\non the reference element [-1,+1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polyIndex The Legendre polynomial index to calculate the squared norm for.\nThe first polynomial has index 1. Return Value real(kind=rk) The squared L2 Norm of the Legendre polynomial. private  function ply_legVal (points, nPoints, maxPolyDegree) result(val) Evaluate a given set of Legendre polynomials a given set of 1D points. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: points (:) A given set of 1D points. integer, intent(in) :: nPoints The number of points to evaluate the polynomials at. integer, intent(in) :: maxPolyDegree The maximal polynomial degree to evaluate for. Return Value real(kind=rk), allocatable, (:,:) Function values for for all Legendre polynomials up to degree\nmaxPolyDegree at all given points.\nTherefore the dimension of this array is (maxPolyDegree+1, nPoints) Subroutines public  subroutine ply_QPolyProjection (subsamp, dofReduction, tree, meshData, varDofs, ndims, varcomps, refine_tree, new_refine_tree, newMeshData, newVarDofs) Subsampling by L2-Projection of the Q-Tensorproduct Legendre polynomials. Arguments Type Intent Optional Attributes Name type( ply_subsample_type ), intent(in) :: subsamp Parameters for the subsampling. real(kind=rk), intent(in) :: dofReduction (:) Factor for reducion of degrees of freedom. type( treelmesh_type ), intent(in) :: tree The tree the data is written for. type( ply_array_type ), intent(in) :: meshData (:) The data to sub-sample. integer, intent(in) :: varDofs (:) The number of degrees of freedom for each scalar variable. integer, intent(in) :: ndims Number of dimensions in the polynomial representation. integer, intent(in) :: varcomps (:) Number of components logical, intent(in) :: refine_tree (:) Logical array that marks elements for refinement from the last sampling logical, intent(in) :: new_refine_tree (:) Logical array that marks elements for refinment. type( ply_array_type ), intent(out), allocatable :: newMeshData (:) The subsampled data. integer, intent(out), allocatable :: newVarDofs (:) The number of dofs for the subsampled dofs. public  subroutine ply_gauleg (x1, x2, x, w, nIntP) subroutine to create gauss points and weights for one-dimensional\nintegration on the interval [x1,x2]. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x1 lower limit of integration interval real(kind=rk), intent(in) :: x2 upper limit of integration interval real(kind=rk), intent(inout), allocatable :: x (:) The coordinates of the gauss points on the interval [-1,1].\nThe array has the length nIntP. real(kind=rk), intent(inout), allocatable :: w (:) The quadrature weights. The array has the length nIntP. integer, intent(in) :: nIntP The number of integration points. private  subroutine ply_initQLegProjCoeff (dofType, nDofs, ndims, nChilds, nChildDofs, projection) Routine to initialize the projection coefficients for a usage in the\nsubsampling routine to project degrees of freedoms of a parent cell\nto the degrees of freedoms of a child cell if the degrees of\nfreedoms are Q-Legendre polynomials. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dofType The type of degrees of freedom we have in our cells. integer, intent(in) :: nDofs The number of degrees of freedom for the parent cells. integer, intent(in) :: ndims The  number of dimensions in the polynomial representation. integer, intent(in) :: nChilds The number of child cells. integer, intent(in) :: nChildDofs The number of degrees of freedom for the child cells. type( ply_ProjCoeff_type ), intent(out) :: projection The subsampling coefficients that will be initialized by this routine. private  subroutine ply_dofToQPoly (dof, nDofs, ndims, xAnsFunc, yAnsFunc, zAnsFunc) Subroutine to convert linearized dof index to ansatz function number for\nQ-Polynomials. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dof The linearized degree of freedom index. integer, intent(in) :: nDofs The number of dofs for all directions. integer, intent(in) :: ndims The number of Dimensions in the polynomial representation. integer, intent(out) :: xAnsFunc The ansatz function number in x direction. integer, intent(out) :: yAnsFunc The ansatz function number in y direction. integer, intent(out) :: zAnsFunc The ansatz function number in z direction. private  subroutine ply_subsampleData (tree, meshData, nDofs, nChildDofs, nComponents, projection, projection_oneDof, refine_tree, new_refine_tree, ndims, subsamp, newMeshData) Routine to subsample mesh information for one refinement level. Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(in) :: tree The tree the data is written for. real(kind=rk), intent(in) :: meshData (:) The data to sub-sample. integer, intent(in) :: nDofs The number of degrees of freedom for each scalar variable. integer, intent(in) :: nChildDofs The number of degrees of freedom per scalar variable on the child\nelements. integer, intent(in) :: nComponents Number of components type( ply_ProjCoeff_type ), intent(in) :: projection Projection coefficients for the given data. type( ply_ProjCoeff_type ), intent(in), optional :: projection_oneDof Projection coeffiecients for the the reduction to polynomial\ndegree of 0. logical, intent(in), optional :: refine_tree (:) Logical array that marks all elements for refinement from the last\nsampling lvl. logical, intent(in) :: new_refine_tree (:) Logical array that marks all elements for refinement integer, intent(in) :: ndims The number of dimensions in the polynomial representation. type( ply_subsample_type ), intent(in) :: subsamp Parameters for the subsampling. real(kind=rk), intent(out), allocatable :: newMeshData (:) The subsampled data. private  subroutine ply_projDataToChild (parentData, nParentDofs, nChildDofs, nComponents, nChilds, projection, childData) Subroutine to project elemental data from a parent cell to one of\nits children. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: parentData (:) Linearized data for a single variable (can have multiple components)\nand a single degree of freedom of the parent cell. integer, intent(in) :: nParentDofs The number of dofs of the parent element. integer, intent(in) :: nChildDofs The total number of dofs for the child cells. integer, intent(in) :: nComponents The number of componentns of the given variable. integer, intent(in) :: nChilds The number of children. type( ply_ProjCoeff_type ), intent(in) :: projection The information about the projection coefficients for the parent\ndofs to the child dofs. real(kind=rk), intent(out) :: childData (:) The created childData.","tags":"","url":"module/ply_legpolyprojection_module.html"},{"title":"ply_split_legendre_module – Seeder","text":"This module provides the functionality to split Legendre polynomials into\na left and right subinterval with transformed coordinates. The original polynomial is defined on the interval [-1,1] and the two\nnew polynomial representations are computed in the intervals [-1,0] and\n[0,1] but in the changed coordinate system, with the interval [-1,1] for\neach.\nThus, if we refer to the coordinates in the original (coarse) element as\nx and to the respective coordinates in the two halfed elements as xi_left\nand xi_right, we compute the modal representation of the original Legendre\npolynomial series under these transformations: This is needed when refining elements. Uses env_module module~~ply_split_legendre_module~~UsesGraph module~ply_split_legendre_module ply_split_legendre_module env_module env_module module~ply_split_legendre_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_split_legendre_module~~UsedByGraph module~ply_split_legendre_module ply_split_legendre_module module~ply_split_element_module ply_split_element_module module~ply_split_element_module->module~ply_split_legendre_module module~ply_sampling_adaptive_module ply_sampling_adaptive_module module~ply_sampling_adaptive_module->module~ply_split_element_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function ply_split_legendre_matrix (nModes) result(split_matrix) Compute the transformation matrix for a projection to the left and right\n half-interval of Legendre polynomials for the given maximal number of\n modes. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes The maximal number of modes to compute the transformation for. Read more… Return Value real(kind=rk), (nModes,nModes) private elemental function alpha (mode) Coefficient alpha from the recursive formulation of Legendre polynomials,\nfor the Legendre mode 'mode'. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The Legendre mode to compute for. Return Value real(kind=rk) private elemental function beta (mode) Coefficient beta from the recursive formulation of Legendre polynomials,\n for the Legendre mode 'mode'. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The Legendre mode to compute for. Return Value real(kind=rk) private elemental function alpha_frac (denominator, numerator) Quotient of two alpha values. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Legendre mode of the to use in the denominator. integer, intent(in) :: numerator Legendre mode of the to use in the numeratorr. Return Value real(kind=rk) private elemental function alpha_beta (denominator, numerator) Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) as\nneeded by the Clenshaw algorithm in ply_split_legendre_matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Legendre mode for the in the denominator and the . integer, intent(in) :: numerator Legendre mode for the in the numerator. Return Value real(kind=rk) Subroutines public  subroutine ply_split_legendre_test (success) A small testing routine to check the functions of this module. Arguments Type Intent Optional Attributes Name logical, intent(out) :: success Indication whether the tests were completed successfully.","tags":"","url":"module/ply_split_legendre_module.html"},{"title":"ply_fxt_module – Seeder","text":"Fast polynomial transformation using the FXTPACK implementation of a\nfast multipole method. Uses env_module fxt_fwrap ply_fxt_header_module module~~ply_fxt_module~~UsesGraph module~ply_fxt_module ply_fxt_module env_module env_module module~ply_fxt_module->env_module fxt_fwrap fxt_fwrap module~ply_fxt_module->fxt_fwrap module~ply_fxt_header_module ply_fxt_header_module module~ply_fxt_module->module~ply_fxt_header_module module~ply_fxt_header_module->env_module aot_out_module aot_out_module module~ply_fxt_header_module->aot_out_module aotus_module aotus_module module~ply_fxt_header_module->aotus_module module~ply_nodes_header_module ply_nodes_header_module module~ply_fxt_header_module->module~ply_nodes_header_module tem_aux_module tem_aux_module module~ply_fxt_header_module->tem_aux_module tem_float_module tem_float_module module~ply_fxt_header_module->tem_float_module tem_logging_module tem_logging_module module~ply_fxt_header_module->tem_logging_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: ply_fxt_type Components Type Visibility Attributes Name Initial type(fxtf_flptld_type), public :: flpt real(kind=rk), public :: prec integer, public :: ndims Subroutines public  subroutine ply_init_fxt (fxt, header, degree) Initialize the flpt data structure for fast legendre polynomial\ntransformation via the fxtpack. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ), intent(out) :: fxt Handle to the resulting fast polynomial table. type( ply_fxt_header_type ), intent(in) :: header integer, intent(in) :: degree Polynomial degree. public  subroutine ply_fxt_m2n_1D (fxt, modal_data, nodal_data) Convert modal data to nodal data in 1D using flpt. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: modal_data (:) Modal data real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data public  subroutine ply_fxt_m2n_2D (fxt, modal_data, nodal_data, oversamp_degree) Convert modal data to nodal data in 2D using flpt. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: modal_data (:) Modal data real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data integer, intent(in) :: oversamp_degree public  subroutine ply_fxt_m2n_3D (fxt, modal_data, nodal_data, oversamp_degree) Convert modal data to nodal data in 3D using flpt. Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: modal_data (:) Modal data real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data integer, intent(in) :: oversamp_degree public  subroutine ply_fxt_n2m_1D (fxt, nodal_data, modal_data) Convert nodal data to modal data using flpt. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data real(kind=rk), intent(inout), target :: modal_data (:) Modal data public  subroutine ply_fxt_n2m_2D (fxt, nodal_data, modal_data, oversamp_degree) Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), target :: nodal_data (:) Nodal data real(kind=rk), target :: modal_data (:) Modal data integer, intent(in) :: oversamp_degree public  subroutine ply_fxt_n2m_3D (fxt, nodal_data, modal_data, oversamp_degree) Arguments Type Intent Optional Attributes Name type( ply_fxt_type ) :: fxt Description of the Fast Legendre Polynomial Transform real(kind=rk), intent(inout), target :: nodal_data (:) Nodal data real(kind=rk), intent(inout), target :: modal_data (:) Modal data integer, intent(in) :: oversamp_degree","tags":"","url":"module/ply_fxt_module.html"},{"title":"ply_space_integration_module – Seeder","text":"Spatial integration with the Gauss-Legendre numerical integration. Uses env_module tem_param_module module~~ply_space_integration_module~~UsesGraph module~ply_space_integration_module ply_space_integration_module env_module env_module module~ply_space_integration_module->env_module tem_param_module tem_param_module module~ply_space_integration_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_space_integration_module~~UsedByGraph module~ply_space_integration_module ply_space_integration_module module~ply_l2p_module ply_l2p_module module~ply_l2p_module->module~ply_space_integration_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine ply_gaussLegPoints (x1, x2, x, w, nIntP) Create Gauss-Legendre integration points and weights for one-dimensional\nintegration on the interval [x1,x2]. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x1 lower limit of integration interval real(kind=rk), intent(in) :: x2 upper limit of integration interval real(kind=rk), intent(out) :: x (:) The coordinates of the gauss points on the interval [x1,x2].\nThe array has the length nIntP. real(kind=rk), intent(out) :: w (:) The quadrature weights. The array has the length nIntP. integer, intent(in) :: nIntP The number of integration points.","tags":"","url":"module/ply_space_integration_module.html"},{"title":"ply_prj_header_module – Seeder","text":"Uses aot_out_module tem_tools_module tem_logging_module env_module ply_l2p_header_module aotus_module fftw_wrap ply_fpt_header_module tem_aux_module ply_fxt_header_module module~~ply_prj_header_module~~UsesGraph module~ply_prj_header_module ply_prj_header_module aot_out_module aot_out_module module~ply_prj_header_module->aot_out_module aotus_module aotus_module module~ply_prj_header_module->aotus_module env_module env_module module~ply_prj_header_module->env_module fftw_wrap fftw_wrap module~ply_prj_header_module->fftw_wrap module~ply_fpt_header_module ply_fpt_header_module module~ply_prj_header_module->module~ply_fpt_header_module module~ply_fxt_header_module ply_fxt_header_module module~ply_prj_header_module->module~ply_fxt_header_module module~ply_l2p_header_module ply_l2p_header_module module~ply_prj_header_module->module~ply_l2p_header_module tem_aux_module tem_aux_module module~ply_prj_header_module->tem_aux_module tem_logging_module tem_logging_module module~ply_prj_header_module->tem_logging_module tem_tools_module tem_tools_module module~ply_prj_header_module->tem_tools_module module~ply_fpt_header_module->aot_out_module module~ply_fpt_header_module->aotus_module module~ply_fpt_header_module->env_module module~ply_fpt_header_module->tem_aux_module module~ply_fpt_header_module->tem_logging_module module~ply_fpt_header_module->tem_tools_module module~ply_nodes_header_module ply_nodes_header_module module~ply_fpt_header_module->module~ply_nodes_header_module tem_compileconf_module tem_compileconf_module module~ply_fpt_header_module->tem_compileconf_module tem_float_module tem_float_module module~ply_fpt_header_module->tem_float_module module~ply_fxt_header_module->aot_out_module module~ply_fxt_header_module->aotus_module module~ply_fxt_header_module->env_module module~ply_fxt_header_module->tem_aux_module module~ply_fxt_header_module->tem_logging_module module~ply_fxt_header_module->module~ply_nodes_header_module module~ply_fxt_header_module->tem_float_module module~ply_l2p_header_module->aot_out_module module~ply_l2p_header_module->aotus_module module~ply_l2p_header_module->env_module module~ply_l2p_header_module->tem_aux_module module~ply_l2p_header_module->tem_logging_module module~ply_l2p_header_module->tem_tools_module module~ply_l2p_header_module->module~ply_nodes_header_module module~ply_l2p_header_module->tem_float_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_prj_header_module~~UsedByGraph module~ply_prj_header_module ply_prj_header_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~ply_prj_header_module module~sdr_config_module sdr_config_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_subresolution_module sdr_subresolution_module module~sdr_subresolution_module->module~ply_prj_header_module module~sdr_config_module->module~sdr_subresolution_module program~seeder seeder program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_config_module module~sdr_flooding_module sdr_flooding_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_prototree_module module~sdr_refinept_module sdr_refinePT_module program~seeder->module~sdr_refinept_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_prototree_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assignment(=) private pure subroutine Copy_poly_proj_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(out) :: left fpt to copy to type( ply_prj_header_type ), intent(in) :: right fpt to copy from public        interface operator(==) private pure function isEqual (left, right) result(equality) This function provides the test for equality of the header for two\nprojections. The headers are considered to be equal, if their kind and the corresponding\nheaders are equal. For unknown kinds, the headers are not taken into\nconsideration. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? public        interface operator(/=) private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of the header of two\nprojections. Two projections are considered to be unequal, if their kind, their\nfpt-header or l2p_header are not equal. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? public        interface operator(<) private pure function isSmaller (left, right) result(small) This function provides a < comparison of the header of two projections. Sorting of projections is given by the kind, fpt_header and\nlast by l2p_header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(<=) private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of the header of two projections. Sorting of projections is given by kind, fpt_header and\nlast by the l2p header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(>) private pure function isGreater (left, right) result(great) This function provides a > comparison of the header of two projections. Sorting of projections is given by kind, fpt_header and\nlast by l2p_header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? public        interface operator(>=) private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of the header of two projections. Sorting of projections is given by kind, fpt_header and\nlast by l2p_header. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Derived Types type, public :: ply_prj_header_type Configurable projection settings. Components Type Visibility Attributes Name Initial character(len=labelLen), public :: kind Kind of projection. Currently available:\n- 'l2p', L2-Projection\n- 'fpt', Fast Polynomial Transformation. Requires the FFTW. type( ply_fpt_header_type ), public :: fpt_header type( ply_l2p_header_type ), public :: l2p_header type( ply_fxt_header_type ), public :: fxt_header Functions private pure function isEqual (left, right) result(equality) This function provides the test for equality of the header for two\nprojections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of the header of two\nprojections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? private pure function isSmaller (left, right) result(small) This function provides a < comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isGreater (left, right) result(great) This function provides a > comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of the header of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: left projection to compare type( ply_prj_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Subroutines public  subroutine ply_prj_header_load (me, conf, parent) Load settings to describe a projection method from a Lua table. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in) :: parent A parent Lua table, in which the boundary conditions are to be found. public  subroutine ply_prj_header_out (me, conf) Load settings to describe a projection method from a Lua table. Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(in) :: me type( aot_out_type ) :: conf private pure subroutine Copy_poly_proj_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_prj_header_type ), intent(out) :: left fpt to copy to type( ply_prj_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"module/ply_prj_header_module.html"},{"title":"sdr_timer_module – Seeder","text":"Uses env_module tem_general_module tem_timer_module soi_revision_module module~~sdr_timer_module~~UsesGraph module~sdr_timer_module sdr_timer_module env_module env_module module~sdr_timer_module->env_module soi_revision_module soi_revision_module module~sdr_timer_module->soi_revision_module tem_general_module tem_general_module module~sdr_timer_module->tem_general_module tem_timer_module tem_timer_module module~sdr_timer_module->tem_timer_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_timer_module~~UsedByGraph module~sdr_timer_module sdr_timer_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_timer_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_timer_module module~sdr_flooding_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_boundary_module sdr_boundary_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_timer_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_prototree_module->module~sdr_timer_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_timer_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_timer_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module module~sdr_boundary_module->module~sdr_prototree_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public :: timer_handle_loadconfig Handles for timer objects to measure the time for some code parts integer, public :: timer_handle_proto integer, public :: timer_handle_flooding integer, public :: timer_handle_inHeritDR integer, public :: timer_handle_refineLeaf integer, public :: timer_handle_smoothLeaf integer, public :: timer_handle_proto2treelm integer, public :: timer_handle_dumping_mesh integer, private, parameter :: nTimers = 8 integer, private :: first_timer Subroutines public  subroutine sdr_addTimers () Setup timers to assess the runtime of various parts of Seeder Arguments None public  subroutine sdr_dumptimers (general, nFluids, nBnds) Performance results are written to a file for statistical review Read more… Arguments Type Intent Optional Attributes Name type( tem_general_type ), intent(in) :: general Parameters of the current simulation integer, intent(in) :: nFluids Number of fluid elements in dumped mesh integer, intent(in) :: nBnds Number of fluid elements which has boundary in dumped mesh","tags":"","url":"module/sdr_timer_module.html"},{"title":"ply_nodes_header_module – Seeder","text":"Uses env_module module~~ply_nodes_header_module~~UsesGraph module~ply_nodes_header_module ply_nodes_header_module env_module env_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_nodes_header_module~~UsedByGraph module~ply_nodes_header_module ply_nodes_header_module module~ply_fpt_header_module ply_fpt_header_module module~ply_fpt_header_module->module~ply_nodes_header_module module~ply_fxt_header_module ply_fxt_header_module module~ply_fxt_header_module->module~ply_nodes_header_module module~ply_l2p_header_module ply_l2p_header_module module~ply_l2p_header_module->module~ply_nodes_header_module module~ply_nodes_module ply_nodes_module module~ply_nodes_module->module~ply_nodes_header_module module~ply_fxt_module ply_fxt_module module~ply_fxt_module->module~ply_fxt_header_module module~ply_l2p_module ply_l2p_module module~ply_l2p_module->module~ply_l2p_header_module module~ply_legfpt_module ply_legFpt_module module~ply_legfpt_module->module~ply_fpt_header_module module~ply_prj_header_module ply_prj_header_module module~ply_prj_header_module->module~ply_fpt_header_module module~ply_prj_header_module->module~ply_fxt_header_module module~ply_prj_header_module->module~ply_l2p_header_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~ply_prj_header_module module~sdr_subresolution_module sdr_subresolution_module module~sdr_subresolution_module->module~ply_prj_header_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_subresolution_module program~seeder seeder program~seeder->module~sdr_proto2treelm_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assignment(=) private pure subroutine Copy_nodes_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(out) :: left fpt to copy to type( ply_nodes_header_type ), intent(in) :: right fpt to copy from public        interface operator(==) private pure function isEqual (left, right) result(equality) This function provides the test for equality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? public        interface operator(/=) private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? public        interface operator(<) private pure function isSmaller (left, right) result(small) This function provides a < comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(<=) private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(>) private pure function isGreater (left, right) result(great) This function provides a > comparison of nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? public        interface operator(>=) private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Derived Types type, public :: ply_nodes_header_type Components Type Visibility Attributes Name Initial character(len=labelLen), public :: nodes_kind which kind of nodes are used. For l2p projection the nodes are\nlegendre-gauss and chebyshev nodes for using fpt logical, public :: lobattoPoints = .false. Logical to indicate whether Chebyshev-Lobatto points or simple\nChebyshev points are used Functions private pure function isEqual (left, right) result(equality) This function provides the test for equality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? private pure function isSmaller (left, right) result(small) This function provides a < comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isGreater (left, right) result(great) This function provides a > comparison of nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two nodes descriptions. Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(in) :: left projection to compare type( ply_nodes_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Subroutines private pure subroutine Copy_nodes_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_nodes_header_type ), intent(out) :: left fpt to copy to type( ply_nodes_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"module/ply_nodes_header_module.html"},{"title":"sdr_refinePT_module – Seeder","text":"This module contains routine to refine protoTree until the minlevel\nor level defined in the refinement object is reached Uses tem_grow_array_module tem_dyn_array_module tem_tools_module sdr_geometry_module tem_logging_module tem_param_module tem_sphere_module sdr_protoTree_module env_module tem_geometry_module tem_timer_module sdr_config_module sdr_timer_module tem_topology_module sdr_attribute_module tem_cube_module sdr_spatialObj_module sdr_node_module module~~sdr_refinept_module~~UsesGraph module~sdr_refinept_module sdr_refinePT_module env_module env_module module~sdr_refinept_module->env_module module~sdr_config_module sdr_config_module module~sdr_refinept_module->module~sdr_config_module module~sdr_geometry_module sdr_geometry_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_refinept_module->module~sdr_prototree_module module~sdr_timer_module sdr_timer_module module~sdr_refinept_module->module~sdr_timer_module sdr_attribute_module sdr_attribute_module module~sdr_refinept_module->sdr_attribute_module sdr_node_module sdr_node_module module~sdr_refinept_module->sdr_node_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_refinept_module->sdr_spatialObj_module tem_cube_module tem_cube_module module~sdr_refinept_module->tem_cube_module tem_dyn_array_module tem_dyn_array_module module~sdr_refinept_module->tem_dyn_array_module tem_geometry_module tem_geometry_module module~sdr_refinept_module->tem_geometry_module tem_grow_array_module tem_grow_array_module module~sdr_refinept_module->tem_grow_array_module tem_logging_module tem_logging_module module~sdr_refinept_module->tem_logging_module tem_param_module tem_param_module module~sdr_refinept_module->tem_param_module tem_sphere_module tem_sphere_module module~sdr_refinept_module->tem_sphere_module tem_timer_module tem_timer_module module~sdr_refinept_module->tem_timer_module tem_tools_module tem_tools_module module~sdr_refinept_module->tem_tools_module tem_topology_module tem_topology_module module~sdr_refinept_module->tem_topology_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_refinept_module~~UsedByGraph module~sdr_refinept_module sdr_refinePT_module program~seeder seeder program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_inHerit_distanceRefineObject (proto, geometry) This routines inherit distance refine sphere object from root node\ndown to leaf node. \nOnly the object with level greater than node level are inHerited Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data to refine further type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos public  subroutine sdr_refine_leaf (proto, geometry) This routine extends the protoTree with max of minlevel or level of\nrefinement object. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data to refine further type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos public  subroutine sdr_smooth_leaf (proto, header, maxLevel) This routine smoothens fluid domain with maximum level jumps of 1. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree on which childern are created type( sdr_confHead_type ), intent(inout) :: header some global information on solver name and version integer, intent(in) :: maxLevel Maximum level in the fluid domain private  subroutine inHerit_intersectedObject (proto, geometry, parent, parentID, testAll, intersected_object, grwObjPos, parent_objPos, leVal, child_intersected_object, child_nodePos, memLeft, isDistRefObj) This routine inherit the intersected boundary objects from parent to\nchildrens Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data to refine further type( sdr_geometry_type ), intent(in) :: geometry type which contains all geometry object infos integer, intent(in) :: parent Position of parent node in protoTree integer(kind=long_k), intent(in) :: parentID TreeID of parent logical, intent(in) :: testAll To test all intersected objects type( grw_intarray_type ), intent(inout) :: intersected_object Growing array of intersected objects. \nCould be user defined  or distance refine spatial objects type(grw_intersectObjPosArray_type), intent(inout) :: grwObjPos First and last position of intersected object of all nodes in\nintersected_object list type(sdr_intersectObjPos_type), intent(in) :: parent_objPos Position of first ans last intersected object of parent node \nin intersected_object list type( levelValues_type ), intent(in) :: leVal contains information on current level on which children are created type( grw_intarray_type ), intent(inout) :: child_intersected_object Temporary array of intersected objects for 8 children integer, intent(in) :: child_nodePos (8) 8 children node position in protoTree integer, intent(out) :: memLeft memory of parent intersected object unused by children logical, intent(in) :: isDistRefObj Is this distance refine objects private  subroutine check_bndLevel (proto, parent, parent_ID_offset, leVal, maxLevel) This routine checks if neighbor node with intersected boundary is level \nhigher than current node level. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree on which childern are created integer, intent(in) :: parent Position of parent node on the dynamic array of node%treeID and node_data\nin preliminary tree integer(kind=long_k), intent(in) :: parent_ID_offset first treeID of the parent type( levelValues_type ), intent(in) :: leVal contains information on current level on which children are created integer, intent(inout) :: maxLevel Maximum level to refine current node private  subroutine create_children (proto, parent, child_nodePos, grwTreeID) This routine append 8 children to protoTree and inherit property bits from \nparent. leaf bit is removed from parent. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto preliminary tree on which childern are created integer, intent(in) :: parent Position of parent node on the dynamic array of node%treeID and node_data\nin preliminary tree integer, intent(out) :: child_nodePos (8) 8 children node position in protoTree type( grw_longarray_type ), intent(inout) :: grwTreeID Temporary growing array of TreeID contains new leaf nodes in current level","tags":"","url":"module/sdr_refinept_module.html"},{"title":"sdr_subres_fills_module – Seeder","text":"Uses tem_tools_module tem_dyn_array_module tem_grow_array_module flu_binding tem_logging_module aot_table_module env_module aotus_module tem_aux_module module~~sdr_subres_fills_module~~UsesGraph module~sdr_subres_fills_module sdr_subres_fills_module aot_table_module aot_table_module module~sdr_subres_fills_module->aot_table_module aotus_module aotus_module module~sdr_subres_fills_module->aotus_module env_module env_module module~sdr_subres_fills_module->env_module flu_binding flu_binding module~sdr_subres_fills_module->flu_binding tem_aux_module tem_aux_module module~sdr_subres_fills_module->tem_aux_module tem_dyn_array_module tem_dyn_array_module module~sdr_subres_fills_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~sdr_subres_fills_module->tem_grow_array_module tem_logging_module tem_logging_module module~sdr_subres_fills_module->tem_logging_module tem_tools_module tem_tools_module module~sdr_subres_fills_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_subres_fills_module~~UsedByGraph module~sdr_subres_fills_module sdr_subres_fills_module module~sdr_subresolution_module sdr_subresolution_module module~sdr_subresolution_module->module~sdr_subres_fills_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_subresolution_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_prototree_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_subres_fills_type Definition of values to use for colors in polynomial representations. Components Type Visibility Attributes Name Initial type( dyn_labelarray_type ), public :: label Name of the color, to which the color values apply. type( grw_realarray_type ), public :: fill Actual value to use, where the color is present, defaults to 1. Read more… type( grw_realarray_type ), public :: void Actual value to use, where the color is not present, defaults to 0. Subroutines public  subroutine sdr_subres_fills_add (fills, colorname, fill_value, void_value, pos, wasAdded) Add a value definition for a color to the list of fillings. Arguments Type Intent Optional Attributes Name type( sdr_subres_fills_type ), intent(inout) :: fills Table of color values to add a color definition to. character(len=*), intent(in) :: colorname Name of the color to define values for. real(kind=rk), intent(in) :: fill_value Value to use, where the domain is flooded by color. real(kind=rk), intent(in) :: void_value Value to use, where the domain is NOT flooded by color. integer, intent(out) :: pos Position of this color in the list of color values. logical, intent(out) :: wasAdded Indicator, if this value definition was added to the list. public  subroutine sdr_subres_fills_load (fills, conf, parent) Load the filling definition for subresolved colors. Read more… Arguments Type Intent Optional Attributes Name type( sdr_subres_fills_type ), intent(out) :: fills Value definitions for individual colors. type( flu_State ) :: conf Handle for the Lua script. integer, intent(in) :: parent Parent table, within which to open the fills table. public  subroutine load_single_fill (fills, conf, parent, pos) Load the value fill definition for a single color. Read more… Arguments Type Intent Optional Attributes Name type( sdr_subres_fills_type ), intent(inout) :: fills Value definitions for individual colors. type( flu_State ) :: conf Handle for the Lua script. integer, intent(in) :: parent Parent table, within which to open the fills table. integer, intent(in) :: pos Position in the table of fills to load.","tags":"","url":"module/sdr_subres_fills_module.html"},{"title":"ply_sampled_tracking_module – Seeder","text":"Tracking offers the possibility to extract data from a simulation for given\n subsections of the mesh and specific points in time. When the data is given in form of polynomials, it usually is required to\n perform some kind of sampling to obtain a visualization.\n The ply_sampled_tracking implements this functionality.\n See ply_sampling_module for details on the configuration of the sampling\n strategy and tem_tracking_module for details on the general configuration\n of trackings (description of mesh subsections to extract data for). An important special case is the tracking of a single point.\n In this case no sampling has to be done, instead the polynomial representing\n the state in the element that contains the requested point needs to be\n evaluated at this point. This can be configured by setting use_get_point=true in the output subtable of the tracking object. A complete example looks like this: tracking = { label = 'track_shearhat2D' , folder = './' , variable = { 'momentum' , 'density' , 'energy' }, shape = { kind = 'canoND' , object = { origin = { 0.01 * dx , 0. , 0. } } }, time_control = { min = 0 , max = sim_control . time_control . max , interval = { iter = 10 } }, output = { format = 'ascii' , use_get_point = true } } This tracks the state variables (momentum, density and energy) in a single\n point (0.01*dx, 0, 0) and writes them every ten iteration to an ASCII file.\n Each point in time gets written on a new line in the same file.\n If you do not use the use_get_point option (its false by default), and no\n sampling is active, all degrees of freedom of the field in the element, that\n contains the point, will be written.\n You can limit the number of degrees of freedom by setting ndofs to some\n value. The first mode of the Legendre series is the integral mean, so this is\n usually the value you want to get. Thus, setting ndofs=1 gives you the\n averaged value of the element the point is found in.\n The according output table would then look as follows: output = { format = 'ascii' , ndofs = 1 } Of course, more complex shapes may be tracked, in that case it usually is\n not sensible to use ascii output anymore. Instead you are than likely to\n want to view data later on and accordingly write it in VTK format.\n For this, a sampling table (see ply_sampling_module ) should be\n considered. Uses tem_bc_prop_module tem_solveHead_module tem_logging_module tem_reduction_spatial_module env_module tem_time_module tem_tracking_module tem_comm_env_module ply_sampling_module aotus_module treelmesh_module hvs_output_module tem_simControl_module tem_aux_module tem_stencil_module tem_varMap_module tem_varSys_module module~~ply_sampled_tracking_module~~UsesGraph module~ply_sampled_tracking_module ply_sampled_tracking_module aotus_module aotus_module module~ply_sampled_tracking_module->aotus_module env_module env_module module~ply_sampled_tracking_module->env_module hvs_output_module hvs_output_module module~ply_sampled_tracking_module->hvs_output_module ply_sampling_module ply_sampling_module module~ply_sampled_tracking_module->ply_sampling_module tem_aux_module tem_aux_module module~ply_sampled_tracking_module->tem_aux_module tem_bc_prop_module tem_bc_prop_module module~ply_sampled_tracking_module->tem_bc_prop_module tem_comm_env_module tem_comm_env_module module~ply_sampled_tracking_module->tem_comm_env_module tem_logging_module tem_logging_module module~ply_sampled_tracking_module->tem_logging_module tem_reduction_spatial_module tem_reduction_spatial_module module~ply_sampled_tracking_module->tem_reduction_spatial_module tem_simControl_module tem_simControl_module module~ply_sampled_tracking_module->tem_simControl_module tem_solveHead_module tem_solveHead_module module~ply_sampled_tracking_module->tem_solveHead_module tem_stencil_module tem_stencil_module module~ply_sampled_tracking_module->tem_stencil_module tem_time_module tem_time_module module~ply_sampled_tracking_module->tem_time_module tem_tracking_module tem_tracking_module module~ply_sampled_tracking_module->tem_tracking_module tem_varMap_module tem_varMap_module module~ply_sampled_tracking_module->tem_varMap_module tem_varSys_module tem_varSys_module module~ply_sampled_tracking_module->tem_varSys_module treelmesh_module treelmesh_module module~ply_sampled_tracking_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_sampled_tracking_module~~UsedByGraph module~ply_sampled_tracking_module ply_sampled_tracking_module module~sdr_hvs_config_module sdr_hvs_config_module module~sdr_hvs_config_module->module~ply_sampled_tracking_module program~sdr_harvesting sdr_harvesting program~sdr_harvesting->module~ply_sampled_tracking_module program~sdr_harvesting->module~sdr_hvs_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: ply_sampled_tracking_type Components Type Visibility Attributes Name Initial type( tem_tracking_type ), public :: tracking Contains all tracking headers, control and tracking entities\nactive on local process type( treelmesh_type ), public, allocatable :: mesh (:) Subsampled mesh for each tracking. Read more… type( tem_varSys_type ), public, allocatable :: varsys (:) Variable system description after subsampling. Read more… type(ply_sampling_type), public :: sampling Configuration of the subsampling (applied to all trackings). integer, public :: ndims Dimensionality of the data to sample. Subroutines public  subroutine ply_sampled_tracking_load (me, conf) Load the configuration of sampled tracking objects. Arguments Type Intent Optional Attributes Name type( ply_sampled_tracking_type ), intent(out) :: me Sampled tracking data to load from the config type( flu_State ) :: conf Lua config to load the tracking from public  subroutine ply_sampled_track_init (me, mesh, solver, varSys, bc, stencil, proc, nDofs, nDims) Initialize the sampled tracking entities. Read more… Arguments Type Intent Optional Attributes Name type( ply_sampled_tracking_type ), intent(inout) :: me Sampled tracking variable to initialize. It has to be configured by ply_sampled_tracking_load beforehand. type( treelmesh_type ), intent(in) :: mesh The global mesh. type( tem_solveHead_type ), intent(in) :: solver Information about the solver (used to construct file name strings). type( tem_varSys_type ), intent(in) :: varSys Global variable system with description of the data to get the\ntracking variables from. type( tem_BC_prop_type ), intent(in) :: bc Boundary condition properties, used to identify elements close to\nthe boundary. type( tem_stencilHeader_type ), intent(in), optional :: stencil Description of the stencil in the numerical scheme. Read more… type( tem_comm_env_type ), intent(in) :: proc General communication environment integer, intent(in) :: nDofs Number of degrees of freedom to use in the output. integer, intent(in) :: nDims Number of dimensions in the polynomial representations. public  subroutine ply_sampled_track_output (me, mesh, bc, solver, proc, varSys, var_degree, lvl_degree, var_space, simControl, time) Output sampled tracking data. Read more… Arguments Type Intent Optional Attributes Name type( ply_sampled_tracking_type ), intent(inout) :: me Sampled tracking instances. type( treelmesh_type ), intent(in) :: mesh Global mesh, required for the sampling. type( tem_BC_prop_type ), intent(in) :: bc Boundary properties, needed to inherit boundary information to refined\nmeshes and allow the extraction of boundary shape geometries. type( tem_solveHead_type ), intent(in) :: solver Information about the solver, needed for the output file name. type( tem_comm_env_type ), intent(in) :: proc General communication environment type( tem_varSys_type ), intent(in) :: varSys Original variable system integer, intent(in) :: var_degree (:) Maximal polynomial degree for each variable Read more… integer, intent(in) :: lvl_degree (:) Maximal polynomial degree for each level integer, intent(in) :: var_space (:) Maximal polynomial space for each variable Read more… type( tem_simControl_type ), intent(in), optional :: simControl Simulation control to determine, whether trackings should be written Read more… type( tem_time_type ), intent(in), optional :: time Provide a time for the current data set to write in tracking. Read more…","tags":"","url":"module/ply_sampled_tracking_module.html"},{"title":"ply_poly_transformation_module – Seeder","text":"Uses env_module treelmesh_module module~~ply_poly_transformation_module~~UsesGraph module~ply_poly_transformation_module ply_poly_transformation_module env_module env_module module~ply_poly_transformation_module->env_module treelmesh_module treelmesh_module module~ply_poly_transformation_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: ply_subsample_type Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. Is subsampling active integer, public :: sampling_lvl The current sampling lvl. integer, public :: caplevel = 20 Maximal Level down to which subsampling should be done. integer, public :: minsub = 0 Minimal subsampling depth: integer, public :: maxsub = 0 Maximal subsampling depth: real(kind=rk), public :: eps_osci Maximum allowed oscillation of the solution.\nFor adaptive subsampling only. real(kind=rk), public :: dofReducFactor Factor for the reduction of the degrees of freedom in one subsampling\nstep (per spatial direction). logical, public :: adaptiveDofReduction Indicator for limitation of total memory consumption integer, public :: AbsUpperBoundLevel Absolute upper bound level to refine to. type, public :: ply_array_type Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dat (:) Functions private  function ply_alpha (mode) result(alpha) Coefficients from the recursive formulation of legendre polynomials.\nL_n = alpha * x * L_n-1 + beta * L_n-2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The current mode in the polynomial representation. Return Value real(kind=rk) Alpha coefficient from the recursive formulation of legendre\npolynomials. private  function ply_beta (mode) result(beta) Coefficients from the recursive formulation of legendre polynomials.\nL_n = alpha * x * L_n-1 + beta * L_n-2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode The current mode in the polynomial representation. Return Value real(kind=rk) Beta coefficient from the recursive formulation of legendre\npolynomials. private  function ply_alpha_frac (denominator, numerator) result(alpha_frac) Quotient of two alpha values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Denominator integer, intent(in) :: numerator Numerator Return Value real(kind=rk) The quotient of two alpha values. private  function ply_alpha_beta (denominator, numerator) result(alpha_beta) Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: denominator Denominator integer, intent(in) :: numerator Numerator Return Value real(kind=rk) The product of alpha(n) * beta(d) / alpha(d) Subroutines public  subroutine ply_Poly_Transformation (subsamp, dofReduction, mesh, meshData, varDofs, varComps, ndims, refine_tree, new_refine_tree, newMeshData, newVarDofs) Projection of polynomial data from parent elements to child elements.\nThe projection is done by a direct transformation of the modal\ncoeffiecients to another coordinate system with z=ax+b. Arguments Type Intent Optional Attributes Name type( ply_subsample_type ), intent(in) :: subsamp Parameters for the subsampling real(kind=rk), intent(in) :: dofReduction (:) Factor for reduction of degrees of freedom. type( treelmesh_type ), intent(in) :: mesh The mesh related to meshData. type( ply_array_type ), intent(in) :: meshData (:) The data for subsampling. integer, intent(in) :: varDofs (:) The number of degrees of freedom for every variable. integer, intent(in) :: varComps (:) The number of components for every variable. integer, intent(in) :: ndims Number of dimensions in the polynomial representation. logical, intent(in) :: refine_tree (:) Logical array that marks elements for refinement\nof the previous sampling level. logical, intent(in) :: new_refine_tree (:) Logical array that marks elements for refinement. type( ply_array_type ), intent(out), allocatable :: newMeshData (:) The subsampled data for new_refine_tree. integer, intent(out), allocatable :: newVarDofs (:) The number of dofs for the subsampled data. private  subroutine ply_subsampleData (mesh, meshData, nDofs, nChildDofs, nComponents, refine_tree, new_refine_tree, nDims, subsamp, newMeshData) Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(in) :: mesh The mesh for the data. real(kind=rk), intent(in) :: meshData (:) The data to subsample integer, intent(in) :: nDofs The number of degrees of freedom. integer, intent(in) :: nChildDofs The number of degrees of freedom for the child elements. integer, intent(in) :: nComponents Number of Components. logical, intent(in) :: refine_tree (:) Logical array that marks all elements for refinement for the previous\nsampling level. logical, intent(in) :: new_refine_tree (:) Logical array that marks all elements for refinement for the current\nsampling level. integer, intent(in) :: nDims The number of dimensions in the polynomial representation. type( ply_subsample_type ), intent(in) :: subsamp Parameters for subsampling. real(kind=rk), intent(out), allocatable :: newMeshData (:) The subsampled Data. private  subroutine ply_projDataToChild (parentData, nParentDofs, nChildDofs, nComponents, nDimensions, nChilds, transform_matrix, childData) Subroutine to project element data from a parent cell to its children. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: parentData (:) The polynomial data for a single parent element. integer, intent(in) :: nParentDofs The number of dofs of the parent element. integer, intent(in) :: nChildDofs The total number of dofs for the child cells. integer, intent(in) :: nComponents The number of componentns for the given variable. integer, intent(in) :: nDimensions The number of dimensions. integer, intent(in) :: nChilds The number of child elements. real(kind=rk), intent(in) :: transform_matrix (:,:) The transformation matrix for the linear coordinate transformation. real(kind=rk), intent(out), allocatable :: childData (:) The new data representation for all child cell of the parent cell. private  subroutine ply_transform_matrix (max_modes, v) Compute the transformation matrix for a projection to the left and right\nhalf-interval of Legendre polynomials for the given maximal number of\nmodes. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: max_modes The maximal number of modes to compute the transformation for. Read more… real(kind=rk), intent(out), allocatable :: v (:,:) The transformation matrix. Read more…","tags":"","url":"module/ply_poly_transformation_module.html"},{"title":"ply_sampling_varsys_module – Seeder","text":"Managing the variable system description for sampled data. Uses env_module tem_time_module tem_tracking_module treelmesh_module tem_topology_module tem_varSys_module module~~ply_sampling_varsys_module~~UsesGraph module~ply_sampling_varsys_module ply_sampling_varsys_module env_module env_module module~ply_sampling_varsys_module->env_module tem_time_module tem_time_module module~ply_sampling_varsys_module->tem_time_module tem_topology_module tem_topology_module module~ply_sampling_varsys_module->tem_topology_module tem_tracking_module tem_tracking_module module~ply_sampling_varsys_module->tem_tracking_module tem_varSys_module tem_varSys_module module~ply_sampling_varsys_module->tem_varSys_module treelmesh_module treelmesh_module module~ply_sampling_varsys_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_sampling_varsys_module~~UsedByGraph module~ply_sampling_varsys_module ply_sampling_varsys_module module~ply_sampling_adaptive_module ply_sampling_adaptive_module module~ply_sampling_adaptive_module->module~ply_sampling_varsys_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: ply_sampling_var_type Small helping type to allow arrays of arrays for the variable data. Components Type Visibility Attributes Name Initial integer, public :: nDeviating integer, public, allocatable :: degree (:) integer, public, allocatable :: first (:) real(kind=rk), public, pointer :: dat (:) logical, public, allocatable :: deviates (:) Subroutines public  subroutine ply_sampling_varsys_for_track (varsys, trackInst, mesh, nDims, lvl_degree, sample_varsys, var, time) Create a variable system for the given tracking instance. Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(in) :: varsys Variable system describing the access to the original data to sample. type( tem_tracking_instance_type ), intent(in) :: trackInst The tracking object that should be sampled. type( treelmesh_type ), intent(in) :: mesh Original mesh describing the spatial organisation of the data to\nsample. integer, intent(in) :: nDims Dimensionality of the data to sample. integer, intent(in) :: lvl_degree (:) Maximal polynomial degree for each level. type( tem_varSys_type ), intent(out) :: sample_varsys Variable system for the sampled data. type( ply_sampling_var_type ), pointer :: var (:) Extracted data for all the variables requested in the given tracking\ninstance. type( tem_time_type ), intent(in) :: time Point in time to get the data for. public  subroutine ply_sampling_var_allocate (var, nElems, datalen) Allocate memory for a sampled variable. Arguments Type Intent Optional Attributes Name type( ply_sampling_var_type ), intent(inout) :: var The variable to allocate the space for. integer, intent(in) :: nElems Number of elements the data lives in. integer, intent(in) :: datalen Size of the container to use for representation of the polynomial\ndata across all elements. public  subroutine ply_sampling_var_move (source, destination) Move the variable data from source to destination. Read more… Arguments Type Intent Optional Attributes Name type( ply_sampling_var_type ), pointer :: source (:) Variable data to move (and make accessible via destination). Read more… type( ply_sampling_var_type ), pointer :: destination (:) Pointer to refer to the data in source. If destination already\ncontains data, this data will be discarded. public  subroutine ply_sampling_var_compute_elemdev (var, threshold, min_mean) This routine computes for each element whether the solution in it is\nconsidered to be deviating from the mean above the given threshold or\nnot. The logical result is stored in var%deviates for each element. Read more… Arguments Type Intent Optional Attributes Name type( ply_sampling_var_type ), intent(inout) :: var Variable data to compute the deviation for. real(kind=rk), intent(in) :: threshold Relative threshold to use as decision whether an element has a high\ndeviation or not. Read more… real(kind=rk), intent(in) :: min_mean A minimal mean value to use as comparison (to cut off changes that are\ntoo close to 0). Read more…","tags":"","url":"module/ply_sampling_varsys_module.html"},{"title":"ply_subresolution_module – Seeder","text":"Uses tem_subres_prop_module tem_tools_module tem_color_prop_module tem_logging_module env_module tem_time_module ply_transfer_module tem_comm_env_module ply_dof_module aotus_module treelmesh_module iso_c_binding tem_aux_module tem_varSys_module module~~ply_subresolution_module~~UsesGraph module~ply_subresolution_module ply_subresolution_module aotus_module aotus_module module~ply_subresolution_module->aotus_module env_module env_module module~ply_subresolution_module->env_module iso_c_binding iso_c_binding module~ply_subresolution_module->iso_c_binding ply_dof_module ply_dof_module module~ply_subresolution_module->ply_dof_module ply_transfer_module ply_transfer_module module~ply_subresolution_module->ply_transfer_module tem_aux_module tem_aux_module module~ply_subresolution_module->tem_aux_module tem_color_prop_module tem_color_prop_module module~ply_subresolution_module->tem_color_prop_module tem_comm_env_module tem_comm_env_module module~ply_subresolution_module->tem_comm_env_module tem_logging_module tem_logging_module module~ply_subresolution_module->tem_logging_module tem_subres_prop_module tem_subres_prop_module module~ply_subresolution_module->tem_subres_prop_module tem_time_module tem_time_module module~ply_subresolution_module->tem_time_module tem_tools_module tem_tools_module module~ply_subresolution_module->tem_tools_module tem_varSys_module tem_varSys_module module~ply_subresolution_module->tem_varSys_module treelmesh_module treelmesh_module module~ply_subresolution_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_subresolution_module~~UsedByGraph module~ply_subresolution_module ply_subresolution_module module~sdr_hvs_props_module sdr_hvs_props_module module~sdr_hvs_props_module->module~ply_subresolution_module module~sdr_hvs_config_module sdr_hvs_config_module module~sdr_hvs_config_module->module~sdr_hvs_props_module program~sdr_harvesting sdr_harvesting program~sdr_harvesting->module~sdr_hvs_props_module program~sdr_harvesting->module~sdr_hvs_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: ply_subresolution_type Components Type Visibility Attributes Name Initial integer, public :: polydegree = 0 integer, public :: basisType type( tem_subres_prop_type ), public :: subres_prop type, public :: ply_subres_colvar_type Self contained description of color data to be used for method data. Components Type Visibility Attributes Name Initial type( tem_color_prop_type ), public, pointer :: color => NULL() Pointer to the overall color property description. type( ply_subresolution_type ), public, pointer :: subres => NULL() Pointer to the overall subresolution property description. real(kind=rk), public, allocatable :: subresdat (:,:) Degrees of freedom for subresolved elements. integer, public :: nsubdofs Number of degrees of freedom of the subresolution data. integer, public :: colpos Position of this color in the list of colors, needed to make use of the\npointers above. Subroutines public  subroutine ply_subresolution_load (me, tree, proc, coloring) Subroutine to load subresolution information for a given tree. Arguments Type Intent Optional Attributes Name type( ply_subresolution_type ), intent(out) :: me type( treelmesh_type ), intent(in) :: tree type( tem_comm_env_type ), intent(in) :: proc type( tem_color_prop_type ), intent(in) :: coloring public  subroutine ply_subres_import_color (me, tree, coloring, iColor, target_degree, target_space, target_dim, subresdat) Get the subresolution data for all elements for a given color and in the\nrequested format. Arguments Type Intent Optional Attributes Name type( ply_subresolution_type ), intent(in) :: me type( treelmesh_type ), intent(in) :: tree type( tem_color_prop_type ), intent(in) :: coloring integer, intent(in) :: iColor integer, intent(in) :: target_degree integer, intent(in) :: target_space integer, intent(in) :: target_dim real(kind=rk), intent(out), allocatable :: subresdat (:,:) public  subroutine ply_subres_get_elemcolor (fun, varSys, elempos, time, tree, nElems, nDofs, res) Get the color of an element. Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) TreeID of the element to get the variable for. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of elements to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more…","tags":"","url":"module/ply_subresolution_module.html"},{"title":"sdr_transformation_module – Seeder","text":"This module provide datatype and routine for transformation of\ngeometrical objects i.e translation and deformation Uses tem_tools_module tem_logging_module flu_binding aot_table_module env_module tem_canonicalND_module aotus_module tem_aux_module module~~sdr_transformation_module~~UsesGraph module~sdr_transformation_module sdr_transformation_module aot_table_module aot_table_module module~sdr_transformation_module->aot_table_module aotus_module aotus_module module~sdr_transformation_module->aotus_module env_module env_module module~sdr_transformation_module->env_module flu_binding flu_binding module~sdr_transformation_module->flu_binding tem_aux_module tem_aux_module module~sdr_transformation_module->tem_aux_module tem_canonicalND_module tem_canonicalND_module module~sdr_transformation_module->tem_canonicalND_module tem_logging_module tem_logging_module module~sdr_transformation_module->tem_logging_module tem_tools_module tem_tools_module module~sdr_transformation_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface sdr_transformcanoND This routine apply transformations to canonical objects private  subroutine transformCanoND (canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND (:) canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object private  subroutine transformCanoND_single (canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object Derived Types type, public :: sdr_translation_type Data type defines geometry translation Components Type Visibility Attributes Name Initial logical, public :: active Is translation defined real(kind=rk), public :: vec (3) vector defining translation in x,y,z direction type, public :: sdr_deformation_type Data type defines geometry scale and rotation Components Type Visibility Attributes Name Initial logical, public :: active Is deformation defined real(kind=rk), public :: matrix (3,3) matrix defining the deformation type, public :: sdr_transformation_type Data type defines geometry transformation Components Type Visibility Attributes Name Initial logical, public :: active is transformation active type( sdr_translation_type ), public :: translate translation of geometry type( sdr_deformation_type ), public :: deform deformation of geometry Subroutines public  subroutine sdr_load_transformation (transform, conf, thandle) This routine loads the transformation table for each spatial object table\nin config file Read more… Arguments Type Intent Optional Attributes Name type( sdr_transformation_type ), intent(out) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle spatial object parent handle private  subroutine sdr_load_translation (translate, conf, thandle) This routine loads the translation table from transformation table Arguments Type Intent Optional Attributes Name type( sdr_translation_type ), intent(out) :: translate translate for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle spatial object parent handle private  subroutine sdr_load_deformation (deform, conf, thandle) This routine loads the deformation table from transformation table Arguments Type Intent Optional Attributes Name type( sdr_deformation_type ), intent(out) :: deform deform for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle spatial object parent handle private  subroutine transformCanoND (canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND (:) canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object private  subroutine transformCanoND_single (canoND, transform) This routine apply transformation to canonical objects. Arguments Type Intent Optional Attributes Name type( tem_canonicalND_type ), intent(inout) :: canoND canonical geometry object type type( sdr_transformation_type ), intent(in) :: transform transformation for spatial object","tags":"","url":"module/sdr_transformation_module.html"},{"title":"sdr_flooding_module – Seeder","text":"This module provides the functionality to find the part of the universe\ncube, which is actually building up the computational domain. Uses tem_tools_module sdr_geometry_module tem_param_module tem_logging_module sdr_protoTree_module env_module tem_geometry_module sdr_boundary_module tem_debug_module tem_timer_module sdr_config_module sdr_timer_module tem_topology_module treelmesh_module sdr_node_module module~~sdr_flooding_module~~UsesGraph module~sdr_flooding_module sdr_flooding_module env_module env_module module~sdr_flooding_module->env_module module~sdr_boundary_module sdr_boundary_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_config_module sdr_config_module module~sdr_flooding_module->module~sdr_config_module module~sdr_geometry_module sdr_geometry_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_timer_module sdr_timer_module module~sdr_flooding_module->module~sdr_timer_module sdr_node_module sdr_node_module module~sdr_flooding_module->sdr_node_module tem_debug_module tem_debug_module module~sdr_flooding_module->tem_debug_module tem_geometry_module tem_geometry_module module~sdr_flooding_module->tem_geometry_module tem_logging_module tem_logging_module module~sdr_flooding_module->tem_logging_module tem_param_module tem_param_module module~sdr_flooding_module->tem_param_module tem_timer_module tem_timer_module module~sdr_flooding_module->tem_timer_module tem_tools_module tem_tools_module module~sdr_flooding_module->tem_tools_module tem_topology_module tem_topology_module module~sdr_flooding_module->tem_topology_module treelmesh_module treelmesh_module module~sdr_flooding_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_flooding_module~~UsedByGraph module~sdr_flooding_module sdr_flooding_module program~seeder seeder program~seeder->module~sdr_flooding_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_flood_tree (proto, geometry, header, meshUniverse) This routine identifies the nodes, which are supposed to be part of the\ncomputational domain, as defined by the seed objects. Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. type( sdr_geometry_type ), intent(in) :: geometry Description of geometric objects. Propably not needed here, remove again\nif this is the case. type( sdr_confHead_type ), intent(inout) :: header some global information on solver name and version type( treelmesh_type ), intent(in) :: meshUniverse treelmesh contains bounding cube info private  subroutine floodwaves_tree (proto, header, geometry) This routine loop over all nodes are flood non-interesting leaf node with\nwet face and inherit the wetness of the virtual node to the eligble\nchildrens Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. type( sdr_confHead_type ), intent(in), optional :: header some global information on solver name and version type( sdr_geometry_type ), intent(in) :: geometry private  subroutine flood_periphery (proto, geometry, meshUniverse) This routine loops over all intersected with geoemtry nodes and fluidify\n some node according to the following rule:\\n\n 1. one of its link does noe intersect with any geometry that requires qVal\n 2. it has fluid neighbor on that direction.\n    i.e. it is wet in that side.\n Jiaxing Qi Read more… Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. type( sdr_geometry_type ), intent(in) :: geometry Description of geometric objects. type( treelmesh_type ), intent(in) :: meshUniverse treelmesh contains bounding cube info private  subroutine flood_periphery_diagonal (proto, node_pos, treeID, qVal, iColor) This routine checks for qVal of the periphery and floods if qVal < 0 and\nthe node in that direction is fluid and not intersected by boundary Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. integer, intent(in) :: node_pos node position in protoTree integer(kind=long_k), intent(in) :: treeID treeID of current node real(kind=rk) :: qVal (:) qVal for all 26 neighbor directions, should be calculated already integer, intent(in) :: iColor Color to do the flooding in private  subroutine flood_parents (proto, color_inverted) Mark all virtual nodes, which contain a flooded child as flooded\nstarting from the second finest level moving up to the root.\nThis allows to easily avoid non-flooded domains later on. Arguments Type Intent Optional Attributes Name type( sdr_protoTree_type ), intent(inout) :: proto The proto tree description with all the data enabling the flooding. logical, intent(in) :: color_inverted (:) List of flags for each color to indicate, wether the color should be\ninverted after flooding.","tags":"","url":"module/sdr_flooding_module.html"},{"title":"sdr_cylinder_module – Seeder","text":"This module contain adapter routine to load cylinder objects and add them to\nlist of spatial objects Uses tem_logging_module tem_param_module aot_table_module env_module tem_cylinder_module aotus_module tem_aux_module sdr_spatialObj_module tem_transformation_module module~~sdr_cylinder_module~~UsesGraph module~sdr_cylinder_module sdr_cylinder_module aot_table_module aot_table_module module~sdr_cylinder_module->aot_table_module aotus_module aotus_module module~sdr_cylinder_module->aotus_module env_module env_module module~sdr_cylinder_module->env_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_cylinder_module->sdr_spatialObj_module tem_aux_module tem_aux_module module~sdr_cylinder_module->tem_aux_module tem_cylinder_module tem_cylinder_module module~sdr_cylinder_module->tem_cylinder_module tem_logging_module tem_logging_module module~sdr_cylinder_module->tem_logging_module tem_param_module tem_param_module module~sdr_cylinder_module->tem_param_module tem_transformation_module tem_transformation_module module~sdr_cylinder_module->tem_transformation_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_cylinder_module~~UsedByGraph module~sdr_cylinder_module sdr_cylinder_module module~sdr_geometry_module sdr_geometry_module module~sdr_geometry_module->module~sdr_cylinder_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_geometry_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_geometry_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_load_cylinder (cylArray, spaObjArray, attr_pos, transform, conf, thandle) \\brief Loading cylinder information from config file \\n Arguments Type Intent Optional Attributes Name type( grw_cylinderarray_type ), intent(inout) :: cylArray growing array of cylinders type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle public  subroutine append_cylinder2SpaObj (cylArray, spaObjArray, attr_pos, loc_cylinder) This routine single cylinder from object table Arguments Type Intent Optional Attributes Name type( grw_cylinderarray_type ), intent(inout) :: cylArray growing array of cylinders type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_cylinder_type ), intent(in) :: loc_cylinder","tags":"","url":"module/sdr_cylinder_module.html"},{"title":"ply_lagrange_module – Seeder","text":"Lagrange polynomial representation. Lagrange polynomial series by the values at given nodes.\nThe nodes to be used are to be given in form of ply_nodeset_coords . Uses env_module ply_nodeset_module module~~ply_lagrange_module~~UsesGraph module~ply_lagrange_module ply_lagrange_module env_module env_module module~ply_lagrange_module->env_module module~ply_nodeset_module ply_nodeset_module module~ply_lagrange_module->module~ply_nodeset_module module~ply_nodeset_module->env_module tem_param_module tem_param_module module~ply_nodeset_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_lagrange_module~~UsedByGraph module~ply_lagrange_module ply_lagrange_module module~ply_l2p_module ply_l2p_module module~ply_l2p_module->module~ply_lagrange_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: ply_lagrange_type Components Type Visibility Attributes Name Initial integer, public :: nPoints Number of points to represent the Lagrange polynomials real(kind=rk), public, allocatable :: coords (:) Coordinates of the points where the nodes are to be found. real(kind=rk), public, allocatable :: values (:) Values of the function at all coords. Functions public  function ply_lagrange_define (nPoints, nodeset, values) result(me) Define a new polynomial in the Lagrange basis. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints Number of points to define the polynomial. procedure( ply_nodeset_coords ) :: nodeset The set of nodes where the function assumes the given values. real(kind=rk), intent(in) :: values (nPoints) Function values at all nPoints of the nodeset. Return Value type( ply_lagrange_type ) The newly created Lagrange series describing the polynomial function. public  function ply_lagrange_eval (me, x) result(f) Evaluate a polynomial in the Lagrange basis at some point x. Arguments Type Intent Optional Attributes Name type( ply_lagrange_type ), intent(in) :: me The polynomial in Lagrange basis to evaluate at point x. real(kind=rk), intent(in) :: x Coordinate at which the function is to be evaluated. Return Value real(kind=rk) Value of the polynomial at coordinate x. public  function ply_lagrange_mode_at (me, mode, x) result(f) Evaluate the given Lagrangian mode (which is 1 at coord(mode) and 0 in\nall other points) at a given point x. Arguments Type Intent Optional Attributes Name type( ply_lagrange_type ), intent(in) :: me The polynomial in Lagrange basis. integer, intent(in) :: mode Mode to evaluate at x. Read more… real(kind=rk), intent(in) :: x Coordinate at which the mode is to be evaluated. Return Value real(kind=rk) Value of the polynomial at coordinate x. public  function ply_lagrange_1D (me, points) result(pointval) Arguments Type Intent Optional Attributes Name type( ply_lagrange_type ), intent(in) :: me Definition of the Lagrange polynomial basis to evaluate at points. real(kind=rk), intent(in) :: points (:) List of points at which the polynomials are to be evaluated. Return Value real(kind=rk), (me%nPoints,size(points)) Resulting Lagrange values at all points. First dimension holds the Lagrange modes, second dimension the\npoints.","tags":"","url":"module/ply_lagrange_module.html"},{"title":"sdr_geometry_module – Seeder","text":"This module provides the description of the complete geometry to mesh. Uses tem_box_module tem_triangle_module sdr_attribute_module tem_cube_module tem_aux_module sdr_canonicalND_module tem_tools_module tem_dyn_array_module tem_line_module tem_sphere_module env_module tem_point_module tem_cylinder_module sdr_spatialObj_module sdr_spacer_module tem_logging_module sdr_triangle_module sdr_sphere_module tem_ellipsoid_module tem_stl_module sdr_periodic_module aotus_module sdr_cylinder_module tem_transformation_module tem_grow_array_module flu_binding aot_table_module sdr_ellipsoid_module sdr_stl_module module~~sdr_geometry_module~~UsesGraph module~sdr_geometry_module sdr_geometry_module aot_table_module aot_table_module module~sdr_geometry_module->aot_table_module aotus_module aotus_module module~sdr_geometry_module->aotus_module env_module env_module module~sdr_geometry_module->env_module flu_binding flu_binding module~sdr_geometry_module->flu_binding module~sdr_canonicalnd_module sdr_canonicalND_module module~sdr_geometry_module->module~sdr_canonicalnd_module module~sdr_cylinder_module sdr_cylinder_module module~sdr_geometry_module->module~sdr_cylinder_module module~sdr_ellipsoid_module sdr_ellipsoid_module module~sdr_geometry_module->module~sdr_ellipsoid_module module~sdr_sphere_module sdr_sphere_module module~sdr_geometry_module->module~sdr_sphere_module module~sdr_stl_module sdr_stl_module module~sdr_geometry_module->module~sdr_stl_module module~sdr_triangle_module sdr_triangle_module module~sdr_geometry_module->module~sdr_triangle_module sdr_attribute_module sdr_attribute_module module~sdr_geometry_module->sdr_attribute_module sdr_periodic_module sdr_periodic_module module~sdr_geometry_module->sdr_periodic_module sdr_spacer_module sdr_spacer_module module~sdr_geometry_module->sdr_spacer_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_geometry_module->sdr_spatialObj_module tem_aux_module tem_aux_module module~sdr_geometry_module->tem_aux_module tem_box_module tem_box_module module~sdr_geometry_module->tem_box_module tem_cube_module tem_cube_module module~sdr_geometry_module->tem_cube_module tem_cylinder_module tem_cylinder_module module~sdr_geometry_module->tem_cylinder_module tem_dyn_array_module tem_dyn_array_module module~sdr_geometry_module->tem_dyn_array_module tem_ellipsoid_module tem_ellipsoid_module module~sdr_geometry_module->tem_ellipsoid_module tem_grow_array_module tem_grow_array_module module~sdr_geometry_module->tem_grow_array_module tem_line_module tem_line_module module~sdr_geometry_module->tem_line_module tem_logging_module tem_logging_module module~sdr_geometry_module->tem_logging_module tem_point_module tem_point_module module~sdr_geometry_module->tem_point_module tem_sphere_module tem_sphere_module module~sdr_geometry_module->tem_sphere_module tem_stl_module tem_stl_module module~sdr_geometry_module->tem_stl_module tem_tools_module tem_tools_module module~sdr_geometry_module->tem_tools_module tem_transformation_module tem_transformation_module module~sdr_geometry_module->tem_transformation_module tem_triangle_module tem_triangle_module module~sdr_geometry_module->tem_triangle_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_geometry_module~~UsedByGraph module~sdr_geometry_module sdr_geometry_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_geometry_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_geometry_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_geometry_type Geometric description of the space to mesh. Components Type Visibility Attributes Name Initial type( tem_cube_type ), public :: universe The universe given as a bounding cube. type( grw_pointarray_type ), public :: point growing array of all points type( grw_linearray_type ), public :: line growing array of all lines type( grw_trianglearray_type ), public :: triangle growing array of all triangles type( grw_boxarray_type ), public :: box growing array of all boxes type(grw_periPlaneArray_type), public :: periPlane growing array of periodic plane objects type( grw_spherearray_type ), public :: sphere growing array of spheres type( grw_ellipsoidarray_type ), public :: ellipsoid growing array of spheres type( grw_cylinderarray_type ), public :: cylinder growing array of cylinders type(grw_spacerInterwovenArray_type), public :: spacerInterwoven growing array of spacer type(grw_spatialObjArray_type), public :: spatialObj Growing array of geometrical objects. type(sdr_attrList_type), public :: attribute Dynamic Unique array of attributes connected to the objects\n(seed, boundary or refinement) logical, public :: smoothbounds = .true. Smooth refinement towards boundaries. logical, public :: smoothLevels = .true. Smooth level jumps, avoid level jump > 1 in domain integer, public :: nUserObjs Number of user defined spatial objects\ni.e excluding spatial objects created for distance refine Functions public  function is_intersecting (cube, geometry, obj_pos) result(intersects) Test the intersection between the given cube and the object specified by\nobj_pos. Read more… Arguments Type Intent Optional Attributes Name type( tem_cube_type ), intent(in) :: cube type( sdr_geometry_type ), intent(in) :: geometry integer, intent(in) :: obj_pos Return Value logical Subroutines public  subroutine sdr_load_geometry (me, subres_colors, invert_colors, conf) Routine to load spatial object defined in config file and store in \ngeometry type Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(out) :: me contains all geometry infomation type( dyn_labelarray_type ), intent(in) :: subres_colors All the colors, which should be default use subelement resolution for\ntheir boundaries. type( dyn_labelarray_type ), intent(in) :: invert_colors type( flu_State ) :: conf public  subroutine sdr_load_spatialObject_single (me, subres_colors, conf, thandle) Routine to load single spatial object table defined in config file Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(inout) :: me contains all geometry infomation type( dyn_labelarray_type ), intent(in) :: subres_colors All the colors, which should be default use subelement resolution for\ntheir boundaries. type( flu_State ) :: conf integer, intent(in) :: thandle public  subroutine sdr_load_geom_table (me, conf, thandle, attr_pos, transform) This routine loads the geometry table from the config file i.e loading\ndifferent geometry kinds like canoND, cube, periodic, STL etc. Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(inout) :: me type( flu_State ) :: conf integer, intent(in) :: thandle integer, intent(in) :: attr_pos Position of the attribute to connect the geometric objects to. type( tem_transformation_type ), intent(in) :: transform public  subroutine sdr_load_geom_table_single (me, conf, thandle, attr_pos, transform) This routine reads a single geometry table from the config file i.e \nloading different geometry kinds like canoND, cube, periodic, STL etc. Arguments Type Intent Optional Attributes Name type( sdr_geometry_type ), intent(inout) :: me type( flu_State ) :: conf integer, intent(in) :: thandle integer, intent(in) :: attr_pos Position of the attribute to connect all primitives to. type( tem_transformation_type ), intent(in) :: transform public  subroutine sdr_append_distanceRefineObject (coord, dx, iLevel, geometry, intersected_first, intersected_last, intersected_object) This routine created sphere objects and new attribute and extend \na list of spatial objects if node intersected boundary has distance \nrefine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: coord (4) Coordinate of current node real(kind=rk), intent(in) :: dx integer, intent(in) :: iLevel Current node level type( sdr_geometry_type ), intent(inout) :: geometry type which contains all geometry object infos integer, intent(in) :: intersected_first This node's first position in intersected_object integer, intent(in) :: intersected_last This node's last position in intersected_object type( grw_intarray_type ), intent(in) :: intersected_object Growing array of intersected_objects","tags":"","url":"module/sdr_geometry_module.html"},{"title":"ply_nodeset_module – Seeder","text":"Collection of node sets to use in the nodal representation of the solution. Node distributions on the reference interval [-1,1] are to be described by\nfunctions that satisfy the ply_nodeset_coords interface and return an\narray of 1D coordinates for the given number of points. The following sets of nodes are available: ply_nodeset_legendre the nodes of the Gauss-Legendre integration ply_nodeset_chebyshev the nodes of the Chebyshev integration ply_nodeset_chebyloba the nodes of the Chebyshev-Lobatto integration\n  (includes the interval boundaries) Uses env_module tem_param_module module~~ply_nodeset_module~~UsesGraph module~ply_nodeset_module ply_nodeset_module env_module env_module module~ply_nodeset_module->env_module tem_param_module tem_param_module module~ply_nodeset_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_nodeset_module~~UsedByGraph module~ply_nodeset_module ply_nodeset_module module~ply_l2p_module ply_l2p_module module~ply_l2p_module->module~ply_nodeset_module module~ply_lagrange_module ply_lagrange_module module~ply_l2p_module->module~ply_lagrange_module module~ply_lagrange_module->module~ply_nodeset_module module~ply_nodes_module ply_nodes_module module~ply_nodes_module->module~ply_nodeset_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public  function ply_nodeset_coords(nPoints) result(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of points to create. Return Value real(kind=rk), (nPoints) The coordinates of the nodeset in the interval [-1,1].\nThe array has to have the length nPoints. Functions public  function ply_nodeset_legendre (nPoints) result(x) Compute Gauss-Legendre integration points on the interval [-1,1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of integration points. Return Value real(kind=rk), (nPoints) The coordinates of the Legendre points on the interval [-1,1].\nThe array has to have the length nPoints. public  function ply_nodeset_chebyshev (nPoints) result(x) Generates a given number of Chebyshev points on the unit interval [-1;+1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of points to generate Return Value real(kind=rk), (nPoints) The coordinates of the Chebyshev points on the interval [-1,1].\nThe array has to have the length nPoints. public  function ply_nodeset_chebyloba (nPoints) result(x) Generates a given number of Chebyshev-Lobatto points on the unit interval\n[-1;+1]. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPoints The number of points to generate Return Value real(kind=rk), (nPoints) The coordinates of the Chebyshev-Lobatto points on the interval [-1,1].\nThe array has to have the length nPoints.","tags":"","url":"module/ply_nodeset_module.html"},{"title":"sdr_triangle_module – Seeder","text":"\\brief This module is an adapter to tem_triangle_module, Contains \na routine to load triangle and added it to list of spatial objects Uses tem_logging_module tem_triangle_module aotus_module sdr_spatialObj_module tem_transformation_module module~~sdr_triangle_module~~UsesGraph module~sdr_triangle_module sdr_triangle_module aotus_module aotus_module module~sdr_triangle_module->aotus_module sdr_spatialObj_module sdr_spatialObj_module module~sdr_triangle_module->sdr_spatialObj_module tem_logging_module tem_logging_module module~sdr_triangle_module->tem_logging_module tem_transformation_module tem_transformation_module module~sdr_triangle_module->tem_transformation_module tem_triangle_module tem_triangle_module module~sdr_triangle_module->tem_triangle_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_triangle_module~~UsedByGraph module~sdr_triangle_module sdr_triangle_module module~sdr_geometry_module sdr_geometry_module module~sdr_geometry_module->module~sdr_triangle_module module~sdr_boundary_module sdr_boundary_module module~sdr_boundary_module->module~sdr_geometry_module module~sdr_prototree_module sdr_protoTree_module module~sdr_boundary_module->module~sdr_prototree_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_geometry_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_geometry_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_flooding_module->module~sdr_config_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_geometry_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_prototree_module->module~sdr_geometry_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_geometry_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_geometry_module program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_load_triangle (triArray, spaObjArray, attr_pos, transform, conf, thandle) Load triangle information from config file. Arguments Type Intent Optional Attributes Name type( grw_trianglearray_type ), intent(inout) :: triArray growing array of triangles type(grw_spatialObjArray_type), intent(inout) :: spaObjArray growing array of geometrical objects. integer, intent(in) :: attr_pos Position of the attribute to connect this object to. type( tem_transformation_type ), intent(in) :: transform transformation for spatial object type( flu_State ) :: conf lua state integer, intent(in) :: thandle","tags":"","url":"module/sdr_triangle_module.html"},{"title":"ply_split_element_module – Seeder","text":"This module provides the methods to project the polynomial representation in\nelements onto the representations in their halves in each dimension. To perform the projection for Legendre polynomials we will use the computed\ncoefficients for the Clenshaw algorithm from ply_split_legendre_module .\nWith those the transformation is just a simple triangular matrix\nmultiplication, but we need to take care of the orthogonal degrees of freedom\nas we want to handle all of them at the same time.\nFurther we want to allow the transformation to be performed for multiple\nelements at once. In each dimension we need to perform the following coordinate transformation: Where refers to the coordinate in the original (coarse) element, and to the coordinates in the two (left and right) halves of the element. Uses env_module ply_modg_basis_module ply_split_legendre_module module~~ply_split_element_module~~UsesGraph module~ply_split_element_module ply_split_element_module env_module env_module module~ply_split_element_module->env_module module~ply_split_legendre_module ply_split_legendre_module module~ply_split_element_module->module~ply_split_legendre_module ply_modg_basis_module ply_modg_basis_module module~ply_split_element_module->ply_modg_basis_module module~ply_split_legendre_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_split_element_module~~UsedByGraph module~ply_split_element_module ply_split_element_module module~ply_sampling_adaptive_module ply_sampling_adaptive_module module~ply_sampling_adaptive_module->module~ply_split_element_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: split_legendre (:,:) Precomputed matrix to hold the transformation operation to project\nLegendre polynomials to its two half intervals. This is computed by ply_split_legendre_matrix , see there for details.\nThere are two triangular matrices stored in this array, one for the\nprojection to the left half (-1,0) , and one for the projection to the\nright half (0,1). This is a module variable, as it is only needed to be computed once with\nsufficient size. All lower orders are just subarrays out of the larger one. Abstract Interfaces abstract interface public  subroutine ply_split_element(parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Split elements of degree parent_degree into elements with polynomials of\ndegree child_degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Elements follow the ordering of the Z space filling curve. logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. This can be used as a simple lowpass filter by ignoring all higher\nmodes from the parent element, that exceed the target polynomial\ndegree. Thus, the polynomials are filtered before projection,\ninstead of cutting them only of after refinement.\nDefaults to false (no filtering). Subroutines public  subroutine ply_split_element_init (nMaxModes) Initialization of the module.\nThis needs to be performed before any call of the actual transformation ply_split_element_1D . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nMaxModes Maximal number of expected modes to perform the splitting for. public  subroutine ply_split_element_singleD (nDims, inLen, outLen, parent_data, child_data, ignore) Project a polynomial representation in elements in one dimension to its\n two halves in that direction. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDims Number of dimensions of the polynomial data. integer, intent(in) :: inLen (nDims) Number degrees of freedom for each direction in parent_Data. Read more… integer, intent(in) :: outLen (nDims) Number degrees of freedom for each direction in child_Data. Read more… real(kind=rk), intent(in) :: parent_data (:,:) Polynomial representation in the parent elements. Read more… real(kind=rk), intent(out) :: child_data (:,:) Computed projection of the polynomial representation in the child\nelements. Read more… logical, intent(in) :: ignore Whether to ignore high modes that exceed the target maximal polynomial\ndegree. Read more… public  subroutine ply_split_element_1D (parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Split one-dimensional elements of degree parent_degree into two elements\nwith polynomials of degree child_degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Read more… logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. Read more… public  subroutine ply_split_element_2D (parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Split two-dimensional elements of degree parent_degree into four elements\nwith polynomials of degree child_degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Read more… logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. Read more… public  subroutine ply_split_element_3D (parent_degree, child_degree, parent_data, child_data, ignore_highmodes) Split three-dimensional elements of degree parent_degree into eight\nelements with polynomials of degree child_degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_degree Polynomial degree in the parent element. integer, intent(in) :: child_degree Polynomial degree in the child elements. real(kind=rk), intent(in) :: parent_data (:,:) Polynomial data in the parent element. The first index describes the\ndegrees of freedom. The second index refers to the elements to split. real(kind=rk), intent(out) :: child_data (:,:) Polynomial data in the child elements. The first index describes the\ndegrees of freedom. The second index refers to the elements, there\nneeds to be four times as many elements than in the parent_data. Read more… logical, intent(in), optional :: ignore_highmodes Whether to ignore high modes from the parent element. Read more… public  subroutine ply_split_element_test (success) Testing routine for the functions of this module. Arguments Type Intent Optional Attributes Name logical, intent(out) :: success Indication whether the tests were completed successfully. private  subroutine ply_split_element_1D_test (nModes, success) Testing the 1D splitting. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of modes in the (1D) polynomials to use in the check. logical, intent(out) :: success Indication whether the tests were completed successfully. private  subroutine ply_split_element_2D_test (nModes, success) Testing the 2D splitting. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of modes in the (1D) polynomials to use in the check. logical, intent(out) :: success Indication whether the tests were completed successfully. private  subroutine ply_split_element_3D_test (nModes, success) Testing the 3D splitting. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of modes in the (1D) polynomials to use in the check. logical, intent(out) :: success Indication whether the tests were completed successfully.","tags":"","url":"module/ply_split_element_module.html"},{"title":"ply_l2p_module – Seeder","text":"Uses tem_logging_module ply_lagrange_module env_module ply_space_integration_module tem_compileconf_module ply_nodeset_module ply_l2p_header_module tem_aux_module ply_modg_basis_module module~~ply_l2p_module~~UsesGraph module~ply_l2p_module ply_l2p_module env_module env_module module~ply_l2p_module->env_module module~ply_l2p_header_module ply_l2p_header_module module~ply_l2p_module->module~ply_l2p_header_module module~ply_lagrange_module ply_lagrange_module module~ply_l2p_module->module~ply_lagrange_module module~ply_nodeset_module ply_nodeset_module module~ply_l2p_module->module~ply_nodeset_module module~ply_space_integration_module ply_space_integration_module module~ply_l2p_module->module~ply_space_integration_module ply_modg_basis_module ply_modg_basis_module module~ply_l2p_module->ply_modg_basis_module tem_aux_module tem_aux_module module~ply_l2p_module->tem_aux_module tem_compileconf_module tem_compileconf_module module~ply_l2p_module->tem_compileconf_module tem_logging_module tem_logging_module module~ply_l2p_module->tem_logging_module module~ply_l2p_header_module->env_module module~ply_l2p_header_module->tem_aux_module module~ply_l2p_header_module->tem_logging_module aot_out_module aot_out_module module~ply_l2p_header_module->aot_out_module aotus_module aotus_module module~ply_l2p_header_module->aotus_module module~ply_nodes_header_module ply_nodes_header_module module~ply_l2p_header_module->module~ply_nodes_header_module tem_float_module tem_float_module module~ply_l2p_header_module->tem_float_module tem_tools_module tem_tools_module module~ply_l2p_header_module->tem_tools_module module~ply_lagrange_module->env_module module~ply_lagrange_module->module~ply_nodeset_module module~ply_nodeset_module->env_module tem_param_module tem_param_module module~ply_nodeset_module->tem_param_module module~ply_space_integration_module->env_module module~ply_space_integration_module->tem_param_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assignment(=) private  subroutine Copy_ply_l2p (left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_type ), intent(out) :: left fpt to copy to type( ply_l2p_type ), intent(in) :: right fpt to copy from Derived Types type, public :: ply_l2p_type Storage of the transformation matrices for the L2 projection method to\nconvert between modal and nodal values. Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: leg2node (:,:) real(kind=rk), public, allocatable :: node2leg (:,:) Subroutines public  subroutine ply_init_l2p (l2p, header, degree) Initialize the transformations via L2 projections. Arguments Type Intent Optional Attributes Name type( ply_l2p_type ), intent(out) :: l2p type( ply_l2p_header_type ), intent(in) :: header integer, intent(in) :: degree public  subroutine ply_l2p_trafo_1D (trafo, projected, original) Transformation between modal and nodal values in 1D via L2 projection. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: trafo (:,:) L2 Projection matrix, this determines the direction of the trafo at hand Read more… real(kind=rk), intent(inout) :: projected (:) Projected coefficients. real(kind=rk), intent(inout) :: original (:) Original coefficients to project. public  subroutine ply_l2p_trafo_2D (trafo, projected, original) Transformation between modal and nodal values in 2D via L2 projection. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: trafo (:,:) L2 Projection matrix, this determines the direction of the trafo at hand Read more… real(kind=rk), intent(inout) :: projected (:) Projected coefficients. real(kind=rk), intent(inout) :: original (:) Original coefficients to project. public  subroutine ply_l2p_trafo_3D (trafo, projected, original) Transformation between modal and nodal values in 3D via L2 projection. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: trafo (:,:) L2 Projection matrix, this determines the direction of the trafo at hand Read more… real(kind=rk), intent(inout) :: projected (:) Projected coefficients. real(kind=rk), intent(inout) :: original (:) Original coefficients to project. private  subroutine Copy_ply_l2p (left, right) Arguments Type Intent Optional Attributes Name type( ply_l2p_type ), intent(out) :: left fpt to copy to type( ply_l2p_type ), intent(in) :: right fpt to copy from private  subroutine ply_l2_projection (nDofs, nIndeps, projected, original, matrix) Actual implementation of the matrix operation to change between nodal\nand modal representations. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDofs Number of degree of freedoms integer, intent(in) :: nIndeps Number of values that can be computed independently. real(kind=rk), intent(out) :: projected (nIndeps,nDofs) Projected data. Read more… real(kind=rk), intent(in) :: original (nDofs,nIndeps) Original data. Read more… real(kind=rk), intent(in) :: matrix (nDofs,nDofs) Matrix to apply in this operation. Read more…","tags":"","url":"module/ply_l2p_module.html"},{"title":"ply_fxt_header_module – Seeder","text":"The FXT method offers a transformation from Legendre modes to nodes by a\n fast multipole approach implemented in the FXTPACK library by\n Reiji Suda:\n R. Suda, \"Fast Spherical Harmonic Transform Algorithm based on\n Generalized Fast Multiple Method\", RIMS Kokyuroku vol 1606,\n pp. 18-29, Jun. 2008, RIMS, Kyoto University. Besides the oversampling factor that can be used to increase the number\n points in the nodal representation to achieve an de-aliasing, there is only\n one other option to this method:\n The prec parameter configures the precision up to which the FXTPACK\n should compute the transformation.\n It defaults to the square root of the epsilon for the real kind. With\n double precision this would something around 1.4e-8. This transformation utilizes the Gauss Legendre integration points in the\n nodal representation. Thus, the configuration for a FXT projection takes the following form: projection = { kind = 'fxt' , prec = 1.e-10 } Uses aot_out_module tem_float_module tem_logging_module env_module aotus_module tem_aux_module ply_nodes_header_module module~~ply_fxt_header_module~~UsesGraph module~ply_fxt_header_module ply_fxt_header_module aot_out_module aot_out_module module~ply_fxt_header_module->aot_out_module aotus_module aotus_module module~ply_fxt_header_module->aotus_module env_module env_module module~ply_fxt_header_module->env_module module~ply_nodes_header_module ply_nodes_header_module module~ply_fxt_header_module->module~ply_nodes_header_module tem_aux_module tem_aux_module module~ply_fxt_header_module->tem_aux_module tem_float_module tem_float_module module~ply_fxt_header_module->tem_float_module tem_logging_module tem_logging_module module~ply_fxt_header_module->tem_logging_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_fxt_header_module~~UsedByGraph module~ply_fxt_header_module ply_fxt_header_module module~ply_fxt_module ply_fxt_module module~ply_fxt_module->module~ply_fxt_header_module module~ply_prj_header_module ply_prj_header_module module~ply_prj_header_module->module~ply_fxt_header_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~ply_prj_header_module module~sdr_config_module sdr_config_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_subresolution_module sdr_subresolution_module module~sdr_subresolution_module->module~ply_prj_header_module module~sdr_config_module->module~sdr_subresolution_module program~seeder seeder program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_config_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assignment(=) private pure subroutine Copy_fxt_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(out) :: left fpt to copy to type( ply_fxt_header_type ), intent(in) :: right fpt to copy from public        interface operator(==) private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Two fxt header are considered to be equal, if their node_header,\nand the factor are equal. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? public        interface operator(/=) private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Two fxt header are considered to be unequal, if their node_header,\nor the factor are not equal. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? public        interface operator(<) private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Sorting of fxt header is given by node_header and by the factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(<=) private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Sorting of fxt header is given by node_header, fxt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(>) private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Sorting of fxt header is given by node_header, fxt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? public        interface operator(>=) private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Sorting of fxt header is given by node_header, fxt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Derived Types type, public :: ply_fxt_header_type Fxt projection header type, consisting of the node header which give\ninformation about the type and number of points for the projection Components Type Visibility Attributes Name Initial type( ply_nodes_header_type ), public :: nodes_header real(kind=rk), public :: factor = 1.0 real(kind=rk), public :: prec = epsilon(1.0) Functions private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: left projection to compare type( ply_fxt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Subroutines public  subroutine ply_fxt_header_load (me, conf, thandle) Load settings to describe a projection method from a Lua table. Read more… Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in) :: thandle public  subroutine ply_fxt_header_out (me, conf) Write FXT settings into a Lua table. Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: me type( aot_out_type ) :: conf public  subroutine ply_fxt_header_display (me) Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(in) :: me private pure subroutine Copy_fxt_header (left, right) Arguments Type Intent Optional Attributes Name type( ply_fxt_header_type ), intent(out) :: left fpt to copy to type( ply_fxt_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"module/ply_fxt_header_module.html"},{"title":"sdr_aux_module – Seeder","text":"Some auxilary functionalities. Uses tem_solveHead_module tem_logging_module tem_aux_module module~~sdr_aux_module~~UsesGraph module~sdr_aux_module sdr_aux_module tem_aux_module tem_aux_module module~sdr_aux_module->tem_aux_module tem_logging_module tem_logging_module module~sdr_aux_module->tem_logging_module tem_solveHead_module tem_solveHead_module module~sdr_aux_module->tem_solveHead_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_aux_module~~UsedByGraph module~sdr_aux_module sdr_aux_module program~seeder seeder program~seeder->module~sdr_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine sdr_init_global (solveHead) Prominently let the user now, what he actually is running right now. Read more… Arguments Type Intent Optional Attributes Name type( tem_solveHead_type ), intent(in) :: solveHead contains solver header information","tags":"","url":"module/sdr_aux_module.html"},{"title":"ply_fpt_header_module – Seeder","text":"Parameters for the FPT method The Fast Polynomial Transformation implements the approach described in\n B. K. Alpert und V. Rokhlin, „A Fast Algorithm for the Evaluation of\n Legendre Expansions“, SIAM Journal on Scientific and Statistical Computing,\n Vol. 12, Nr. 1, pp. 158–179, Jan. 1991, doi: 10.1137/0912009. It utilizes the Fast Fourier Transformation by first converting the\n Legendre modes into Chebyshev modes.\n The conversion between Legendre and Chebyshev modes is done approximately\n by approximating increasingly larger blocks away from the diagonal.\n This method is only available if the executable is linked against the FFTW . As with the other projection methods, a factor can be specified to\n use more points in the nodal representation and achieve some de-aliasing.\n Because the FFT works especially well for powers of two, it is possible to\n choose the oversampling such, that the oversampled modes have count of the\n next larger power of 2.\n To achieve this, the option adapt_factor_pow2 has to be set to true ,\n by default it is assumed to be false .\n Further it is possible to make use of lobattoPoints with this\n transformation method.\n If lobattoPoints = true , the points on the interval boundary will be\n included in the set of points in the nodal representation. This is for\n example necessary when positivity is to be preserved for the numerical\n fluxes.\n By default this setting is false . All other options tune the transformation algorithm: blocksize defines the minimal block size that is to be approximated in\n   the transformation matrix. It defaults to 64, which is the recommendation\n   for double precision computations, but requires high polynomial degrees to\n   attain any approximation at all. The (oversampled) number of nodes needs to\n   be larger than two times the blocksize, to have at least one approximated\n   block. As long as the number modes is below this threshold the method is\n   not \"fast\" and a computational complexity of number of modes squared is\n   required for the operation. Smaller values push the approximation closer\n   to the diagonal. This can speed up the computation for smaller number of\n   modes but also detoriates the accuracy of the transformation. approx_terms number of terms to use in the approximation of blocks,\n   defaults to 18, which is recommended for double precision computations.\n   In each block only approx_terms will be used to represent rows in the\n   block. Smaller values make the transformation faster, but less accurate\n   (if blocks are actually approximated). implementation selects the implementation for the transformation. There\n   are two variants of the implementation: 'scalar' this is the default\n   and treats the transformations with an outer loop over the independent\n   operations. The 'vector' implementation on the other hand gathers\n   multiple independent operations together and performs them all at once\n   with an inner loop over blocks length striplen . While the 'vector' variant may exploit vector instructions, it utilizes a larger amount of\n   temporary memory. The default setting for this option is 'scalar' . striplen determines the length for vectorized loops to be used in the\n   matrix operation. It defaults to the vlen setting defined in tem_compileconf_module during compilation.\n   Depending on the computing architecture, different values may provide\n   more efficient computations. subblockingWidth defines striding in the multiplication of the diagonal\n   elements in the transformation matrix. The default for this setting is 8. The configuration table for the FPT table may, for example, look as follows: projection = { kind = 'fpt' , factor = 1.5 , adapt_factor_pow2 = true , lobattoPoints = false , blocksize = 16 , approx_terms = 12 , implementation = 'scalar' , striplen = 256 , subblockingWidth = 8 } Uses tem_tools_module aot_out_module tem_float_module tem_logging_module env_module tem_compileconf_module aotus_module tem_aux_module ply_nodes_header_module module~~ply_fpt_header_module~~UsesGraph module~ply_fpt_header_module ply_fpt_header_module aot_out_module aot_out_module module~ply_fpt_header_module->aot_out_module aotus_module aotus_module module~ply_fpt_header_module->aotus_module env_module env_module module~ply_fpt_header_module->env_module module~ply_nodes_header_module ply_nodes_header_module module~ply_fpt_header_module->module~ply_nodes_header_module tem_aux_module tem_aux_module module~ply_fpt_header_module->tem_aux_module tem_compileconf_module tem_compileconf_module module~ply_fpt_header_module->tem_compileconf_module tem_float_module tem_float_module module~ply_fpt_header_module->tem_float_module tem_logging_module tem_logging_module module~ply_fpt_header_module->tem_logging_module tem_tools_module tem_tools_module module~ply_fpt_header_module->tem_tools_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ply_fpt_header_module~~UsedByGraph module~ply_fpt_header_module ply_fpt_header_module module~ply_legfpt_module ply_legFpt_module module~ply_legfpt_module->module~ply_fpt_header_module module~ply_prj_header_module ply_prj_header_module module~ply_prj_header_module->module~ply_fpt_header_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~ply_prj_header_module module~sdr_config_module sdr_config_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_subresolution_module sdr_subresolution_module module~sdr_subresolution_module->module~ply_prj_header_module module~sdr_config_module->module~sdr_subresolution_module program~seeder seeder program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_config_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ply_fpt_default_blocksize = 64 The recommended minimal blocksize for double precision. integer, public, parameter :: ply_fpt_default_subblockingWidth = 8 The default width of the subblocking of the diagonal calculation of the\nfpt projection integer, public, parameter :: ply_fpt_default_approx_terms = 18 Default number of terms to use in FPT blocks. 18 is recommended for\ndouble precision. integer, public, parameter :: ply_fpt_scalar = 1 Value to signify the use of the scalar FPT implementation. integer, public, parameter :: ply_fpt_vector = 2 Value to signify the use of the vector FPT implementation. Interfaces public        interface assignment(=) private pure subroutine Copy_fpt_header (left, right) Copy the FPT header information. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: left fpt to copy to type( ply_fpt_header_type ), intent(in) :: right fpt to copy from public        interface operator(==) private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Two fpt header are considered to be equal, if their  node_header,\nfpt_blocksize or the factor are equal. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? public        interface operator(/=) private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Two fpt header are considered to be unequal, if their  node_header,\nfpt_blocksize or the factor are not equal. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? public        interface operator(<) private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(<=) private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? public        interface operator(>) private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? public        interface operator(>=) private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Sorting of fpt header is given by node_header, fpt_blocksize and\nlast by factor. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Derived Types type, public :: ply_fpt_header_type Type for the fpt header, stores all information needed to initialize the\nfpt method later on Components Type Visibility Attributes Name Initial type( ply_nodes_header_type ), public :: nodes_header real(kind=rk), public :: factor = 1.0_rk In case of nonlinear equations, aliasing occurs if the projections\nof the nonlinear terms on the testfunctions are not calculated\naccurately enough. To avoid these errors it is possible to\nextend the transformation vectors of the FPT with zeros. This\nfactor determines by how many zeros the modal vector is extended\nbefore transformation. This factor has to be chosen properly with\nrespect of the type of nonlinearity of your equation. integer, public :: blocksize = ply_fpt_default_blocksize The blockisze of the fast bases exchange algorithm from\nLegendre to Chebyshev polynomials.\nA negative number indicates to use the default blocksize of the\nalgorithm. integer, public :: approx_terms = ply_fpt_default_approx_terms The number of approximation terms to use for blocks apart from the\ndiagonal. Read more… integer, public :: implementation The implementation variant to use for the transformation computation. Read more… integer, public :: striplen = vlen The striplen, that should be used for vectorized simultaneous\ncomputations of the matrix operation. Read more… integer, public :: subblockingWidth = ply_fpt_default_subblockingWidth The width of the subblocks used during the unrolled base exchange to\nensure a better cache usage. Read more… logical, public :: adapt_factor_pow2 = .false. Should the oversampling factor be adapted to ensure a power of 2\nin the oversampled polynomial? Read more… Functions private pure function isEqual (left, right) result(equality) This function provides the test for equality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is equal?? private pure function isUnequal (left, right) result(unequality) This function provides the test for unequality of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is unequal?? private pure function isSmaller (left, right) result(small) This function provides a < comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isSmallerOrEqual (left, right) result(small) This function provides a <= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is smaller?? private pure function isGreater (left, right) result(great) This function provides a > comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? private pure function isGreaterOrEqual (left, right) result(great) This function provides a >= comparison of two projections. Read more… Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: left projection to compare type( ply_fpt_header_type ), intent(in) :: right projection to compare against Return Value logical is greater?? Subroutines public  subroutine ply_fpt_header_load (me, conf, thandle) Read the FPT configuration options from the provided Lua script in conf . Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: me type( flu_State ), intent(inout) :: conf integer, intent(in) :: thandle public  subroutine ply_fpt_header_define (me, blocksize, factor, approx_terms, implementation, striplen, subBlockingWidth, adapt_factor_pow2, lobattoPoints) Define settings for the Fast Polynomial Transformation. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: me FPT header to hold the defined settings. integer, intent(in), optional :: blocksize Blocksize to use in approximation algorithm. Defaults to ply_fpt_default_blocksize . real(kind=rk), intent(in), optional :: factor Oversampling factor to use. Read more… integer, intent(in), optional :: approx_terms Number of approximation terms to use for the representation of the\nblocks in the Legendre to Chebyshev transformation algorithm.\nDefaults to ply_fpt_default_approx_terms . integer, intent(in), optional :: implementation Implementation to use in the computation. Read more… integer, intent(in), optional :: striplen Length of strips to use in the transformation implementation.\nDefaults to vlen . integer, intent(in), optional :: subBlockingWidth Width for subblocks in unrolling the approximate Legendre to\nChebyshev transformation. Defaults to ply_fpt_default_subblockingWidth . logical, intent(in), optional :: adapt_factor_pow2 Adapt the oversampling factor such, that oversampled space has a\nnumber of degrees of freedoms in one direction that is a power of 2.\nDefault is .false.. logical, intent(in), optional :: lobattoPoints Wether to use Chebyshev-Lobatto points (include boundary points) or\nnot. Defaults to .false.. public  subroutine ply_fpt_header_out (me, conf) Write FPT settings into a Lua table. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: me type( aot_out_type ), intent(inout) :: conf public  subroutine ply_fpt_header_display (me) Print the FPT settings to the log output. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(in) :: me private pure subroutine Copy_fpt_header (left, right) Copy the FPT header information. Arguments Type Intent Optional Attributes Name type( ply_fpt_header_type ), intent(out) :: left fpt to copy to type( ply_fpt_header_type ), intent(in) :: right fpt to copy from","tags":"","url":"module/ply_fpt_header_module.html"},{"title":"ply_legFpt_module – Seeder","text":"Module providing datatypes and routines for a fast\ntransformation of Legendre expansion to point values.\n\\author{Jens Zudrop} Uses env_module tem_compileconf_module fftw_wrap ply_fpt_header_module iso_c_binding ply_polyBaseExc_module module~~ply_legfpt_module~~UsesGraph module~ply_legfpt_module ply_legFpt_module env_module env_module module~ply_legfpt_module->env_module fftw_wrap fftw_wrap module~ply_legfpt_module->fftw_wrap iso_c_binding iso_c_binding module~ply_legfpt_module->iso_c_binding module~ply_fpt_header_module ply_fpt_header_module module~ply_legfpt_module->module~ply_fpt_header_module ply_polyBaseExc_module ply_polyBaseExc_module module~ply_legfpt_module->ply_polyBaseExc_module tem_compileconf_module tem_compileconf_module module~ply_legfpt_module->tem_compileconf_module module~ply_fpt_header_module->env_module module~ply_fpt_header_module->tem_compileconf_module aot_out_module aot_out_module module~ply_fpt_header_module->aot_out_module aotus_module aotus_module module~ply_fpt_header_module->aotus_module module~ply_nodes_header_module ply_nodes_header_module module~ply_fpt_header_module->module~ply_nodes_header_module tem_aux_module tem_aux_module module~ply_fpt_header_module->tem_aux_module tem_float_module tem_float_module module~ply_fpt_header_module->tem_float_module tem_logging_module tem_logging_module module~ply_fpt_header_module->tem_logging_module tem_tools_module tem_tools_module module~ply_fpt_header_module->tem_tools_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assignment(=) private  subroutine Copy_fpt (left, right) Arguments Type Intent Optional Attributes Name type( ply_legFpt_type ), intent(out) :: left fpt to copy to type( ply_legFpt_type ), intent(in) :: right fpt to copy from interface private  subroutine ply_fptm2n(fpt, legCoeffs, pntVal, nIndeps) Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps interface private  subroutine ply_fptn2m(fpt, pntVal, legCoeffs, nIndeps) Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps Derived Types type, public :: ply_legFpt_type Datatype for parameters of the FPT used for 1d, 2d and 3d. Read more… Components Type Visibility Attributes Name Initial type(ply_trafo_params_type), public :: legToChebParams FPT params for the fast base exchange from Legendre to\nChebyshev expansion. type(ply_trafo_params_type), public :: chebToLegParams FPT params for the fast base exchange from Chebyshev to\nLegendre expansion. type(C_PTR), public :: planChebToPnt FFTW plan for DCT from Chebyshev coefficients to point values. type(C_PTR), public :: planPntToCheb FFTW plan for DCT from point values to Chebyshev coefficients. logical, public :: use_lobatto_points Flag whether to use Lobatto points (include boundary points) procedure( ply_fptm2n ), public, pointer :: legtopnt => NULL() procedure( ply_fptn2m ), public, pointer :: pnttoleg => NULL() Subroutines public  subroutine ply_init_legFpt (maxPolyDegree, nIndeps, fpt, header, fft_flags) Subroutine to initialize the fast polynomial transformation\n for Legendre expansion. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxPolyDegree Maximal polynomial degree for the transformation. integer, intent(in) :: nIndeps Number of independent values that can be computed simultaneously. type( ply_legFpt_type ), intent(inout) :: fpt The Fast Polynomial Transformation setting to initialize. type( ply_fpt_header_type ), intent(in) :: header Configuration settings for the projection. integer, intent(in), optional :: fft_flags Planning flags for the FFT. Read more… private  subroutine Copy_fpt (left, right) Arguments Type Intent Optional Attributes Name type( ply_legFpt_type ), intent(out) :: left fpt to copy to type( ply_legFpt_type ), intent(in) :: right fpt to copy from private  subroutine ply_legToPnt_single (fpt, legCoeffs, pntVal, nIndeps) Subroutine to transform Legendre expansion to point values\nat Chebyshev nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps private  subroutine ply_legToPnt_vec (fpt, legCoeffs, pntVal, nIndeps) Vectorizing subroutine to transform Legendre expansion to point values\nat Chebyshev nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps private  subroutine ply_legToPnt_lobatto_single (fpt, legCoeffs, pntVal, nIndeps) Subroutine to transform Legendre expansion to point values\nat Chebyshev-Lobatto nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps private  subroutine ply_legToPnt_lobatto_vec (fpt, legCoeffs, pntVal, nIndeps) Vectorizing subroutine to transform Legendre expansion to point values\nat Chebyshev-Lobatto nodes. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: legCoeffs (:) real(kind=rk), intent(inout) :: pntVal (:) integer, intent(in) :: nIndeps private  subroutine ply_pntToLeg_single (fpt, pntVal, legCoeffs, nIndeps) Subroutine to transform point values at Chebyshev nodes to a Legendre\nexpansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps private  subroutine ply_pntToLeg_vec (fpt, pntVal, legCoeffs, nIndeps) Vectorizing subroutine to transform point values at Chebyshev nodes to a\nLegendre expansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps private  subroutine ply_pntToLeg_lobatto_single (fpt, pntVal, legCoeffs, nIndeps) Subroutine to transform point values at Chebyshev-Lobatto nodes to a\nLegendre expansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps private  subroutine ply_pntToLeg_lobatto_vec (fpt, pntVal, legCoeffs, nIndeps) Vectorizing subroutine to transform point values at Chebyshev-Lobatto\nnodes to a Legendre expansion. Arguments Type Intent Optional Attributes Name class( ply_legFpt_type ), intent(inout) :: fpt real(kind=rk), intent(inout) :: pntVal (:) real(kind=rk), intent(inout) :: legCoeffs (:) integer, intent(in) :: nIndeps","tags":"","url":"module/ply_legfpt_module.html"},{"title":"sdr_hvs_props_module – Seeder","text":"This module describes the properties in a treelmesh to allow their output. Uses tem_bc_prop_module tem_color_prop_module tem_logging_module env_module tem_time_module ply_subresolution_module tem_comm_env_module ply_dof_module treelmesh_module iso_c_binding tem_varSys_module module~~sdr_hvs_props_module~~UsesGraph module~sdr_hvs_props_module sdr_hvs_props_module env_module env_module module~sdr_hvs_props_module->env_module iso_c_binding iso_c_binding module~sdr_hvs_props_module->iso_c_binding module~ply_subresolution_module ply_subresolution_module module~sdr_hvs_props_module->module~ply_subresolution_module ply_dof_module ply_dof_module module~sdr_hvs_props_module->ply_dof_module tem_bc_prop_module tem_bc_prop_module module~sdr_hvs_props_module->tem_bc_prop_module tem_color_prop_module tem_color_prop_module module~sdr_hvs_props_module->tem_color_prop_module tem_comm_env_module tem_comm_env_module module~sdr_hvs_props_module->tem_comm_env_module tem_logging_module tem_logging_module module~sdr_hvs_props_module->tem_logging_module tem_time_module tem_time_module module~sdr_hvs_props_module->tem_time_module tem_varSys_module tem_varSys_module module~sdr_hvs_props_module->tem_varSys_module treelmesh_module treelmesh_module module~sdr_hvs_props_module->treelmesh_module module~ply_subresolution_module->env_module module~ply_subresolution_module->iso_c_binding module~ply_subresolution_module->ply_dof_module module~ply_subresolution_module->tem_color_prop_module module~ply_subresolution_module->tem_comm_env_module module~ply_subresolution_module->tem_logging_module module~ply_subresolution_module->tem_time_module module~ply_subresolution_module->tem_varSys_module module~ply_subresolution_module->treelmesh_module aotus_module aotus_module module~ply_subresolution_module->aotus_module ply_transfer_module ply_transfer_module module~ply_subresolution_module->ply_transfer_module tem_aux_module tem_aux_module module~ply_subresolution_module->tem_aux_module tem_subres_prop_module tem_subres_prop_module module~ply_subresolution_module->tem_subres_prop_module tem_tools_module tem_tools_module module~ply_subresolution_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_hvs_props_module~~UsedByGraph module~sdr_hvs_props_module sdr_hvs_props_module module~sdr_hvs_config_module sdr_hvs_config_module module~sdr_hvs_config_module->module~sdr_hvs_props_module program~sdr_harvesting sdr_harvesting program~sdr_harvesting->module~sdr_hvs_props_module program~sdr_harvesting->module~sdr_hvs_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_hvs_props_type Datatype to collect the various properties of the mesh. Components Type Visibility Attributes Name Initial type( tem_BC_prop_type ), public, pointer :: bc => NULL() Property describing the boundary conditions in the mesh. type( tem_color_prop_type ), public, pointer :: color => NULL() Property describing the coloring of the mesh. type( ply_subresolution_type ), public, pointer :: subres => NULL() Additional color distribution information via subresolution. type( sdr_hvs_colvar_ptr_type ), public, allocatable :: colorVar (:) Description of color variables. integer, public, allocatable :: colorvarpos (:) Position in the variables for each color. Read more… type, private :: sdr_hvs_colvar_ptr_type Auxilary data type to allow an array of pointers to colvar objects. Components Type Visibility Attributes Name Initial type( ply_subres_colvar_type ), public, pointer :: p => NULL() procedure( tem_varSys_proc_element ), public, nopass, pointer :: get_element Subroutines public  subroutine sdr_hvs_props_load (me, varsys, mesh, proc) Load the properties from the mesh. Arguments Type Intent Optional Attributes Name type( sdr_hvs_props_type ), intent(out) :: me Properties to load. type( tem_varSys_type ), intent(inout) :: varsys A variable system, to which the colors should be appended. type( treelmesh_type ), intent(in) :: mesh Mesh to load the properties for. type( tem_comm_env_type ), intent(in) :: proc Process description for MPI-IO public  subroutine sdr_hvs_props_import_dofs (me, mesh, proc, maxdegree, ndims) Import subresolved color data. Arguments Type Intent Optional Attributes Name type( sdr_hvs_props_type ), intent(inout) :: me Properties to get the subresolution dofs for. type( treelmesh_type ), intent(in) :: mesh Mesh definition, these properties belong to. type( tem_comm_env_type ), intent(in) :: proc Communicating environment. integer, intent(in) :: maxdegree Maximal polynomial degree to import. Read more… integer, intent(in) :: ndims Dimensions of the polynomials after importing. private  subroutine sdr_hvs_props_clean (me) Clean up the properties data type. Read more… Arguments Type Intent Optional Attributes Name type( sdr_hvs_props_type ), intent(out) :: me","tags":"","url":"module/sdr_hvs_props_module.html"},{"title":"sdr_subresolution_module – Seeder","text":"This module describes settings that are required for the resolution of\nboundaries on a subelement level. These boundaries are represented by polynomials, and a nodal sampling in\nelements intersected by the boundary needs to be done accordingly. For subresolution to work, there needs to be a subresolution table\ndefined, indicating at least the polynomial degree to use for polynomial\nrepresentations.\nOnly boundaries with a color (not the 'none' color), can be subresolved.\nFor each color a separate file will be generated to contain the\npolynomial information on all the subresolved elements of this color.\nNote, that polynomial settings are global, all boundaries will be resolved\nwith the same polynomial definition. Nodal values are obtained, by refining elements further down and probing\nintegration points for their in or out status. This detaches the\nactual polynomial somewhat from the mesh resolution, and the number of\nlevels to resolve beyond the target element can be stated independently\nof the polynomial degree.\nHowever, the subresolution levels should be set sufficiently high to\nprovide a good resolution for the integration points. Uses tem_tools_module tem_dyn_array_module flu_binding tem_logging_module aot_table_module env_module ply_prj_header_module ply_dof_module aotus_module sdr_subres_fills_module tem_aux_module ply_dynarray_project_module module~~sdr_subresolution_module~~UsesGraph module~sdr_subresolution_module sdr_subresolution_module aot_table_module aot_table_module module~sdr_subresolution_module->aot_table_module aotus_module aotus_module module~sdr_subresolution_module->aotus_module env_module env_module module~sdr_subresolution_module->env_module flu_binding flu_binding module~sdr_subresolution_module->flu_binding module~ply_prj_header_module ply_prj_header_module module~sdr_subresolution_module->module~ply_prj_header_module module~sdr_subres_fills_module sdr_subres_fills_module module~sdr_subresolution_module->module~sdr_subres_fills_module ply_dof_module ply_dof_module module~sdr_subresolution_module->ply_dof_module ply_dynarray_project_module ply_dynarray_project_module module~sdr_subresolution_module->ply_dynarray_project_module tem_aux_module tem_aux_module module~sdr_subresolution_module->tem_aux_module tem_dyn_array_module tem_dyn_array_module module~sdr_subresolution_module->tem_dyn_array_module tem_logging_module tem_logging_module module~sdr_subresolution_module->tem_logging_module tem_tools_module tem_tools_module module~sdr_subresolution_module->tem_tools_module module~ply_prj_header_module->aotus_module module~ply_prj_header_module->env_module module~ply_prj_header_module->tem_aux_module module~ply_prj_header_module->tem_logging_module module~ply_prj_header_module->tem_tools_module aot_out_module aot_out_module module~ply_prj_header_module->aot_out_module fftw_wrap fftw_wrap module~ply_prj_header_module->fftw_wrap module~ply_fpt_header_module ply_fpt_header_module module~ply_prj_header_module->module~ply_fpt_header_module module~ply_fxt_header_module ply_fxt_header_module module~ply_prj_header_module->module~ply_fxt_header_module module~ply_l2p_header_module ply_l2p_header_module module~ply_prj_header_module->module~ply_l2p_header_module module~sdr_subres_fills_module->aot_table_module module~sdr_subres_fills_module->aotus_module module~sdr_subres_fills_module->env_module module~sdr_subres_fills_module->flu_binding module~sdr_subres_fills_module->tem_aux_module module~sdr_subres_fills_module->tem_dyn_array_module module~sdr_subres_fills_module->tem_logging_module module~sdr_subres_fills_module->tem_tools_module tem_grow_array_module tem_grow_array_module module~sdr_subres_fills_module->tem_grow_array_module module~ply_fpt_header_module->aotus_module module~ply_fpt_header_module->env_module module~ply_fpt_header_module->tem_aux_module module~ply_fpt_header_module->tem_logging_module module~ply_fpt_header_module->tem_tools_module module~ply_fpt_header_module->aot_out_module module~ply_nodes_header_module ply_nodes_header_module module~ply_fpt_header_module->module~ply_nodes_header_module tem_compileconf_module tem_compileconf_module module~ply_fpt_header_module->tem_compileconf_module tem_float_module tem_float_module module~ply_fpt_header_module->tem_float_module module~ply_fxt_header_module->aotus_module module~ply_fxt_header_module->env_module module~ply_fxt_header_module->tem_aux_module module~ply_fxt_header_module->tem_logging_module module~ply_fxt_header_module->aot_out_module module~ply_fxt_header_module->module~ply_nodes_header_module module~ply_fxt_header_module->tem_float_module module~ply_l2p_header_module->aotus_module module~ply_l2p_header_module->env_module module~ply_l2p_header_module->tem_aux_module module~ply_l2p_header_module->tem_logging_module module~ply_l2p_header_module->tem_tools_module module~ply_l2p_header_module->aot_out_module module~ply_l2p_header_module->module~ply_nodes_header_module module~ply_l2p_header_module->tem_float_module module~ply_nodes_header_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~sdr_subresolution_module~~UsedByGraph module~sdr_subresolution_module sdr_subresolution_module module~sdr_config_module sdr_config_module module~sdr_config_module->module~sdr_subresolution_module module~sdr_flooding_module sdr_flooding_module module~sdr_flooding_module->module~sdr_config_module module~sdr_prototree_module sdr_protoTree_module module~sdr_flooding_module->module~sdr_prototree_module module~sdr_boundary_module sdr_boundary_module module~sdr_flooding_module->module~sdr_boundary_module module~sdr_proto2treelm_module sdr_proto2treelm_module module~sdr_proto2treelm_module->module~sdr_config_module module~sdr_proto2treelm_module->module~sdr_prototree_module module~sdr_proto2treelm_module->module~sdr_boundary_module module~sdr_prototree_module->module~sdr_config_module module~sdr_refinept_module sdr_refinePT_module module~sdr_refinept_module->module~sdr_config_module module~sdr_refinept_module->module~sdr_prototree_module program~seeder seeder program~seeder->module~sdr_config_module program~seeder->module~sdr_flooding_module program~seeder->module~sdr_proto2treelm_module program~seeder->module~sdr_prototree_module program~seeder->module~sdr_refinept_module module~sdr_boundary_module->module~sdr_prototree_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: sdr_subresolution_type Settings for the resolution below mesh elements. Components Type Visibility Attributes Name Initial integer, public :: polydegree Degree for the polynomials to use in the subelement resolution. character(len=1), public :: polyspace Identification of the polynomial space to use. type(ply_prj_init_type), public :: projection Definition of conversions between modal and nodal values. type( ply_prj_header_type ), public :: project_header Header definition of the projection header. Read more… integer, public :: nLevels Number of levels to use for the resolution of boundaries within elements. Read more… type( dyn_labelarray_type ), public :: default_colors Dynamic array to store the color names, for which the default boundary\nresolution should reach subelements. Read more… type( sdr_subres_fills_type ), public :: color_values Definition of the values to use for color filling and color voids. integer, public, allocatable :: value_pos (:) Position of value definitions for each color in the mesh. Subroutines public  subroutine sdr_subresolution_load (subres, conf, parent) Loading the settings for the subresolution in the mesh. Arguments Type Intent Optional Attributes Name type( sdr_subresolution_type ), intent(out) :: subres The subresolution data structure to fill. type( flu_State ) :: conf Handle to the Lua configuration script. integer, intent(in), optional :: parent Handle to a possible parent table. public  subroutine subres_load_color_defaults (label, conf, parent) Internal subroutine to load the list of colors, which by default should\napply subelement resolution to its boundaries. Read more… Arguments Type Intent Optional Attributes Name type( dyn_labelarray_type ), intent(out) :: label Labels of the colors, for which a default setting is given. type( flu_State ) :: conf Handle for the Lua script. integer, intent(in) :: parent Parent table, within which to open the color_default table. public  subroutine sdr_subresolution_encolor (me, colors) Find the value definitions for all unique colors. Arguments Type Intent Optional Attributes Name type( sdr_subresolution_type ), intent(inout) :: me type( dyn_labelarray_type ), intent(in) :: colors","tags":"","url":"module/sdr_subresolution_module.html"},{"title":"seeder – Seeder","text":"Uses sdr_geometry_module sdr_protoTree_module sdr_aux_module tem_timer_module tem_debug_module sdr_config_module sdr_timer_module sdr_proto2treelm_module sdr_refinePT_module tem_general_module sdr_flooding_module program~~seeder~~UsesGraph program~seeder seeder module~sdr_aux_module sdr_aux_module program~seeder->module~sdr_aux_module module~sdr_config_module sdr_config_module program~seeder->module~sdr_config_module module~sdr_flooding_module sdr_flooding_module program~seeder->module~sdr_flooding_module module~sdr_geometry_module sdr_geometry_module program~seeder->module~sdr_geometry_module module~sdr_proto2treelm_module sdr_proto2treelm_module program~seeder->module~sdr_proto2treelm_module module~sdr_prototree_module sdr_protoTree_module program~seeder->module~sdr_prototree_module module~sdr_refinept_module sdr_refinePT_module program~seeder->module~sdr_refinept_module module~sdr_timer_module sdr_timer_module program~seeder->module~sdr_timer_module tem_debug_module tem_debug_module program~seeder->tem_debug_module tem_general_module tem_general_module program~seeder->tem_general_module tem_timer_module tem_timer_module program~seeder->tem_timer_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. S E E D E R\nMesh generator within the APES suite For a documentation, run ./waf gendoxy and find the documentation at\n./Documentation/html/index.html Calls program~~seeder~~CallsGraph program~seeder seeder proc~sdr_addtimers sdr_addTimers program~seeder->proc~sdr_addtimers proc~sdr_build_prototree sdr_build_protoTree program~seeder->proc~sdr_build_prototree proc~sdr_dump_treelm sdr_dump_treelm program~seeder->proc~sdr_dump_treelm proc~sdr_dumptimers sdr_dumptimers program~seeder->proc~sdr_dumptimers proc~sdr_flood_tree sdr_flood_tree program~seeder->proc~sdr_flood_tree proc~sdr_inherit_distancerefineobject sdr_inHerit_distanceRefineObject program~seeder->proc~sdr_inherit_distancerefineobject proc~sdr_init_global sdr_init_global program~seeder->proc~sdr_init_global proc~sdr_load_config sdr_load_config program~seeder->proc~sdr_load_config proc~sdr_proto2treelm sdr_proto2treelm program~seeder->proc~sdr_proto2treelm proc~sdr_refine_leaf sdr_refine_leaf program~seeder->proc~sdr_refine_leaf proc~sdr_smooth_leaf sdr_smooth_leaf program~seeder->proc~sdr_smooth_leaf proc~sdr_write_proto_as_restart sdr_write_proto_as_restart program~seeder->proc~sdr_write_proto_as_restart tem_finalize tem_finalize program~seeder->tem_finalize tem_start tem_start program~seeder->tem_start tem_stopTimer tem_stopTimer program~seeder->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( sdr_confHead_type ) :: header type( sdr_geometry_type ) :: geometry type( sdr_protoTree_type ) :: protoTree type( sdr_temData_type ) :: temData","tags":"","url":"program/seeder.html"},{"title":"sdr_harvesting – Seeder","text":"Uses iso_c_binding hvs_output_module tem_varMap_module sdr_hvs_config_module ply_sampled_tracking_module env_module ply_dof_module sdr_hvs_props_module tem_bc_prop_module tem_logging_module tem_time_module treelmesh_module tem_restart_module tem_general_module tem_varSys_module tem_color_prop_module tem_tracking_module sdr_protoData_module tem_stencil_module tem_meshInfo_module program~~sdr_harvesting~~UsesGraph program~sdr_harvesting sdr_harvesting env_module env_module program~sdr_harvesting->env_module hvs_output_module hvs_output_module program~sdr_harvesting->hvs_output_module iso_c_binding iso_c_binding program~sdr_harvesting->iso_c_binding module~ply_sampled_tracking_module ply_sampled_tracking_module program~sdr_harvesting->module~ply_sampled_tracking_module module~sdr_hvs_config_module sdr_hvs_config_module program~sdr_harvesting->module~sdr_hvs_config_module module~sdr_hvs_props_module sdr_hvs_props_module program~sdr_harvesting->module~sdr_hvs_props_module ply_dof_module ply_dof_module program~sdr_harvesting->ply_dof_module sdr_protoData_module sdr_protoData_module program~sdr_harvesting->sdr_protoData_module tem_bc_prop_module tem_bc_prop_module program~sdr_harvesting->tem_bc_prop_module tem_color_prop_module tem_color_prop_module program~sdr_harvesting->tem_color_prop_module tem_general_module tem_general_module program~sdr_harvesting->tem_general_module tem_logging_module tem_logging_module program~sdr_harvesting->tem_logging_module tem_meshInfo_module tem_meshInfo_module program~sdr_harvesting->tem_meshInfo_module tem_restart_module tem_restart_module program~sdr_harvesting->tem_restart_module tem_stencil_module tem_stencil_module program~sdr_harvesting->tem_stencil_module tem_time_module tem_time_module program~sdr_harvesting->tem_time_module tem_tracking_module tem_tracking_module program~sdr_harvesting->tem_tracking_module tem_varMap_module tem_varMap_module program~sdr_harvesting->tem_varMap_module tem_varSys_module tem_varSys_module program~sdr_harvesting->tem_varSys_module treelmesh_module treelmesh_module program~sdr_harvesting->treelmesh_module module~ply_sampled_tracking_module->env_module module~ply_sampled_tracking_module->hvs_output_module module~ply_sampled_tracking_module->tem_bc_prop_module module~ply_sampled_tracking_module->tem_logging_module module~ply_sampled_tracking_module->tem_stencil_module module~ply_sampled_tracking_module->tem_time_module module~ply_sampled_tracking_module->tem_tracking_module module~ply_sampled_tracking_module->tem_varMap_module module~ply_sampled_tracking_module->tem_varSys_module module~ply_sampled_tracking_module->treelmesh_module aotus_module aotus_module module~ply_sampled_tracking_module->aotus_module ply_sampling_module ply_sampling_module module~ply_sampled_tracking_module->ply_sampling_module tem_aux_module tem_aux_module module~ply_sampled_tracking_module->tem_aux_module tem_comm_env_module tem_comm_env_module module~ply_sampled_tracking_module->tem_comm_env_module tem_reduction_spatial_module tem_reduction_spatial_module module~ply_sampled_tracking_module->tem_reduction_spatial_module tem_simControl_module tem_simControl_module module~ply_sampled_tracking_module->tem_simControl_module tem_solveHead_module tem_solveHead_module module~ply_sampled_tracking_module->tem_solveHead_module module~sdr_hvs_config_module->env_module module~sdr_hvs_config_module->hvs_output_module module~sdr_hvs_config_module->module~ply_sampled_tracking_module module~sdr_hvs_config_module->module~sdr_hvs_props_module module~sdr_hvs_config_module->tem_bc_prop_module module~sdr_hvs_config_module->tem_color_prop_module module~sdr_hvs_config_module->tem_general_module module~sdr_hvs_config_module->tem_logging_module module~sdr_hvs_config_module->tem_restart_module module~sdr_hvs_config_module->tem_time_module module~sdr_hvs_config_module->tem_tracking_module module~sdr_hvs_config_module->tem_varSys_module module~sdr_hvs_config_module->treelmesh_module module~sdr_hvs_config_module->aotus_module flu_binding flu_binding module~sdr_hvs_config_module->flu_binding module~sdr_hvs_config_module->tem_aux_module tem_debug_module tem_debug_module module~sdr_hvs_config_module->tem_debug_module module~sdr_hvs_props_module->env_module module~sdr_hvs_props_module->iso_c_binding module~sdr_hvs_props_module->ply_dof_module module~sdr_hvs_props_module->tem_bc_prop_module module~sdr_hvs_props_module->tem_color_prop_module module~sdr_hvs_props_module->tem_logging_module module~sdr_hvs_props_module->tem_time_module module~sdr_hvs_props_module->tem_varSys_module module~sdr_hvs_props_module->treelmesh_module module~ply_subresolution_module ply_subresolution_module module~sdr_hvs_props_module->module~ply_subresolution_module module~sdr_hvs_props_module->tem_comm_env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Seeder Harvesting Tool\n Visualization of meshes, generated by seeder.\n (c) 2015 University of Siegen For a documentation, run ./waf gendoxy and find the documentation at\n ./Documentation/html/index.html Todo HK: no subsampling if we dump all data (no tracking)?\n          Probably should do subsampling also here? Calls program~~sdr_harvesting~~CallsGraph program~sdr_harvesting sdr_harvesting hvs_output_close hvs_output_close program~sdr_harvesting->hvs_output_close hvs_output_finalize hvs_output_finalize program~sdr_harvesting->hvs_output_finalize hvs_output_init hvs_output_init program~sdr_harvesting->hvs_output_init hvs_output_open hvs_output_open program~sdr_harvesting->hvs_output_open hvs_output_write hvs_output_write program~sdr_harvesting->hvs_output_write instance instance program~sdr_harvesting->instance proc~ply_sampled_track_init ply_sampled_track_init program~sdr_harvesting->proc~ply_sampled_track_init proc~ply_sampled_track_output ply_sampled_track_output program~sdr_harvesting->proc~ply_sampled_track_output proc~sdr_hvs_config_load sdr_hvs_config_load program~sdr_harvesting->proc~sdr_hvs_config_load proc~sdr_hvs_props_import_dofs sdr_hvs_props_import_dofs program~sdr_harvesting->proc~sdr_hvs_props_import_dofs sdr_append_protovar sdr_append_protovar program~sdr_harvesting->sdr_append_protovar sdr_readrestart sdr_readrestart program~sdr_harvesting->sdr_readrestart tem_create_stencil tem_create_stencil program~sdr_harvesting->tem_create_stencil tem_create_varMap tem_create_varMap program~sdr_harvesting->tem_create_varMap tem_finalize tem_finalize program~sdr_harvesting->tem_finalize tem_init_restart tem_init_restart program~sdr_harvesting->tem_init_restart tem_start tem_start program~sdr_harvesting->tem_start tem_time_reset tem_time_reset program~sdr_harvesting->tem_time_reset tem_varSys_append_meshInfoVar tem_varSys_append_meshInfoVar program~sdr_harvesting->tem_varSys_append_meshInfoVar tem_varSys_init tem_varSys_init program~sdr_harvesting->tem_varSys_init val val program~sdr_harvesting->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( tem_restart_type ) :: restart type(sdr_protoData_type), target :: protoData type( tem_general_type ) :: general type( treelmesh_type ) :: mesh type( sdr_hvs_config_type ) :: config type( sdr_hvs_props_type ) :: property type( hvs_output_file_type ) :: out_file type( tem_varSys_type ) :: varsys type( tem_varMap_type ) :: varMap type( tem_stencilHeader_type ) :: stencil type( tem_time_type ) :: time procedure( tem_varSys_proc_element ), pointer :: get_element integer :: iTrack integer :: nDofs integer :: nSimpleVars integer, allocatable :: var_degree (:) integer, allocatable :: lvl_degree (:) integer, allocatable :: var_space (:) character(len=pathLen) :: basename","tags":"","url":"program/sdr_harvesting.html"},{"title":"sdr_ellipsoid_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_ellipsoid_module.f90~~AfferentGraph sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** !> author: Kannan Masilamani !! This module contain adapter routine to load ellipsoid objects and add them to !! list of spatial objects module sdr_ellipsoid_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_transformation_module , only : tem_transformation_type use tem_ellipsoid_module , only : tem_ellipsoid_type , tem_load_ellipsoid , & & grw_ellipsoidArray_type , append use aotus_module , only : flu_State , aot_get_val , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use sdr_spatialObj_module , only : grw_spatialObjArray_type , & & sdr_spatialObj_type , append , & & ellipsoid implicit none private public :: sdr_load_ellipsoid contains ! ***************************************************************************** !> Load ellipsoid information from config file. subroutine sdr_load_ellipsoid ( sphArray , spaObjArray , attr_pos , transform , & & conf , thandle ) ! --------------------------------------------------------------------------! !inferface variables !> growing array of ellipsoids type ( grw_ellipsoidArray_type ), intent ( inout ) :: sphArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> Position of the attribute to connect this object to. integer , intent ( in ) :: attr_pos !> transformation for spatial object type ( tem_transformation_type ), intent ( in ) :: transform !> lua state type ( flu_state ) :: conf integer , intent ( in ) :: thandle !< handle for canonical objects ! --------------------------------------------------------------------------! ! local varaibles integer :: iObj type ( tem_ellipsoid_type ), allocatable :: loc_ellipsoid (:) type ( sdr_spatialObj_type ) :: spatialObj ! --------------------------------------------------------------------------! ! load ellipsoid call tem_load_ellipsoid ( loc_ellipsoid , transform , conf , thandle ) ! append ellipsoid do iObj = 1 , size ( loc_ellipsoid ) !append ellipsoid to ellipsoid array spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = ellipsoid call append ( sphArray , loc_ellipsoid ( iObj ) ) spatialObj % primitive_position = sphArray % nVals !add spatialObj to spatialObj list call append ( spaObjArray , spatialObj ) end do end subroutine sdr_load_ellipsoid ! ***************************************************************************** end module sdr_ellipsoid_module !> \\page ellipsoid ellipsoid !! ellipsoids are defined by an origin and radius. !! ellipsoid is considered to be solid as default i.e. all the cubes inside the !! ellipsoid are marked as intersected cubes. !! It is possible to created hollow ellipsoids by setting only_surface = true, !! it will mark only the cubes intersect with ellipsoid surface as intersected !! cubes !! !! Valid definition: !! \\li Single ellipsoid !! \\verbatim !! geometry={ !!   kind='ellipsoid', !!     object={ !!       origin={0.0,0.0,0.0}, !!       radius=0.25, !!       only_surface = true, -- If not defined default is set to false !!     } !! } !! \\endverbatim !! !! \\li Multiple ellipsoid !! \\verbatim !! geometry={ !!   kind='ellipsoid', !!     object={ !!       { !!       origin={0.0,0.0,0.0}, !!       radius=0.25 !!       }, !!       { !!       origin={-2.0,0.0,0.0}, !!       radius=0.25 !!       } !!     } !! } !! \\endverbatim !! \\n\\n !! The following seeder file is to generate mesh with hollow ellipsoid (hollow => only_surface=true) !!  inside: !! \\include testsuite/ellipsoid/seeder.lua !! \\n\\n !! Mesh generated with hollow ellipsoid by the seeder file: !! \\image html ellipsoid.png !! \\image html ellipsoid_withedges.png !! \\n\\n !! Cutview of mesh with hollow ellipsoid: !! \\image html ellipsoid_hollow.png !! \\n\\n !! Cutview of mesh with solid ellipsoid (solid => only_surface=false): !! \\image html ellipsoid_solid.png !! \\n\\n !! Example lua file is available at \\link testsuite/ellipsoid/seeder.lua !! \\example testsuite/ellipsoid/seeder.lua","tags":"","url":"sourcefile/sdr_ellipsoid_module.f90.html"},{"title":"ply_l2p_header_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_l2p_header_module.f90~~EfferentGraph sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ply_l2p_header_module.f90~~AfferentGraph sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_l2p_module.f90 ply_l2p_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013-2014 Verena Krupp ! Copyright (c) 2013-2014,2017,2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2013,2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2014 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2017 Daniel Petró <daniel.petro@student.uni-siegen.de> ! Copyright (c) 2019 Neda Ebrahimi Pour <neda.epour@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Peter Vitt, Verena Krupp, ! Nikhil Anand, Daniel Petró and Neda Ebrahimi Pour for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Parameters for the plain L2 projection method to transform between Legendre !! modes and nodal representation. !! !! This method utilizes the L2 projection from Legendre to Lagrange polynomials !! or the other way around. A numerical Gauss-Legendre Quadrature is used to !! compute the integral over the product of both functions. !! The Lagrange polynomials can be defined on any nodeset, see also !! [[ply_nodeset_module]]. !! !! Available options for the nodes to project onto are: !! !! * `'gauss-legendre'` these are the Gauss-Legendre integration points that !!   are also used for the numerical integration (this is the default). !! * `'chebyshev'` these are the nodes from the Chebyshev integration. !! !! The set of nodes to use is configured by the `nodes_kind` option, and if !! `nodes_kind = 'chebyshev'` it is also possible to make use of Lobatto points !! to include the interval boundaries in the nodal representation. !! This is achieved by setting `lobattoPoints = true`, by default this is false. !! !! The configuration table for a projection with L2P may, for example, look as !! follows: !! !!```lua !!  projection = { !!    kind = 'l2p', !!    factor = 1.5, !!    nodes_kind = 'chebyshev', !!    lobattoPoints = true !!  } !!``` !! !! The example illustrates the three possible settings for the L2P !! transformation method: !! !! * `factor` - Oversampling factor to avoid aliasing. !! * `nodes_kind` - Selection of set of nodes to use in the nodal !!   representation. !! * `lobattoPoints` - Whether to include interval bounds, only !!   available for Chebyshev nodes. !! module ply_l2p_header_module use env_module , only : rk , labelLen use aotus_module , only : flu_State , aot_get_val use aot_out_module , only : aot_out_type , aot_out_val use tem_tools_module , only : upper_to_lower use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use tem_float_module use ply_nodes_header_module implicit none private !> l2p projection header type, consisting of the node header which give !! information about the type and number of points for the projection type ply_l2p_header_type type ( ply_nodes_header_type ) :: nodes_header real ( kind = rk ) :: factor end type ply_l2p_header_type interface assignment ( = ) module procedure Copy_l2p_header end interface interface operator ( == ) module procedure isEqual end interface interface operator ( /= ) module procedure isUnequal end interface interface operator ( < ) module procedure isSmaller end interface interface operator ( <= ) module procedure isSmallerOrEqual end interface interface operator ( > ) module procedure isGreater end interface interface operator ( >= ) module procedure isGreaterOrEqual end interface public :: operator ( == ), operator ( /= ), operator ( < ), operator ( <= ) public :: operator ( > ), operator ( >= ) public :: assignment ( = ) public :: ply_l2p_header_type public :: ply_l2p_header_load , ply_l2p_header_display public :: ply_l2p_header_define public :: ply_l2p_header_out contains ! ************************************************************************ ! pure subroutine Copy_l2p_header ( left , right ) ! -------------------------------------------------------------------- ! !> fpt to copy to type ( ply_l2p_header_type ), intent ( out ) :: left !> fpt to copy from type ( ply_l2p_header_type ), intent ( in ) :: right ! -------------------------------------------------------------------- ! left % factor = right % factor left % nodes_header = right % nodes_header end subroutine Copy_l2p_header ! ************************************************************************ ! ! ************************************************************************ ! !> Load settings to describe a projection method from a Lua table. subroutine ply_l2p_header_load ( me , conf , thandle ) ! -------------------------------------------------------------------- ! type ( ply_l2p_header_type ), intent ( out ) :: me type ( flu_State ), intent ( inout ) :: conf integer , intent ( in ) :: thandle ! -------------------------------------------------------------------- ! character ( len = labelLen ) :: nodes_kind integer :: iError ! -------------------------------------------------------------------- ! ! for l2p gauss-legendre points are used me % nodes_header % nodes_kind = 'gauss-legendre' ! fill up l2p header call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'factor' , & & val = me % factor , & & default = 1.0_rk , & & ErrCode = iError ) call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'lobattoPoints' , & & val = me % nodes_header % lobattoPoints , & & ErrCode = iError , & & default = . false . ) call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'nodes_kind' , & & val = nodes_kind , & & ErrCode = iError , & & default = 'gauss-legendre' ) me % nodes_header % nodes_kind = upper_to_lower ( nodes_kind ) select case ( trim ( me % nodes_header % nodes_kind )) case ( 'gauss-legendre' ) if ( me % nodes_header % lobattoPoints ) then write ( logUnit ( 1 ), * ) 'ERROR in loading projection: Legendre nodes' & & // ' do not support Lobatto points' write ( logUnit ( 1 ), * ) 'But you configured to use Lobatto Points!' write ( logUnit ( 1 ), * ) 'Probably you want to use Chebyshev nodes instead!' call tem_abort () end if case ( 'chebyshev' ) ! Nothing to do case default write ( logUnit ( 1 ), * ) 'ERROR in loading projection: nodes_kind' write ( logUnit ( 1 ), * ) trim ( me % nodes_header % nodes_kind ) write ( logUnit ( 1 ), * ) 'The nodes_kind needs to be one of:' write ( logUnit ( 1 ), * ) ' * \"gauss-legendre\"' write ( logUnit ( 1 ), * ) ' * \"chebyshev\"' write ( logUnit ( 1 ), * ) '' write ( logUnit ( 1 ), * ) 'Aborting...' call tem_abort () end select if ( me % factor <= 0.0_rk ) then write ( logUnit ( 1 ), * ) 'ERROR in loading projection: factor for ' & & // 'projection has to be larger than 0!' write ( logUnit ( 1 ), * ) 'But it is set to ' , me % factor call tem_abort () end if end subroutine ply_l2p_header_load ! ************************************************************************ ! ! ************************************************************************ ! subroutine ply_l2p_header_define ( me , factor , nodes_kind , lobattoPoints ) ! -------------------------------------------------------------------- ! !> L2P header to define. type ( ply_l2p_header_type ), intent ( out ) :: me !> Oversampling factor to use in the projection, defaults to 1. integer , optional , intent ( in ) :: factor !> Set of nodes to use in the nodal representation. !! !! May be 'gauss-legendre' or 'chebyshev', defaults to 'gauss-legendre' character ( len =* ), optional :: nodes_kind !> Wether to use Lobatto points (include interval bounds) when using the !! chebyshev nodes, defaults to .false.. logical , optional , intent ( in ) :: lobattoPoints ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! ! Set defaults: me % nodes_header % nodes_kind = 'gauss-legendre' me % nodes_header % lobattoPoints = . false . me % factor = 1.0_rk if ( present ( nodes_kind )) me % nodes_header % nodes_kind & & = upper_to_lower ( nodes_kind ) if ( present ( lobattoPoints )) me % nodes_header % lobattoPoints = lobattoPoints if ( present ( factor )) me % factor = factor select case ( trim ( me % nodes_header % nodes_kind )) case ( 'gauss-legendre' ) if ( me % nodes_header % lobattoPoints ) then write ( logUnit ( 1 ), * ) 'ERROR in defining projection: Legendre nodes' & & // ' do not support Lobatto points' write ( logUnit ( 1 ), * ) 'But you configured to use Lobatto Points!' write ( logUnit ( 1 ), * ) 'Probably you want to use Chebyshev nodes instead!' call tem_abort () end if case ( 'chebyshev' ) ! Nothing to do case default write ( logUnit ( 1 ), * ) 'ERROR in defining projection: nodes_kind' write ( logUnit ( 1 ), * ) trim ( me % nodes_header % nodes_kind ) write ( logUnit ( 1 ), * ) 'The nodes_kind needs to be one of:' write ( logUnit ( 1 ), * ) ' * \"gauss-legendre\"' write ( logUnit ( 1 ), * ) ' * \"chebyshev\"' write ( logUnit ( 1 ), * ) '' write ( logUnit ( 1 ), * ) 'Aborting...' call tem_abort () end select if ( me % factor <= 0.0_rk ) then write ( logUnit ( 1 ), * ) 'ERROR in defining projection: factor for ' & & // 'projection has to be larger than 0!' write ( logUnit ( 1 ), * ) 'But it is set to ' , me % factor call tem_abort () end if end subroutine ply_l2p_header_define ! ************************************************************************ ! ! ************************************************************************ ! !> Write L2P settings into a Lua table. subroutine ply_l2p_header_out ( me , conf ) ! -------------------------------------------------------------------- ! type ( ply_l2p_header_type ), intent ( in ) :: me type ( aot_out_type ), intent ( inout ) :: conf ! -------------------------------------------------------------------- ! call aot_out_val ( put_conf = conf , & & vname = 'factor' , & & val = me % factor ) call aot_out_val ( put_conf = conf , & & vname = 'nodes_kind' , & & val = trim ( me % nodes_header % nodes_kind ) ) call aot_out_val ( put_conf = conf , & & vname = 'lobattoPoints' , & & val = me % nodes_header % lobattoPoints ) end subroutine ply_l2p_header_out ! ************************************************************************ ! ! ************************************************************************ ! subroutine ply_l2p_header_display ( me ) ! -------------------------------------------------------------------- ! type ( ply_l2p_header_type ), intent ( in ) :: me ! -------------------------------------------------------------------- ! write ( logUnit ( 1 ), * ) ' * Kind of projection method = l2p' write ( logUnit ( 1 ), * ) ' * Factor to use in projection = ' , me % factor write ( logUnit ( 1 ), * ) ' * using this set of nodes: ' & & // trim ( me % nodes_header % nodes_kind ) write ( logUnit ( 1 ), * ) ' * using LobattoPoints =' , & & me % nodes_header % lobattoPoints if ( me % factor < 2.0_rk ) then write ( logUnit ( 1 ), * ) '' write ( logUnit ( 1 ), * ) & & '+-----------------------------------------------------+' write ( logUnit ( 1 ), * ) & & '| WARNING, the oversampling factor is smaller than 2! |' write ( logUnit ( 1 ), * ) & & '|        this might lead to bad projections!          |' write ( logUnit ( 1 ), * ) & & '+-----------------------------------------------------+' end if end subroutine ply_l2p_header_display ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides the test for equality of two projections. !! !! Two l2p header are considered to be equal, if their node_header, !! and the factor are equal. pure function isEqual ( left , right ) result ( equality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_l2p_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_l2p_header_type ), intent ( in ) :: right !> is equal?? logical :: equality ! -------------------------------------------------------------------- ! equality = ( left % nodes_header == right % nodes_header ) & & . and . ( left % factor . feq . right % factor ) end function isEqual ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides the test for unequality of two projections. !! !! Two l2p header are considered to be unequal, if their node_header, !! or the factor are not equal. pure function isUnequal ( left , right ) result ( unequality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_l2p_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_l2p_header_type ), intent ( in ) :: right !> is unequal?? logical :: unequality ! -------------------------------------------------------------------- ! unequality = ( left % nodes_header /= right % nodes_header ) & & . or . ( left % factor . fne . right % factor ) end function isUnequal ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a < comparison of two projections. !! !! Sorting of l2p header is given by node_header and by the factor. pure function isSmaller ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_l2p_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_l2p_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! small = . false . if ( left % nodes_header < right % nodes_header ) then small = . true . else if ( left % nodes_header == right % nodes_header ) then small = ( left % factor < right % factor ) end if end if end function isSmaller ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a <= comparison of two projections. !! !! Sorting of l2p header is given by node_header, l2p_blocksize and !! last by factor. pure function isSmallerOrEqual ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_l2p_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_l2p_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! small = . false . if ( left % nodes_header < right % nodes_header ) then small = . true . else if ( left % nodes_header == right % nodes_header ) then small = ( left % factor <= right % factor ) end if end if end function isSmallerOrEqual ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a > comparison of two projections. !! !! Sorting of l2p header is given by node_header, l2p_blocksize and !! last by factor. pure function isGreater ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_l2p_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_l2p_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! great = . false . if ( left % nodes_header > right % nodes_header ) then great = . true . else if ( left % nodes_header == right % nodes_header ) then great = ( left % factor > right % factor ) end if end if end function isGreater ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a >= comparison of two projections. !! !! Sorting of l2p header is given by node_header, l2p_blocksize and !! last by factor. pure function isGreaterOrEqual ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_l2p_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_l2p_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! great = . false . if ( left % nodes_header > right % nodes_header ) then great = . true . else if ( left % nodes_header == right % nodes_header ) then great = ( left % factor >= right % factor ) end if end if end function isGreaterOrEqual ! ************************************************************************ ! end module ply_l2p_header_module","tags":"","url":"sourcefile/ply_l2p_header_module.f90.html"},{"title":"sdr_sphere_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_sphere_module.f90~~AfferentGraph sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2014, 2017 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011-2013, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011 Metin Cakircali <m.cakircali@grs-sim.de> ! Copyright (c) 2012 Sathish Krishnan P S <s.krishnan@grs-sim.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** !> author: Kannan Masilamani !! This module contain adapter routine to load sphere objects and add them to !! list of spatial objects module sdr_sphere_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_transformation_module , only : tem_transformation_type use tem_sphere_module , only : tem_sphere_type , tem_load_sphere , & & grw_sphereArray_type , append use aotus_module , only : flu_State , aot_get_val , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use sdr_spatialObj_module , only : grw_spatialObjArray_type , & & sdr_spatialObj_type , append , & & sphere implicit none private public :: sdr_load_sphere contains ! **************************************************************************** !> Load sphere information from config file. subroutine sdr_load_sphere ( sphArray , spaObjArray , attr_pos , transform , & & conf , thandle ) ! -------------------------------------------------------------------------! !inferface variables !> growing array of spheres type ( grw_sphereArray_type ), intent ( inout ) :: sphArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> Position of the attribute to connect this object to. integer , intent ( in ) :: attr_pos !> transformation for spatial object type ( tem_transformation_type ), intent ( in ) :: transform !> lua state type ( flu_state ) :: conf integer , intent ( in ) :: thandle !< handle for canonical objects ! -------------------------------------------------------------------------! ! local varaibles integer :: iObj type ( tem_sphere_type ), allocatable :: loc_sphere (:) type ( sdr_spatialObj_type ) :: spatialObj ! -------------------------------------------------------------------------! ! load sphere objects call tem_load_sphere ( loc_sphere , transform , conf , thandle ) do iObj = 1 , size ( loc_sphere ) !append sphere to sphere array spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = sphere call append ( sphArray , loc_sphere ( iObj ) ) spatialObj % primitive_position = sphArray % nVals !add spatialObj to spatialObj list call append ( spaObjArray , spatialObj ) end do end subroutine sdr_load_sphere ! **************************************************************************** end module sdr_sphere_module !> \\page sphere Sphere !! Spheres are defined by an origin and radius. !! Sphere is considered to be solid as default i.e. all the cubes inside the !! sphere are marked as intersected cubes. !! It is possible to created hollow spheres by setting only_surface = true, !! it will mark only the cubes intersect with sphere surface as intersected !! cubes !! !! Valid definition: !! \\li Single sphere !! \\verbatim !! geometry={ !!   kind='sphere', !!     object={ !!       origin={0.0,0.0,0.0}, !!       radius=0.25, !!       only_surface = true, -- If not defined default is set to false !!     } !! } !! \\endverbatim !! !! \\li Multiple sphere !! \\verbatim !! geometry={ !!   kind='sphere', !!     object={ !!       { !!       origin={0.0,0.0,0.0}, !!       radius=0.25 !!       }, !!       { !!       origin={-2.0,0.0,0.0}, !!       radius=0.25 !!       } !!     } !! } !! \\endverbatim !! \\n\\n !! The following seeder file is to generate mesh with hollow sphere (hollow => only_surface=true) !!  inside: !! \\include testsuite/sphere/seeder.lua !! \\n\\n !! Mesh generated with hollow sphere by the seeder file: !! \\image html sphere.png !! \\image html sphere_withedges.png !! \\n\\n !! Cutview of mesh with hollow sphere: !! \\image html sphere_hollow.png !! \\n\\n !! Cutview of mesh with solid sphere (solid => only_surface=false): !! \\image html sphere_solid.png !! \\n\\n !! Example lua file is available at \\link testsuite/sphere/seeder.lua !! \\example testsuite/sphere/seeder.lua","tags":"","url":"sourcefile/sdr_sphere_module.f90.html"},{"title":"sdr_protoTree_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_prototree_module.f90~~EfferentGraph sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_prototree_module.f90~~AfferentGraph sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2016, 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2015, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012, 2014, 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2018 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** !> This module provides the description of the evolving tree, as it is built !! up to match the given geometry. !! !! The concept used here, is a proposal for an algorithm, following a !! level-wise iterative approach instead of an recursive one. !! This is better suited for parallel processing. !! Also it tries to follow more closely the principals from tem_construction !! and the solver layout. !! That is, treating seeder more like a solver in itself. !! !! For flooding a concept of wet sides on coarser levels is used, all elements !! need to track just a single neighbor in each direction in this case. !! And the coarse ghost elements take care of flooding their children !! accordingly themselves. module sdr_protoTree_module use , intrinsic :: iso_c_binding use env_module , only : globalMaxLevels , long_k , rk , newunit , & & isLittleEndian , pathLen , labelLen use tem_param_module , only : qOffset , qQQQ , qInvDir , childCoord use treelmesh_module , only : treelmesh_type use tem_debug_module , only : main_debug use tem_global_module , only : tem_global_type , dump_tem_global use tem_dyn_array_module , only : PositionOfVal use tem_grow_array_module , only : grw_longArray_type , init , append , destroy , & & truncate , grw_intArray_type use tem_restart_module , only : tem_restart_type , tem_restart_writeHeader use tem_tools_module , only : tem_horizontalSpacer use tem_logging_module , only : logunit use tem_topology_module , only : tem_directChildren , tem_FirstIdAtLevel , & & tem_parentOf , tem_CoordOfId , tem_IdOfCoord use tem_varSys_module , only : tem_varSys_type , tem_varSys_init , & & tem_varSys_append_stateVar , & & tem_varSys_proc_point , & & tem_varSys_proc_element use tem_varMap_module , only : tem_create_varMap use tem_time_module , only : tem_time_type use tem_aux_module , only : tem_abort use tem_solveHead_module , only : tem_solverTag use sdr_geometry_module , only : sdr_geometry_type , is_intersecting , & & sdr_append_distanceRefineObject use sdr_spatialObj_module , only : periodicPlane use tem_cube_module , only : tem_cube_type use sdr_attribute_module , only : sdr_Boundary_Object , sdr_Seed_Object , & & sdr_Refinement_Object , & & sdr_object_kinds_max , & & sdr_Fluidifyable_Object , & & sdr_noSolidification_Object , & & sdr_any_bc_subresolution , & & sdr_any_bc_distanceRefine use sdr_node_module , only : sdr_node_type , sdr_wetNeighborsFace , & & intersectsBoundary_bit , hasBoundary_bit , & & isLeaf_bit , isTarget_bit , isFlooded_bit , & & isFluidifyable_bit , isNoSolidification_bit , & & sdr_mark_floodNode , append , init , truncate , & & sdr_set_nodeProp_bit , & & sdr_clear_nodeProp_bit , sdr_nodeProp_btest , & & sdr_inHeritBnd_eligibleChildren , & & sdr_append_childIntersectedObject , & & sdr_intersectObjPos_type use sdr_config_module , only : sdr_confHead_type use sdr_protoData_module , only : sdr_append_protoVar use sdr_timer_module , only : timer_handle_proto use tem_timer_module , only : tem_startTimer , tem_stopTimer implicit none private public :: sdr_protoTree_type public :: sdr_build_protoTree public :: levelValues_type public :: sdr_write_proto_as_restart public :: sdr_neighbor_in_proto public :: sdr_node_neighbors !> The protoTree is used to describe the preliminary tree, before it !! is actually extended to the full information of the mesh. !! !! This extension will only be done for the actual leaf nodes, in the !! computational domain. type sdr_protoTree_type !> Keep track of the deepest level in the tree. integer :: nLevels !> Number of leaf nodes. integer :: nLeafNodes !> Number of flooded leaves. integer :: nFloodedLeaves !> List of all nodes in the tree, each node contains a list of the !! objects it is intersecting and a property bit mask. !! It is identified by its treeID. !! !! All components of Node are growing arrays, thus the corresponding !! component of node inode has to be accessed with component%val(inode). type ( sdr_node_type ) :: node !> The index of the first node on a given level in node%treeID%sorted. integer :: levelNode_first ( 0 : globalMaxLevels ) !> The index of the last node on a given level in node%treeID%sorted. integer :: levelNode_last ( 0 : globalMaxLevels ) !> Temporary array intersected objects of 8 children which will later !! be copied to intersected_object in node_type. !! !! This array is initialized in build_protoTree and destroyed !! after refine_leaf type ( grw_intArray_type ) :: child_intersected_object end type sdr_protoTree_type !> Auxilary data type to provide data on the current level iteration. type levelValues_type !> First treeID on current level integer ( kind = long_k ) :: ID_offset !> Node cube length on current level real ( kind = rk ) :: dx !> Number of the level itself. integer :: level end type levelValues_type contains ! **************************************************************************** !> This routine builds the preliminary tree with geometry intersection and !! neighbor identification subroutine sdr_build_protoTree ( me , geometry , header ) ! --------------------------------------------------------------------------! !> preliminary tree created by this routine type ( sdr_protoTree_type ), intent ( out ) :: me !> type which contains all geometry object infos type ( sdr_geometry_type ), intent ( inout ) :: geometry !> some global information on solver name and version type ( sdr_confHead_type ), intent ( inout ) :: header ! --------------------------------------------------------------------------! integer ( kind = long_k ) :: parent_ID_offset real ( kind = rk ) :: parent_dx integer :: parent_coord ( 4 ) integer :: iLevel integer :: iParent integer :: iSide integer :: firstParent integer :: lastParent integer :: nodePos integer :: nNodes integer :: nColors integer :: iColor integer :: nBoundaries integer :: nSublevels logical :: distanceRefine integer , allocatable :: nodeprops (:) integer :: linkpos ( 6 ) logical :: nullify_parent_sl logical :: neigh_noLeaf , neigh_noSub , neigh_intersected logical :: testAll type ( levelValues_type ) :: leVal ! --------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_proto ) call tem_horizontalSpacer ( funit = logunit ( 1 )) write ( logunit ( 1 ), * ) 'Building preliminary tree ...' me % nLeafNodes = 0 me % nFloodedLeaves = 0 me % levelNode_first = 1 me % levelNode_last = 0 me % nLevels = 0 ! Initialize temporary growing array for childrens ! Destroy it after refine_leaf routine call init ( me % child_intersected_object ) nColors = geometry % attribute % uni_name ( sdr_Seed_object )% nVals nBoundaries = geometry % attribute % uni_name ( sdr_Boundary_object )% nVals ! Set the number of sublevels only, if there is at least one active bc ! that requires it. Otherwise we are going to ignore subelement resolution. if ( sdr_any_bc_subresolution ( geometry % attribute )) then nSublevels = header % subresolution % nLevels else nSublevels = 0 end if ! Set if distance refine is defined for any boundary attribute. ! Consider only boundary with distance_refine%reach_level>0 distanceRefine = sdr_any_bc_distanceRefine ( geometry % attribute ) ! Initialize the list of all nodes call init ( me = me % node , & & nColors = nColors , & & nSublevels = nSublevels , & & distanceRefine = distanceRefine , & & none_color_id = geometry % attribute % none_color_id ) allocate ( nodeprops ( me % node % propLength )) ! Define the root node (complete universe) nodeprops = 0 ! By definition, this node intersects all geometric objects. ! so test all spatial objects only in the root node testAll = . true . ! The root node. It has a treeID of 0, and never is a subelement. call append ( me = me % node , & & treeID = 0_long_k , & & PropertyBits = nodeprops , & & sublevel = - 1 , & & minLevel = header % minLevel , & & pos = nodePos ) ! Checking if there are any boundary objects here. To include periodic ! walls, we need to check all attribute kinds and can not rely on the ! counted kindpos, as that excludes the periodic objects. if ( any ( geometry % attribute % dynArray & & % val (: geometry % attribute % dynArray & & % nVals )% kind & & == sdr_Boundary_object )) then ! There are boundaries defined, as by definition, all boundaries are in ! the root node, the root node intersects boundaries, set the according ! bit to create its children subsequently. call sdr_set_nodeProp_bit ( node = me % node , & & iNode = nodePos , & & bit = IntersectsBoundary_bit ) ! No neighbors for this virtual node. do iSide = 1 , 6 me % node % linkpos ( iSide )% val ( nodePos ) = 0 end do else ! No boundaries defined at all, there is only the root element. ! (Which is also to be flooded unconditionally with all colors.) call sdr_set_nodeProp_bit ( node = me % node , & & iNode = nodePos , & & bit = isLeaf_bit ) do iColor = 1 , nColors call sdr_mark_floodNode ( node = me % node , & & iNode = nodePos , & & nFloodedLeaves = me % nFloodedLeaves , & & color = iColor ) end do ! The universe is periodic, and therefore all neighbors refer back to the ! root node itself. do iSide = 1 , 6 me % node % linkpos ( iSide )% val ( nodePos ) = nodePos end do ! Increase the counter of leaf nodes me % nLeafNodes = me % nLeafNodes + 1 end if ! Mark the boundaries of level 0. me % levelNode_first ( 0 ) = nodePos me % levelNode_last ( 0 ) = nodePos ! Set the length of the level cube length to the complete bounding cube ! length initially. leVal % dx = geometry % universe % extent leVal % ID_offset = 0_long_k levelLoop : do iLevel = 1 , globalMaxlevels write ( logunit ( 2 ), * ) 'current Level ' , iLevel ! The first node on the current level has to be one after all the nodes ! already in the mesh. me % levelNode_first ( iLevel :) = me % node % nNodes + 1 firstParent = me % levelNode_first ( iLevel - 1 ) lastParent = me % levelNode_last ( iLevel - 1 ) parent_ID_offset = leVal % ID_offset ! First treeID on parent level parent_dx = leVal % dx ! (save from previous iteration) ! Set some auxilary data describing the current level. leVal % dx = 0.5_rk * leVal % dx ! length of cube nodes on this level leVal % ID_offset = tem_FirstIdAtLevel ( iLevel ) ! first treeID on this level leVal % level = iLevel ! level count ! Set hasBoundary properties for neighbors of intersected ! leaf bit on parent level to inHerit to children before looping ! over parent to create children. ! Also create sphere object if distance function ! is defined for this boundary and append sphere object ! to list of spatial objects. do iParent = firstParent , lastParent ! Coordinates of parent parent_coord = tem_CoordOfId ( & & treeID = me % node % treeID % val ( iParent ), & & offset = parent_ID_offset ) if ( sdr_nodeProp_btest ( node = me % node , & & iNode = iParent , & & bit = intersectsBoundary_bit ) ) then ! if intersected boundary and leaf node then set ! neighbors of this node to hasBoundary bit if ( sdr_nodeProp_btest ( node = me % node , & & iNode = iParent , & & bit = isLeaf_bit ) ) then call sdr_mark_neighborHasBnd ( proto = me , & & coord = parent_coord ) end if ! Create sphere object and attribute for distance function and ! append to list of spatial objects if parent in intersected boundary call sdr_append_distanceRefineObject ( & & coord = parent_coord , & & dx = parent_dx , & & iLevel = iLevel - 1 , & & geometry = geometry , & & intersected_first = me % node % userObjPos & & % val ( iParent )% first , & & intersected_last = me % node % userObjPos & & % val ( iParent )% last , & & intersected_object = me % node % intersected_object ) end if ! parent is intersectedBoundary end do ! parent loop ! Iterate over all elements on the previous level. parElemLoop : do iParent = firstParent , lastParent if ( sdr_nodeProp_btest ( node = me % node , & & iNode = iParent , & & bit = isLeaf_bit ) ) then ! At this point the domain boundaries have been resolved down to the ! required level in this location of the mesh. ! For flooding we need the neighbors of all leaf-nodes, and children ! of non-leaves. ! We can exploit here, that the 8 children are always placed ! consecutively one after the other in the node list an thus, storing ! the position of the first child is sufficient to find them all. ! 6 integers to store the positions of linked elements are therefore ! sufficient, as neighbors are not needed for virtual nodes. ! Reached a leaf node in the prototree, lookup it's neighbors. ! This is possible here, as prototree neighbors are either on the ! current level, or on a previous level. linkpos = sdr_node_neighbors ( me = me , & & level_offset = parent_ID_offset , & & iNode = iParent ) do iSide = 1 , 6 me % node % linkpos ( iSide )% val ( iParent ) = linkpos ( iSide ) end do ! If the current node is flooded, wet all the neighboring sides ! by setting the appropiate bits in the neighbors properties. ! This avoids special treatment in the flooding routine for the ! initially flooded elements. call sdr_wetNeighborsFace ( node = me % node , & & iNode = iParent ) else ! The parent is not a leaf node, will add all eight children at the ! end of the current node list, thus the first one will be at position ! nNodes + 1. ! Store this vertical link here, as it will later on be required ! during flooding. me % node % linkpos ( 1 )% val ( iParent ) = me % node % nNodes + 1 ! Flag to indicate, whether the parent sublevel needs to be restored ! to a non-negative value, after children where created. nullify_parent_sl = . false . if ( sdr_nodeProp_btest ( node = me % node , & & iNode = iParent , & & bit = isTarget_bit ) & & . and . geometry % smoothbounds ) then ! If the parent was a target, we need to check the neighbors for ! their status, to ensure proper resolution, in the proximity of ! highly resolved non-subelement boundaries. ! Obviously this can only happen, if subresolution is active, and ! therefore the sublevel array is available. ! By setting smoothbounds to false this can be deactivated, however ! in this case it might happen, that the subresolved element ! neighbors to multiple boundary conditions on its sides and it is ! not quite clear which ones to use. linkpos = sdr_node_neighbors ( me = me , & & level_offset = parent_ID_offset , & & iNode = iParent ) do iSide = 1 , 6 ! If any adjacent element is not a leaf but intersected by ! boundaries, it will be further refined. In this case we also ! need to refine the current parent further, that is, we need to ! remove its target bit, and turn it into a non-subelement node ! for the children (sublevel < 0). ! However, this should only be done, if the intersected neighbor ! itself is not a subelement. To avoid neighboring target elements ! to cause infinite refinement, we therefore need to detect ! neighboring target elements as well. As the sublevel has no ! relevance after creating the chilren, we will temporaly set the ! sublevel of the current parent to a negative value and restore ! a positive one afterwards again (for future neighbor checks). ! Though, this might be a little confusing, the only other option ! would be to introduce yet another bit to set for this case. neigh_noLeaf = . not . sdr_nodeProp_btest ( node = me % node , & & iNode = linkpos ( iSide ), & & bit = isLeaf_bit ) neigh_intersected = sdr_nodeProp_btest ( & & node = me % node , & & iNode = linkpos ( iSide ), & & bit = intersectsBoundary_bit ) neigh_noSub = me % node % sublevel % val ( linkpos ( iSide )) < 0 if ( neigh_noSub . and . neigh_intersected . and . neigh_noLeaf ) then ! Found a neighbor to the current parent, that will be further ! refined due to boundaries. Remove the target bit from it and ! pretend a negative sublevel for the chilren. nullify_parent_sl = . true . me % node % sublevel % val ( iParent ) = - 1 call sdr_clear_nodeProp_bit ( node = me % node , & & iNode = iParent , & & bit = isTarget_bit ) ! We can end the loop as soon, as any neighbor with these ! properties was found... EXIT end if end do end if ! Add all eight children. call create_children ( me = me , & & parent = iParent , & & geometry = geometry , & & leVal = leVal , & & testAll = testAll , & & minlevel = header % minlevel ) if ( nullify_parent_sl ) then ! If we removed the target bit from our parent above, we need to set ! its sublevel to a non-negative value here again. ! Otherwise neighboring target nodes would not recognize this node ! as one, which is only refined due to neighbors. me % node % sublevel % val ( iParent ) = 0 ! Reset the parent to a common virtual node again, thus it should ! have a 0 minbcid again. me % node % minBCID % val ( iParent ) = 0 end if end if ! parent is leaf end do parElemLoop me % levelNode_last ( iLevel :) = me % node % nNodes ! The number of elements on the current level, compute this count with ! the difference of the first and last index of nodes on the current ! level. nNodes = me % levelNode_last ( iLevel ) - me % levelNode_first ( iLevel ) + 1 write ( logunit ( 3 ), * ) '  * nodes on this level: ' , nNodes write ( logunit ( 3 ), * ) '' ! Leave the loop, if no new nodes were created in this iteration. if ( nNodes == 0 ) exit ! Update the number of levels in the tree, as the current level contains ! new elements. me % nLevels = iLevel ! after root node deactivate testAll testAll = . false . end do levelLoop ! Found all leaves and resolved boundaries to the requested resolution. ! Free memory of growing arrays, if they are longer than the actual ! data. call truncate ( me % node ) write ( logunit ( 1 ), * ) '                          ... done with level: ' , & & me % nLevels write ( logunit ( 1 ), * ) 'Number of leaves:      ' , me % nLeafNodes write ( logunit ( 1 ), * ) 'Total number of nodes: ' , me % node % nNodes write ( logunit ( 2 ), * ) 'Number of flooded leaves while building tree: ' , & & me % nFloodedLeaves write ( logunit ( 1 ), * ) 'Memory unused in parent intersected_object: ' , & & me % node % memLeft_userObj if ( me % nFloodedLeaves == 0 ) then write ( logunit ( 0 ), * ) 'Error: There are no flooded leaves. ' write ( logunit ( 0 ), * ) & & 'PLACE SEED AT NON-SOLID ELEMENT. Terminating seeder...' call tem_abort () end if write ( logunit ( 1 ), * ) '' ! Finished the prototree with all necessary data for flooding. ! We can now go on and identify the elements belonging to the domain with ! the flooding algorithm. call tem_stopTimer ( timerHandle = timer_handle_proto ) end subroutine sdr_build_protoTree ! **************************************************************************** ! **************************************************************************** !> This routine creates children for each parent if children !! intersect with boundary object. !! !! First loop over 8 children, and test for intersection of each child cube !! with the geometry objects inherited from the parent node. !! Then check for various object kinds, that might be intersected: !! If BOUNDARY objects are intersected, record the minimal bcID for later, !! boundaries are only marked as a leaf if the maxlevel has been reached. !! If NO BOUNDARY are intersected, the refinement can stop early here, and !! the node is marked as leaf. This avoids overly many elements before !! flooding. !! If a leaf is intersecting a SEED object, mark it already as flooded here. !! Children that do not intersect any objects do not need to be refined !! further at this stage and are marked as leaf nodes. subroutine create_children ( me , parent , geometry , leval , testAll , minlevel ) ! --------------------------------------------------------------------------! !> preliminary tree on which childern are created type ( sdr_protoTree_type ), intent ( inout ) :: me !> Position of parent node on the growing array of node_treeID and node_data !! in preliminary tree integer , intent ( in ) :: parent !> type which contains all geometry object infos type ( sdr_geometry_type ), intent ( in ) :: geometry !> contains information on current level on which children are created type ( levelValues_type ), intent ( in ) :: leVal !> testAll objects only for root node logical , intent ( in ) :: testAll integer , intent ( in ) :: minlevel !minimum refinement for fluids ! --------------------------------------------------------------------------! integer :: iChild , iObject integer :: nObjects ! number of objects need to intersect with integer ( kind = long_k ) :: treeID ( 8 ) ! treeID of eight children integer :: node_coord ( 4 ) integer :: firstchild_coord ( 4 ) integer :: node_pos ! position in node list ( me%node ) integer :: obj_pos integer :: attr_pos integer :: attr_kind integer :: maxLevel ! the ultimate level this child should resolve integer :: min_BCID integer :: n_ni_seeds integer :: seed_color ( me % node % nColors ) integer :: propbits ( me % node % propLength ) integer :: iColor integer :: col_int , col_bit ! number of objects in each kind for one child integer :: objkind_count ( sdr_object_kinds_max ) integer :: bc_color integer :: bcid integer :: child_sublevel logical :: reached_leaf logical :: reached_maxlevel logical :: subresolution logical :: color_seeded ( me % node % nColors ) logical :: color_intersected ( me % node % nColors ) logical :: nonecolor_intersected logical :: child_hasBnd ( 8 ) type ( sdr_intersectObjPos_type ) :: child_objPos ( 8 ) integer :: intersected_first , intersected_last integer :: child_nodePos ( 8 ) integer :: child_nObjects ( 8 ) integer :: memLeft type ( tem_cube_type ) :: node_cube ! --------------------------------------------------------------------------! ! If parent has hasBoundary_bit then inherit this property to its children child_hasBnd = sdr_inHeritBnd_eligibleChildren ( me % node , parent ) ! Get treeID of eight children treeID ( 1 : 8 ) = tem_directChildren ( me % node % treeID % val ( parent )) if ( me % node % subelement_resolution > 0 ) then child_sublevel = me % node % sublevel % val ( parent ) - 1 else ! If there is no subelement resolution the sublevels are not available. ! However, we store a negative value here in child_sublevel to avoid ! further checks for subelement_resolution further down. child_sublevel = - 1 end if ! Get the length of children cube. all children cubes have same length. node_cube % extent = leVal % dx node_cube % halfwidth = 0.5_rk * leVal % dx if ( testAll ) then nObjects = geometry % nUserObjs intersected_first = 1 intersected_last = nObjects else intersected_first = me % node % userObjPos % val ( parent )% first intersected_last = me % node % userObjPos % val ( parent )% last nObjects = intersected_last - intersected_first + 1 end if ! Coordinate of childs can be computed with an offset from ! first child using childCoord parameter firstchild_coord = tem_coordOfId ( treeID = treeID ( 1 ), & & offset = leVal % ID_offset ) ! Initialize counter for child_intersected_first and last child_objPos (:)% first = 1 child_objPos (:)% last = 0 me % child_intersected_object % nVals = 0 childLoop : do iChild = 1 , 8 !>@todo HK: The content of the childLoop should probably move into its !!          own subroutine, it could then also be used to define the root !!          node (treeID=0). Though this might just add a 9th check on !!          all defined objects in most cases. Needs further thinking. ! Set the flag on the maximal level in the intersected boundary objects ! initially to 0. maxLevel = minlevel ! Set the counts for all object kinds to 0. objkind_count = 0 ! the first intersected object of this child has to be one after ! all the previous childs intersected objects child_objPos ( iChild :)% first = me % child_intersected_object % nVals + 1 ! Define the children cube to intersect with. node_coord ( 1 : 3 ) = firstchild_coord ( 1 : 3 ) + childCoord ( iChild ,:) node_cube % origin = leVal % dx * node_coord ( 1 : 3 ) + geometry % universe % origin node_cube % endPnt = leVal % dx * ( node_coord ( 1 : 3 ) + 1 ) + geometry % universe % origin node_cube % center = node_cube % origin + node_cube % halfwidth ! Append this child to the tree. propBits = 0 call append ( me = me % node , & & treeID = treeID ( iChild ), & & PropertyBits = propBits , & & sublevel = child_sublevel , & & minlevel = minlevel , & & pos = node_pos ) ! position of this node in node list child_nodePos ( iChild ) = node_pos ! if this child hasBnd, set the hasBoundary_bit ! and copy the directions which has boundary from parent. ! if parent has boundary in certain direction, its child should have ! the save since hasBoundary is set by the leaf of intersected ! boundary node if ( child_hasBnd ( iChild )) then call sdr_set_nodeProp_bit ( node = me % node , & & iNode = node_pos , & & bit = hasBoundary_bit ) me % node % hasBndBits % val ( node_pos ) = me % node % hasBndBits % val ( parent ) end if ! Trumping rule to set boundaryID for each direction when a node ! is intersected by more than one boundary object. min_bcID = huge ( min_bcID ) bcid = 0 color_seeded = . false . color_intersected = . false . ! Check for subresolution of this node. ! Subresolution is only activated for non-periodic boundaries and those ! with a specific color. Boundaries that should apply to all colors can ! not be subresolved, as it is unclear what values should be used outside ! the computational domain. ! Subresolution becomes necessary if any intersected boundary requests it. ! If a boundary should be subresolved or not is given by its attribute. subresolution = . false . nonecolor_intersected = . false . ! Loop over the objects which intersected with parent objLoop : do iObject = intersected_first , intersected_last if ( testAll ) then obj_pos = iObject else obj_pos = me % node % intersected_object % val ( iObject ) end if ! Test for intersection of geometric object and node_cube. if ( is_intersecting ( node_cube , geometry , obj_pos )) then ! If there is an intersection, add the object to the ! intersected_object list of the child. call append ( me % child_intersected_object , obj_pos ) attr_pos = geometry % spatialObj % val ( obj_pos )% attribute_position attr_kind = geometry % attribute % dynArray % val ( attr_pos )% kind objkind_count ( attr_kind ) = objkind_count ( attr_kind ) + 1 select case ( geometry % attribute % dynArray % val ( attr_pos )% kind ) case ( sdr_Boundary_object ) bcid = geometry % attribute % dynArray % val ( attr_pos )% id min_bcID = min ( min_bcID , bcid ) ! Exclude periodic boundaries from the color check. if ( bcid > 0 ) then bc_color = geometry % attribute % bc_color_id ( bcid ) if ( bc_color < 0 ) then ! Negative values are used for boundaries, which should ! affect all colors. color_intersected = . true . ! The nonecolor is treated somewhat special as, a node that is ! intersected by this kind of boundary should not be ! subresolved. nonecolor_intersected = . true . else if ( bc_color > 0 ) then ! This boundary should be applied to a specific color. color_intersected ( bc_color ) = . true . ! If there is any boundary with a specific color and ! required subresolution, this element needs to be resolved ! beyond the levels of the mesh. subresolution = ( subresolution & & . or . geometry % attribute % dynArray & & % val ( attr_pos )% subresolution ) end if else ! Periodic boundaries always affect all colors. color_intersected = . true . end if case ( sdr_Seed_object ) color_seeded ( geometry % attribute % dynArray % val ( attr_pos )% uni_id ) & & = . true . end select ! Update the maximal level of intersected objects. ! ( Always refine objects down to maximal level of all objects ! intersecting the cube. That is, refinementboxes might enforce ! a higher boundary resolution than the boundary object itself. ! Objects, that should have no influence on the resolution, like ! seeds, should have set their level low enough e.g. 0). ! KM: Do not refine periodic boundaries, Refining periodic boundaries ! causes issue in finding periodic neighbor between coarser fluid ! node and refined periodic boundary node. if ( bcid /= - 1 ) then maxLevel = max ( maxlevel , & & geometry % attribute % dynArray % val ( attr_pos )% level ) end if end if ! is_intersecting end do objLoop ! ------------------------------------------------------------------------! ! Set child intersected object first and last in child_intersected_object child_objPos ( iChild :)% last = me % child_intersected_object % nVals child_nObjects ( iChild ) = child_objPos ( iChild )% last & & - child_objPos ( iChild )% first + 1 ! ------------------------------------------------------------------------! ! Check whether this child intersects any boundary object. ! Update intersectsboundary_bit if necessary. ! For the proto tree only boundaries need to be resolved fully, ! stop everything else as early as possible. ! Thus, reached leaf depends on the maxlevel only if there are ! boundaries intersected it is true in all other cases. if ( objkind_count ( sdr_Boundary_object ) > 0 ) then call sdr_set_nodeProp_bit ( node = me % node , & & iNode = node_pos , & & bit = intersectsBoundary_bit ) reached_maxlevel = ( leval % level == globalmaxlevels ) reached_leaf = ( ( maxLevel <= leval % level ) . or . reached_maxlevel ) ! Only do a subresolution, if the element is not intersected by a BC ! with the 'none' color. BCs with the 'none' color restrict the overall ! computational domain, and elements intersected by it, will not be ! part of the domain. Therefore, there is no need for subresolution ! here. subresolution = ( subresolution . and . (. not . nonecolor_intersected ) & & . and . ( me % node % subelement_resolution > 0 ) ) leaf : if ( reached_leaf ) then sub : if ( child_sublevel < 0 ) then ! Hit either a leaf or target element (node is not subelement yet). me % node % minBCID % val ( node_pos ) = min_bcID if ( subresolution . and . (. not . reached_maxlevel ) & & . and . min_bcID >= 0 ) then ! There is a boundary that needs to be refined on a subelement ! resolution, this can only be true, if subelement_resolution is ! greater than 0, and thus, the sublevel data is available. ! Mark this node as target, and set the sublevels according to the ! subelement_resolution. ! Subresolution is not possible if the maximal level was already ! reached, in this case, the element is treated like a normal ! leaf node. ! It is also not possible periodic boundaries, if the element ! intersects a periodic boundary, subresolution will be ignored. ! (Periodic boundaries trump all other boundaries) call sdr_set_nodeProp_bit ( node = me % node , & & iNode = node_pos , & & bit = isTarget_bit ) me % node % sublevel % val ( node_pos ) = me % node % subelement_resolution reached_leaf = . false . end if else sub ! The parent is a target element or already a subelement. ! Decide end of refinement independent of maxLevel and use the ! sublevel counter instead. Never refine beyond the maximal allowed ! total number of elements. if ( ( child_sublevel > 0 ) . and . (. not . reached_maxlevel ) ) then reached_leaf = . false . else ! Reached the required subelement resolution, finally this can ! be marked as a leaf node, also store the minbcid for this ! element now. me % node % minBCID % val ( node_pos ) = min_bcID end if end if sub end if leaf else ! If there is no boundary intersected, no further refinement ! is necessary. reached_leaf = . true . end if ! Check whether this child intersects any noSolidification object. ! Update noSolidification_bit if necessary. if ( objkind_count ( sdr_noSolidification_object ) > 0 ) then call sdr_set_nodeProp_bit ( node = me % node , & & iNode = node_pos , & & bit = isNoSolidification_bit ) end if ! Set count for non-intersected leaves to 0, to allow their counting ! in the loop. n_ni_seeds = 0 ! Setting color specific properties according to the intersected objects ! now (only necessary if there is actually something intersected): if ( child_nObjects ( iChild ) > 0 ) then ! Loop over colors to find color dependent properties of this node. do iColor = 1 , me % node % nColors if ( color_intersected ( iColor )) then ! The node is intersected by a boundary that is relevant for ! iColor. Set the according bit. col_int = ( iColor - 1 ) / me % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , me % node % bytes_per_int ) * 8 me % node % PropertyBits % val ( col_int , Node_pos ) & & = ibset ( me % node % PropertyBits % val ( col_int , Node_pos ), col_bit ) else if ( color_seeded ( iColor )) then ! Not intersected by relevant boundary, but seeded. ! Add to list of possible seeds. If this node is actually a leaf, ! it will be marked as flooded in that color. n_ni_seeds = n_ni_seeds + 1 seed_color ( n_ni_seeds ) = iColor end if end do end if ! this node intersects with any object if ( reached_Leaf ) then ! This node is actually a leaf, mark it as such and flood it in ! seeded colors as needed. call mark_leafNode ( me = me , & & node_pos = node_pos ) do iColor = 1 , n_ni_seeds ! For all non-intersected seeds, mark the leaf node as flooded. call sdr_mark_floodNode ( node = me % node , & & iNode = node_pos , & & nFloodedLeaves = me % nFloodedLeaves , & & color = seed_color ( iColor ) ) end do end if end do childLoop ! Now copy temporary growing array of intersected objects of child ! to actual array of intersected_objects if ( any ( child_nObjects > 0 )) then call sdr_append_childIntersectedObject ( & & node = me % node , & & parent = parent , & & testAll = testAll , & & intersected_object = me % node % intersected_object , & & grwObjPos = me % node % userObjPos , & & child_nodePos = child_nodePos , & & child_nObjects = child_nObjects , & & child_intersected_object = me % child_intersected_object , & & child_objPos = child_objPos , & & memLeft = memLeft ) ! track memory unused from parent intersected object list me % node % memLeft_userObj = me % node % memLeft_userObj + memLeft end if end subroutine create_children ! **************************************************************************** ! **************************************************************************** !> Small helping routine to keep track of leaf nodes. !! !!@todo HK: Originally this operation was inlined in create_children in !!          a few places. Need to check for performance impact? Readability !!          was not hurt too much by this, but it was changed into a flag and !!          final decision, which in my opinion did not improve the !!          readability as the reader has to track down the location where the !!          final decision is taken, and introduces an additional if. !!          It might be that the compiler is smart enough on both variants !!          but anyway, I would prefer such a small routine if you think !!          inlining is too burdensome. !!          We should have an eye on the performance, though. subroutine mark_leafNode ( me , node_pos ) ! --------------------------------------------------------------------------! !> Property bit mask to set the leaf bit in type ( sdr_protoTree_type ), intent ( inout ) :: me integer , intent ( in ) :: node_pos ! --------------------------------------------------------------------------! me % nLeafNodes = me % nLeafNodes + 1 call sdr_set_nodeProp_bit ( node = me % node , & & iNode = node_pos , & & bit = isLeaf_bit ) end subroutine mark_leafNode ! **************************************************************************** ! **************************************************************************** !> This routine identifies the 6 direct neighbors of a node in the prototree !! !!@todo We could cut the lookups of neighbors in the complete tree !!      by one half, if we set the siblings within the same !!      direct parent by their in-node relation (all 8 siblings within a !!      parent either exist or do not exist at all). !!      We than would have to iterate only over the remaining !!      three outer sides of each node here. function sdr_node_neighbors ( me , level_offset , iNode , coord ) result ( neighbors ) ! --------------------------------------------------------------------------! !> neighbors are identified for this tree and neighbor of each node !! are stored at link_pos of each node in node_data type type ( sdr_protoTree_type ), intent ( in ) :: me !> First treeID on level integer ( kind = long_k ), optional , intent ( in ) :: level_offset !> Node position in protoTree integer , intent ( in ) :: iNode !> if coord is present, no need to compute using tem_coordOfID integer , intent ( in ), optional :: coord ( 4 ) integer :: neighbors ( 6 ) ! --------------------------------------------------------------------------! integer :: iLevel integer :: iDir integer :: iSide integer :: iNeighbor integer :: offset ( 4 ) integer ( kind = long_k ) :: neighbor_tID integer :: neighbor_pos integer :: neighbor_level integer :: coord_loc ( 4 ) ! --------------------------------------------------------------------------! ! 3D offset to indicate neighbor to look up. offset = 0 if ( present ( coord )) then coord_loc = coord else coord_loc = tem_coordOfId ( treeID = me % node % treeID % val ( iNode ), & & offset = level_offset ) end if iLevel = coord_loc ( 4 ) dirLoop : do iDir = 1 , 3 sideLoop : do iSide = 1 , 2 offset ( iDir ) = iSide * 2 - 3 ! offset = -1 or 1 iNeighbor = ( iDir - 1 ) * 2 + iSide ! iNeighbor = 1, 2,..., 6 neighbor_tID = tem_IdOfCoord ( coord = coord_loc + offset , & & offset = level_offset ) ! Find the neighbor on the current level or on any ! one above (move one level up, when the neighbor is not found). neighLoop : do neighbor_level = iLevel , 0 , - 1 neighbor_pos = PositionOfVal ( & & me = me % node % treeID , & & val = neighbor_tID , & & lower = me % levelNode_first ( neighbor_level ), & & upper = me % levelNode_last ( neighbor_level ) ) if ( neighbor_pos > 0 ) then ! Found the neighbor, put it into the list of neighbors neighbors ( iNeighbor ) = neighbor_pos ! Leave the loop exit else neighbor_tID = tem_ParentOf ( neighbor_tID ) end if end do neighLoop end do sideLoop ! reset offset in current direction to 0. offset ( iDir ) = 0 end do dirLoop end function sdr_node_neighbors ! **************************************************************************** ! **************************************************************************** !> This routine marks 26 direct neighbors as has boundary bit subroutine sdr_mark_neighborHasBnd ( proto , coord ) ! --------------------------------------------------------------------------! !> neighbors are identified for this tree and neighbors !! as marked with hasBoundary_bit type ( sdr_protoTree_type ), intent ( inout ) :: proto !> Coordinate of current node integer , intent ( in ) :: coord ( 4 ) ! --------------------------------------------------------------------------! integer :: iDir integer :: neighbor_level integer :: neighbor_pos ! --------------------------------------------------------------------------! ! loop over all 26 directions do iDir = 1 , qQQQ ! get position of neighbor in the protoTree which might me ! from different level neighbor_pos = sdr_neighbor_in_proto ( proto , coord , iDir , & & neighbor_level ) call sdr_set_nodeProp_bit ( node = proto % node , & & iNode = neighbor_pos , & & bit = hasBoundary_bit ) ! From neighbor node the current intersected boundary node ! is at inverse direction of iDir proto % node % hasBndBits % val ( neighbor_pos ) = & & ibset ( proto % node % hasBndBits % val ( neighbor_pos ), qInvDir ( iDir ) ) end do end subroutine sdr_mark_neighborHasBnd ! **************************************************************************** ! **************************************************************************** !> Write current leaves of the prototree as treelm restart. !! !! This routine is mainly for debugging, to allow the visualization of the !! tree with harvester. The mesh will not contain any properties, instead !! additional data is provided as restart. !! Note that recursive output is used, to write each leaf node on its own, !! this output is thus really only useful for debugging, and might take very !! long for large meshes, however memory consumption should be fairly small. !! @todo SDR_write_proto_as_restart is a explicitly serial routine, deploying !!       its own writing to save memory. Therefore this is some code !!       duplication from treelmesh_module::dump_treelmesh. subroutine sdr_write_proto_as_restart ( proto , geometry , itime , header , & & prefix ) ! --------------------------------------------------------------------------! !> The prototree to output. type ( sdr_protoTree_type ), intent ( in ) :: proto !> Bounding cube, the prototree lives in. type ( sdr_geometry_type ), intent ( in ) :: geometry !> wave number in character format to prepend to filenames and timestamp integer , intent ( in ) :: itime !> some global information on solver name and version type ( sdr_confHead_type ), intent ( in ) :: header !> prefix for filenames character ( len =* ), optional , intent ( in ) :: prefix ! --------------------------------------------------------------------------! type ( treelmesh_type ) :: dummy_treelmesh type ( tem_global_type ) :: tem_global type ( tem_varsys_type ) :: varsys type ( tem_restart_type ) :: restart type ( tem_time_type ) :: timing character ( len = PathLen ) :: ElemFileName character ( len = 4 ) :: EndianSuffix character ( len = labelLen ) :: charWave character ( len = labelLen ), allocatable :: varLabel (:) !character(len=labelLen) :: varLabel real ( kind = rk ) :: protodata ( 11 + proto % node % nColors ) integer :: meshunit integer :: restunit integer :: rl integer :: iLeaf integer :: iColor character ( len = labelLen ) :: prefix_loc procedure ( tem_varSys_proc_point ), pointer :: get_point => null () procedure ( tem_varSys_proc_element ), pointer :: get_element => null () ! --------------------------------------------------------------------------! if ( isLittleEndian ) then EndianSuffix = '.lsb' else EndianSuffix = '.msb' end if if ( present ( prefix )) then prefix_loc = trim ( prefix ) else prefix_loc = '' endif write ( charwave , * ) itime charwave = trim ( adjustl ( charwave )) timing % iter = itime timing % sim = real ( itime , kind = rk ) tem_global % BoundingCubeLength = geometry % universe % extent tem_global % Origin = geometry % universe % origin tem_global % EffLength = tem_global % BoundingCubeLength tem_global % EffOrigin = tem_global % Origin tem_global % nElems = proto % nLeafNodes tem_global % nParts = 1 tem_global % myPart = 0 tem_global % minLevel = 0 tem_global % maxLevel = proto % nLevels tem_global % label = 'ProtoTree' tem_global % comment = 'A ProtoTree from Seeder.' tem_global % nProperties = 0 ! No properties, everything in restart data. tem_global % dirname = trim ( main_debug % debugMesh ) // trim ( prefix_loc )& & // trim ( charWave ) // '_mesh_' dummy_treelmesh % global = tem_global allocate ( tem_global % property ( tem_global % nProperties ) ) ! Initialize varsys with a length of 16 (there will be at least 12 vars) call tem_varsys_init ( me = varsys , & & systemName = 'meshInfo' , & & length = 16 ) ! proto variables dumped as restart output allocate ( varLabel ( 11 + proto % node % nColors )) varLabel ( 1 : 11 ) = ( / 'refLevel          ' , 'isFlooded         ' , & & 'nObjects          ' , 'nSeeds            ' , & & 'nRefines          ' , 'nFluidifyable     ' , & & 'nBounds           ' , 'trumping_bound    ' , & & 'target_level      ' , 'bcAttr_pos_minBCID' , & & 'hasBnd            ' / ) do iColor = 1 , proto % node % nColors ! 2. Wetness (= 1 for each wet face or 10 if flooded) varLabel ( 11 + iColor ) = 'wet_' // trim ( geometry & & % attribute & & % uni_name ( sdr_seed_object ) & & % val ( iColor )) end do ! Set pointers appropriately. call sdr_append_protoVar ( protoVar = varLabel , & & varSys = varsys , & & method_data = c_null_ptr , & & get_element = get_element ) ! Create varMap call tem_create_varMap ( varName = varsys % varname % val ( & & 1 : varsys % varname % nVals ), & & varSys = varSys , & & varMap = restart % varMap ) restart % header % headerPrefix = trim ( main_debug % debugMesh ) // trim ( prefix_loc )& & // trim ( charWave ) // '_restart_ProtoData' ! set the timestamp to be the current wave iWave stored in prefix restart % header % timestamp = trim ( charWave ) restart % header % binName = trim ( main_debug % debugMesh ) // trim ( prefix_loc ) & & // trim ( charWave ) // '_restart_ProtoData' & & // EndianSuffix restart % write_file % nDofs = 1 ! set the right solvertag restart % header % solverTag = tem_solverTag ( header % general % solver ) ! copy the global communicator to the restart one restart % comm = header % general % proc ! Dump global mesh info to header.lua. call dump_tem_global ( tem_global ) ! Write restart header information. call tem_restart_writeHeader ( me = restart , & & tree = dummy_treelmesh , & & varSys = varSys , & & timing = timing ) ElemFileName = trim ( tem_global % dirname ) // 'elemlist' // EndianSuffix meshunit = newunit () inquire ( iolength = rl ) 0_long_k , 0_long_k open ( unit = meshunit , file = trim ( ElemFileName ), action = 'write' , & & form = 'unformatted' , access = 'direct' , & & recl = rl ) restunit = newunit () inquire ( iolength = rl ) protodata open ( unit = restunit , file = trim ( restart % header % binName ), & & action = 'write' , & & form = 'unformatted' , access = 'direct' , & & recl = rl ) if ( sdr_nodeProp_btest ( node = proto % node , iNode = 1 , bit = isLeaf_bit )) then ! Only the root node exists as leaf. write ( meshunit , rec = 1 ) 0_long_k , 0_long_k write ( restunit , rec = 1 ) protoData_ofNode ( 1 , proto , geometry , 0 ) else iLeaf = 0 call write_childLeaves ( meshunit = meshunit , restunit = restunit , & & iLeaf = iLeaf , level = 0 , & & node_pos = 1 , proto = proto , geometry = geometry ) end if close ( meshunit ) close ( restunit ) end subroutine sdr_write_proto_as_restart ! **************************************************************************** ! **************************************************************************** !> Small helping routine to write leaves in order into a treelmesh formatted !! file. recursive subroutine write_childLeaves ( meshunit , restunit , iLeaf , node_pos , & & proto , geometry , level ) integer , intent ( in ) :: meshunit integer , intent ( in ) :: restunit integer , intent ( inout ) :: iLeaf integer , intent ( in ) :: node_pos integer , intent ( in ) :: level type ( sdr_prototree_type ), intent ( in ) :: proto type ( sdr_geometry_type ), intent ( in ) :: geometry integer :: iChild integer :: childpos integer :: nextlevel nextlevel = level + 1 if ( nextlevel > proto % nLevels ) return do iChild = 0 , 7 childpos = proto % node % linkpos ( 1 )% val ( node_pos ) + iChild if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = childpos , & & bit = isLeaf_bit ) ) then iLeaf = iLeaf + 1 write ( meshunit , rec = iLeaf ) proto % node % treeID % val ( childPos ), 0_long_k write ( restunit , rec = iLeaf ) protoData_ofNode ( childPos , proto , geometry , & & level ) else call write_childLeaves ( meshunit = meshunit , restunit = restunit , & & iLeaf = iLeaf , & & node_pos = childpos , proto = proto , & & geometry = geometry , level = nextlevel ) end if end do end subroutine write_childLeaves ! **************************************************************************** ! **************************************************************************** !> Small helping routine to get the variable data from a leaf. function protoData_ofNode ( node_pos , proto , geometry , level ) result ( protodata ) ! --------------------------------------------------------------------------! integer , intent ( in ) :: node_pos type ( sdr_prototree_type ), intent ( in ) :: proto type ( sdr_geometry_type ), intent ( in ) :: geometry integer , intent ( in ) :: level real ( kind = rk ) :: protodata ( 11 + proto % node % nColors ) ! --------------------------------------------------------------------------! integer :: iSide , iObj integer :: trumping , maxlevel integer :: obj_pos , attr_pos , attr_kind integer :: objkind_count ( sdr_object_kinds_max ) integer :: nObjects integer :: nColors integer :: iColor integer :: col_int , col_bit logical :: countAll integer :: intersected_first , intersected_last ! --------------------------------------------------------------------------! protodata = 0.0_rk objkind_count = 0 nColors = proto % node % nColors if ( level == 0 ) then nObjects = geometry % spatialObj % nVals intersected_first = 1 intersected_last = nObjects countAll = . true . else intersected_first = proto % node % userObjPos % val ( node_pos )% first intersected_last = proto % node % userObjPos % val ( node_pos )% last nObjects = intersected_last - intersected_first + 1 countAll = . false . end if ! - Refinement level protodata ( 1 ) = level ! - Wetness (= 1 for each wet face or 10 if flooded) ! Check flooding for first color (in first integer, bit 1): if ( sdr_nodeProp_btest ( proto % node , node_pos , isFlooded_bit ) ) then protodata ( 2 ) = 1.0_rk end if do iColor = 1 , proto % node % nColors col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 + 1 if ( btest ( proto % node % PropertyBits % val ( col_int , node_pos ), col_bit )) then protodata ( 11 + iColor ) = 1 0.0_rk else do iSide = 1 , 6 if ( btest ( proto % node % PropertyBits % val ( col_int , node_pos ), & & col_bit + iSide ) ) then protodata ( 11 + iColor ) = protodata ( 10 + iColor ) + 1.0_rk end if end do end if end do ! - Number of intersected objects protodata ( 3 ) = nObjects ! count number of each attibute kind maxlevel = 0 trumping = geometry % attribute % dynArray % nVals + 1 do iObj = intersected_first , intersected_last if ( countAll ) then obj_pos = iObj else obj_pos = proto % node % intersected_object % val ( iObj ) end if attr_pos = geometry % spatialObj % val ( obj_pos )% attribute_position attr_kind = geometry % attribute % dynArray % val ( attr_pos )% kind objkind_count ( attr_kind ) = objkind_count ( attr_kind ) + 1 if ( attr_kind == sdr_Boundary_object ) then trumping = min ( trumping , attr_pos ) end if maxlevel = max ( maxlevel , geometry % attribute % dynArray % val ( attr_pos )% level ) end do ! - Intersected seeds protodata ( 4 ) = objkind_count ( sdr_Seed_object ) ! - Intersected refinements protodata ( 5 ) = objkind_count ( sdr_Refinement_object ) ! - Intersected fluidifyable elements protodata ( 6 ) = objkind_count ( sdr_fluidifyable_object ) ! - Intersected boundaries protodata ( 7 ) = objkind_count ( sdr_Boundary_object ) ! - Trumping boundary (trumping boundary condition or 0 if none) if ( sdr_Boundary_object > 0 ) then protodata ( 8 ) = trumping end if ! - Target ref level (maximum level of intersected objects) protodata ( 9 ) = maxlevel ! - bc attribute position protodata ( 10 ) = proto % node % minBCID % val ( node_pos ) ! - hasBoundary bit is also set for non-flooded and intersected ! boundary bit so set hasBnd =1 only for flooded and hasboundary nodes if ( sdr_nodeProp_btest ( proto % node , node_pos , hasBoundary_bit ) . and . & & sdr_nodeProp_btest ( proto % node , node_pos , isFlooded_bit ) ) then protodata ( 11 ) = 1.0_rk end if end function protoData_ofNode ! **************************************************************************** ! **************************************************************************** !> Find the neighbor position in protoTree for iDir on the same level !! or on any one above. function sdr_neighbor_in_proto ( proto , coord , iDir , neighbor_level ) & & result ( pos ) !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto integer , intent ( in ) :: coord ( 4 ) integer , intent ( in ) :: iDir integer , intent ( out ) :: neighbor_level integer :: pos ! --------------------------------------------------------------------------! integer :: myLevel , iLevel , offset ( 4 ), neighbor_coord ( 4 ) integer ( kind = long_k ) :: neighbor_tID pos = - 1 offset = 0 neighbor_coord = 0 myLevel = coord ( 4 ) offset ( 1 : 3 ) = qOffset ( iDir ,:) neighbor_coord = coord + offset neighbor_tID = tem_IdOfCoord ( coord = neighbor_coord ) ! Find the neighbor on the current level or on any one above. levelLoop : do iLevel = myLevel , 0 , - 1 pos = PositionOfVal ( & & me = proto % node % treeID , & & val = neighbor_tID , & & lower = proto % levelNode_first ( iLevel ), & & upper = proto % levelNode_last ( iLevel ) ) if ( pos > 0 ) then neighbor_level = iLevel return else ! Can NOT find neighbor, get its parent ID on one above level neighbor_tID = tem_ParentOf ( neighbor_tID ) end if end do levelLoop end function sdr_neighbor_in_proto ! **************************************************************************** end module sdr_protoTree_module","tags":"","url":"sourcefile/sdr_prototree_module.f90.html"},{"title":"ply_sampling_adaptive_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_sampling_adaptive_module.f90~~EfferentGraph sourcefile~ply_sampling_adaptive_module.f90 ply_sampling_adaptive_module.f90 sourcefile~ply_filter_element_module.f90 ply_filter_element_module.f90 sourcefile~ply_sampling_adaptive_module.f90->sourcefile~ply_filter_element_module.f90 sourcefile~ply_sampling_varsys_module.f90 ply_sampling_varsys_module.f90 sourcefile~ply_sampling_adaptive_module.f90->sourcefile~ply_sampling_varsys_module.f90 sourcefile~ply_split_element_module.f90 ply_split_element_module.f90 sourcefile~ply_sampling_adaptive_module.f90->sourcefile~ply_split_element_module.f90 sourcefile~ply_split_legendre_module.f90 ply_split_legendre_module.f90 sourcefile~ply_split_element_module.f90->sourcefile~ply_split_legendre_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2017-2019, 2022 Harald Klimach <harald.klimach@dlr.de> ! Copyright (c) 2018, 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2017-2018 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Peter Vitt and Daniel ! Fleischer for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Adaptive sampling of polynomial data. !! !! This module implements the sampling of polynomials with data dependent !! refinement. !! Elements, where the polynomials vary above a certain threshold, will be !! split into their eight children and the polynomial data will be projected !! onto those. !! The polynomials in the children can be restricted in their order to limit !! the memory consumption. !! In the end only one degree of freedom will be returned for each (refined) !! element, these are always the mean of the solution in those (refined) !! elements. !! !! The module provides a data type to describe the configuration of the !! adaptive sampling: [[ply_sampling_adaptive_type]], !! one routine to load this configuration [[ply_sampling_adaptive_load]] and !! one routine to actually perform the adaptive sampling !! [[ply_sample_adaptive]]. module ply_sampling_adaptive_module use mpi use iso_c_binding , only : c_f_pointer , c_loc use env_module , only : rk , labelLen use aotus_module , only : flu_state , & & aot_get_val use treelmesh_module , only : treelmesh_type use tem_aux_module , only : tem_abort use tem_bc_prop_module , only : tem_bc_prop_type , & & tem_bc_prop_pos , & & tem_bc_prop_sublist use tem_logging_module , only : logunit use tem_refining_module , only : tem_refine_global_subtree use tem_subtree_type_module , only : tem_subtree_type , & & tem_destroy_subtree use tem_subTree_module , only : tem_subTree_from , & & tem_create_subTree_of , & & tem_create_tree_from_sub use tem_time_module , only : tem_time_type use tem_topology_module , only : tem_levelOf use tem_tracking_module , only : tem_tracking_instance_type , & & tem_tracking_config_type use tem_tools_module , only : upper_to_lower use tem_varsys_module , only : tem_varSys_proc_element , & & tem_varSys_proc_point , & & tem_varSys_proc_getParams , & & tem_varSys_proc_setParams , & & tem_varSys_proc_setupIndices , & & tem_varSys_proc_getValOfIndex , & & tem_varsys_append_statevar , & & tem_varSys_type , & & tem_varSys_op_type , & & tem_varSys_getParams_dummy , & & tem_varSys_setParams_dummy use ply_sampling_varsys_module , only : ply_sampling_var_type , & & ply_sampling_varsys_for_track , & & ply_sampling_var_allocate , & & ply_sampling_var_move , & & ply_sampling_var_compute_elemdev use ply_split_element_module , only : ply_split_element_init , & & ply_split_element , & & ply_split_element_1D , & & ply_split_element_2D , & & ply_split_element_3D use ply_filter_element_module , only : ply_filter_element , & & ply_filter_element_type , & & ply_filter_element_load implicit none private public :: ply_sample_adaptive public :: ply_sampling_adaptive_type public :: ply_sampling_adaptive_load !> Constant to indicate the factor reduction mode. integer , parameter :: redux_factor = 1 !> Constant to indicate the decrement reduction mode. integer , parameter :: redux_decrement = 2 !> Configuration of the adaptive sampling. !! !! The main setting is max_nlevels, which states the maximum number of !! levels that elements will be refined. type ply_sampling_adaptive_type !> Maximal number of levels by which any mesh element should be refined. !! !! A setting of 0 results in no sampling, and the original mesh elements !! will be used with the integral mean value (first degree of freedom). !! Higher levels provide a limit for the refinement of the mesh. !! Note, that even for large settings here, the overall mesh depth is !! restricted by the global limit, due to the available space in the !! integers representing the treeIDs. integer :: max_nlevels = 0 !> Maximum allowed oscillation of the solution. !! For adaptive subsampling only. real ( kind = rk ) :: eps_osci !> Method to use for the reduction. !! !! This may either be: !! !! - redux_factor: multiply the maximal polynomial degree by the !!               given factor in each refinement level. This allows to !!               maintain the same total number of degrees of freedom by !!               halfing the modes during each refinement. !!               This is the default reduction mode !! - redux_decrement: Cut off the given dof_decrement last modes in each !!                    refinement. This can be used to filter off the most !!                    oscillatory modes while affecting the solution !!                    minimally otherwise. integer :: reduction_mode !> Indication whether to filter modes during refinement by ignoring !! all modes in the parent, that exceed the target polynomial degree !! of the child elements. !! !! This provides a simple lowpass filtering method if activated. !! Defaults to false. logical :: ignore_highmodes = . false . !> Number of modes to cut off in each refinement. !! !! If the decrement mode for reduction is used, this setting will !! be used to cut off as many modes from the refined elements. integer :: dof_decrement = 1 !> Factor to Reduce dofs for every sampling level. !! Can be used to avoid too drastic increase of memory consumption. !! For adaptive subsampling only. real ( kind = rk ) :: dofReducFactor !> Indicator for the limitation of memory consumption. logical :: adaptiveDofReduction !> Absolute upper bound level to refine to. integer :: AbsUpperBoundLevel !> Filtering the poylnomial modes during adaptive refinement. !! !! This filtering provides the possibility to change the applied !! filtering based on the polynomials and thereby attempting to !! capture discontinuities more sharply. type ( ply_filter_element_type ) :: filter_element end type ply_sampling_adaptive_type !> Small helping type to allow arrays of arrays for the variable data. type realarray_type real ( kind = rk ), pointer :: dat (:) => NULL () end type realarray_type !> A container for the method data to hold the data in a scalar pointer for !! the C-pointer conversion. type sampled_method_data_type type ( realarray_type ), allocatable :: component (:) end type sampled_method_data_type contains ! ------------------------------------------------------------------------- ! !> Load the configuration for adaptive subsampling. subroutine ply_sampling_adaptive_load ( me , conf , parent ) ! -------------------------------------------------------------------- ! !> Sampling definition to load. type ( ply_sampling_adaptive_type ), intent ( out ) :: me !> Configuration to read the sampling settings from. type ( flu_State ), intent ( in ) :: conf !> Parent table in which to look for the adaptive sampling settings. integer , intent ( in ), optional :: parent ! -------------------------------------------------------------------- ! integer :: iError character ( len = labelLen ) :: reduction_mode ! -------------------------------------------------------------------- ! call aot_get_val ( L = conf , & & thandle = parent , & & key = 'nlevels' , & & val = me % max_nlevels , & & ErrCode = iError , & & default = 0 ) call aot_get_val ( L = conf , & & thandle = parent , & & key = 'tolerance' , & & val = me % eps_osci , & & ErrCode = iError , & & default = 0.0_rk ) write ( logunit ( 1 ), * ) '  Using a tolerance of ' , me % eps_osci call aot_get_val ( L = conf , & & thandle = parent , & & key = 'AbsUpperBoundLevel' , & & val = me % AbsUpperBoundLevel , & & ErrCode = iError , & & default = 0 ) if ( me % AbsUpperBoundLevel > 0 ) then write ( logunit ( 1 ), * ) '  Level ' , me % AbsUpperBoundLevel , & & ' will be used as absolute upper bound for the' write ( logunit ( 1 ), * ) '  refinement. No element will be refined beyond this' write ( logunit ( 1 ), * ) '  level.' end if call aot_get_val ( L = conf , & & thandle = parent , & & key = 'ignore_highmodes' , & & val = me % ignore_highmodes , & & ErrCode = iError , & & default = . false . ) if ( me % ignore_highmodes ) then write ( logunit ( 1 ), * ) 'The highest modes that exceed the target degree' write ( logunit ( 1 ), * ) 'will be ignored during each refinement!' end if call aot_get_val ( L = conf , & & thandle = parent , & & key = 'reduction_mode' , & & val = reduction_mode , & & ErrCode = iError , & & default = 'factor' ) reduction_mode = upper_to_lower ( reduction_mode ) select case ( trim ( reduction_mode )) case ( 'factor' ) me % reduction_mode = redux_factor call aot_get_val ( L = conf , & & thandle = parent , & & key = 'dof_reduction' , & & val = me % dofReducFactor , & & ErrCode = iError , & & default = 0.5_rk ) if ( me % dofReducFactor > 1.0_rk . or . me % dofReducFactor <= 0.0_rk ) then write ( logunit ( 1 ), * ) 'ERROR: dof_reduction has invalid setting:' , & & me % dofReducFactor call tem_abort ( 'dof_reduction needs to be in ' & & // '0.0 < dof_reduction <= 1.0' ) end if call aot_get_val ( L = conf , & & thandle = parent , & & key = 'adaptiveDofReduction' , & & val = me % adaptiveDofReduction , & & ErrCode = iError , & & default = . FALSE . ) if ( me % adaptiveDofReduction ) then write ( logunit ( 1 ), * ) '  Reducing the degrees of freedom adaptively.' write ( logunit ( 1 ), * ) '  This option tries to keep as many degrees of' & & // ' freedom' write ( logunit ( 1 ), * ) '  as possible while not increasing the required' write ( logunit ( 1 ), * ) '  memory.' write ( logunit ( 1 ), * ) '  However, the factor for the reduction will be' write ( logunit ( 1 ), * ) '  at least ' , me % dofReducFactor write ( logunit ( 1 ), * ) '  Even if this results in an increased memory' write ( logunit ( 1 ), * ) '  consumption after the refinement.' else write ( logunit ( 1 ), * ) 'Reducing the degrees of freedom on each ' & & // 'refinement by a factor of' , & & me % dofReducFactor end if case ( 'decrement' ) me % reduction_mode = redux_decrement call aot_get_val ( L = conf , & & thandle = parent , & & key = 'dof_decrement' , & & val = me % dof_decrement , & & ErrCode = iError , & & default = 1 ) write ( logunit ( 1 ), * ) '  Degrees of freedom will be decremented' , & & ' on each level by ' , me % dof_decrement case default write ( logunit ( 1 ), * ) 'ERROR: Unknown reduction mode: ' , & & trim ( reduction_mode ) write ( logunit ( 1 ), * ) 'Available reduction modes are:' write ( logunit ( 1 ), * ) '* factor' write ( logunit ( 1 ), * ) '* decrement' call tem_abort ( 'Unknown reduction mode!' ) end select call ply_filter_element_load ( & & me = me % filter_element , & & conf = conf , & & parent = parent ) end subroutine ply_sampling_adaptive_load ! ------------------------------------------------------------------------- ! ! ------------------------------------------------------------------------- ! ! ------------------------------------------------------------------------- ! !> Sample data described by varsys in orig_mesh according to the tracking !! object trackInst with adaptive refinements. !! !! Only works for Q-Polynomials. subroutine ply_sample_adaptive ( me , ndims , orig_mesh , orig_bcs , varsys , & & var_degree , lvl_degree , trackInst , & & trackConfig , time , new_mesh , resvars ) ! -------------------------------------------------------------------- ! !> A ply_sampling_type to describe the sampling method. type ( ply_sampling_adaptive_type ), intent ( in ) :: me !> The original mesh to be refined. type ( treelmesh_type ), intent ( in ) :: orig_mesh !> Boundary conditions for the original mesh. type ( tem_BC_prop_type ), intent ( in ) :: orig_bcs !> Variable system of the original data to do the sampling on. type ( tem_varsys_type ), intent ( in ) :: varsys !> Maximal polynomial degree for each variable. !! !! Needs to be matching the variable definition in the variable system. !! @todo Needs to be changed to be an information per element per variable! !!       Possibly by defining a variable in the varsys, providing the !!       degree. integer , intent ( in ) :: var_degree (:) !> Maximal polynomial degree for each level. integer , intent ( in ) :: lvl_degree (:) !> Number of dimensions in the polynomial representation. integer , intent ( in ) :: ndims !> Tracking object describing what to sample. type ( tem_tracking_instance_type ), intent ( in ) :: trackInst !> Tracking configuration with the geometry to obtain from the overall mesh. type ( tem_tracking_config_type ), intent ( in ) :: trackConfig !> Point in time to get the data for. type ( tem_time_type ), intent ( in ) :: time !> The new mesh with the refined elements. type ( treelmesh_type ), intent ( out ) :: new_mesh !> Resulting system of variables describing the data in the arrays of !! subsampled elements. type ( tem_varsys_type ), intent ( out ) :: resvars ! -------------------------------------------------------------------- ! type ( ply_sampling_var_type ), pointer :: var (:) => NULL () type ( ply_sampling_var_type ), pointer :: prev (:) => NULL () type ( sampled_method_data_type ), pointer :: vardat => NULL () real ( kind = rk ), allocatable :: reduction_factor (:) real ( kind = rk ), allocatable :: maxmean (:) real ( kind = rk ), allocatable :: minmean (:) real ( kind = rk ) :: memprefac real ( kind = rk ), pointer :: parent_data (:,:) => NULL () real ( kind = rk ), pointer :: child_data (:,:) => NULL () integer :: maxtarget integer :: targetdeg integer :: containersize integer :: nMaxModes integer :: nChildren integer :: nVars integer :: nScalars integer :: nComponents integer :: nDofs integer :: nOldDofs integer :: nElems integer :: newElems integer :: refinedElems integer :: varpos integer :: bcpos integer :: firstdof , lastdof integer :: oldfirst , oldlast integer :: iVar integer :: iScalar integer :: iComponent integer :: iRefLevel integer :: iElem integer :: iRefElem integer :: iNewElem integer :: iChild integer :: elemlevel integer :: iError integer , allocatable :: ReducableElems (:) integer , allocatable :: map2global (:) integer , allocatable :: maxdeg (:) integer , allocatable :: origsize (:) logical , allocatable :: reached_limit (:) logical , allocatable :: is_varying (:) logical :: lastRefine logical :: need2refine type ( treelmesh_type ), pointer :: curmesh => NULL () type ( treelmesh_type ), pointer :: oldmesh => NULL () type ( tem_bc_prop_type ), pointer :: curbcs => NULL () type ( tem_bc_prop_type ), pointer :: oldbcs => NULL () type ( tem_subTree_type ) :: refine_subtree type ( tem_subTree_type ) :: tracked_subtree procedure ( ply_split_element ), pointer :: split_element procedure ( ply_filter_element ), pointer :: filtering procedure ( tem_varSys_proc_element ), pointer :: get_element procedure ( tem_varSys_proc_point ), pointer :: get_point procedure ( tem_varSys_proc_setParams ), pointer :: set_params procedure ( tem_varSys_proc_getParams ), pointer :: get_params procedure ( tem_varSys_proc_setupIndices ), pointer :: setup_indices procedure ( tem_varSys_proc_getValOfIndex ), pointer :: get_valOfIndex ! -------------------------------------------------------------------- ! nMaxModes = maxval ( var_degree + 1 ) nChildren = 2 ** nDims nullify ( split_element ) nullify ( filtering ) select case ( nDims ) case ( 1 ) split_element => ply_split_element_1D filtering => me % filter_element % filter1D case ( 2 ) split_element => ply_split_element_2D filtering => me % filter_element % filter2D case ( 3 ) split_element => ply_split_element_3D filtering => me % filter_element % filter3D end select call ply_split_element_init ( nMaxModes ) call ply_sampling_varsys_for_track ( varsys = varsys , & & trackInst = trackInst , & & mesh = orig_mesh , & & nDims = nDims , & & lvl_degree = lvl_degree , & & sample_varsys = resvars , & & var = var , & & time = time ) ! Create a mesh describing the original selection of elements to sample. ! We use two pointers to hold the current and the previous mesh information: ! curmesh, curbcs and oldmesh, oldbcs respectively allocate ( curmesh ) allocate ( curbcs ) call tem_create_tree_from_sub ( intree = orig_mesh , & & subtree = trackInst % subtree , & & newtree = curmesh , & & keep_props = . true . ) bcpos = tem_bc_prop_pos ( orig_mesh ) nScalars = size ( var ) nElems = curmesh % nElems allocate ( maxdeg ( nScalars )) allocate ( reduction_factor ( nScalars )) allocate ( origsize ( nScalars )) allocate ( reducableelems ( nScalars )) allocate ( maxmean ( nScalars )) allocate ( minmean ( nScalars )) do iScalar = 1 , nScalars origsize ( iScalar ) = size ( var ( iScalar )% dat ) maxmean ( iScalar ) = maxval ( var ( iScalar )% dat ( var ( iScalar )% first (: nElems ))) end do ! If the maximal mean of the variable across all elements is too close to ! 0, lift it to ensure some safeguard. maxmean = max ( maxmean , 256 * epsilon ( maxmean ( 1 )) ) minmean = maxmean * me % eps_osci if ( bcpos > 0 ) then ! Take care of the boundary properties if ( trackInst % subtree % useGlobalMesh ) then ! For global meshes we can just reuse the original boundary property. curbcs = orig_bcs curbcs % header => curmesh % global % property ( bcpos ) curbcs % property => curmesh % property ( bcpos ) else ! Otherwise we need to create a new boundary property with just the ! elements of the subtree. call tem_bc_prop_sublist ( tree = orig_mesh , & & bc = orig_bcs , & & header = orig_mesh % global % property ( bcpos ), & & property = orig_mesh % property ( bcpos ), & & sublist = trackInst % subtree % map2global , & & sub_bc = curbcs ) end if end if ! All preparations done, we now have an array holding the original ! polynomial data for all requested variables and an accompanying mesh ! with the boundary properties. ! We now can go on and do the actual refinement: refining : do iRefLevel = 1 , me % max_nlevels lastrefine = ( iRefLevel == me % max_nLevels ) newElems = 0 do iScalar = 1 , nScalars call ply_sampling_var_compute_elemdev ( var = var ( iScalar ), & & threshold = me % eps_osci , & & min_mean = minmean ( iScalar ) ) end do if ( allocated ( reached_limit )) deallocate ( reached_limit ) allocate ( reached_limit ( curmesh % nElems )) if ( allocated ( is_varying )) deallocate ( is_varying ) allocate ( is_varying ( curmesh % nElems )) refinedElems = 0 write ( logunit ( 5 ), * ) 'Adaptive sampling refinement ' , iRefLevel write ( logunit ( 5 ), * ) '        Parent local mesh has ' , curmesh % nelems , & & ' elements.' ! The decision whether an element needs to be refined or not depends ! on all variable components. Thus, this needs to be checked once ! beforehand. ! For each element we also determine whether this will be the last ! refinement, as in this case the data will be reduced to a single dof ! later on independent of the variation of the data. do iElem = 1 , curmesh % nElems elemlevel = tem_levelOf ( curmesh % treeID ( iElem )) reached_limit ( iElem ) = lastrefine & & . or . ( ( me % AbsUpperBoundLevel > 0 ) & & . and . ( elemlevel >= me % AbsUpperBoundLevel - 1 ) ) ! Now get the spectral variation (sum of absolute values of all ! higher modes). is_varying ( iElem ) = . false . ! Only consider refining, if absupperboundlevel is not reached. if ( ( elemlevel < me % AbsUpperBoundLevel ) & & . or . ( me % AbsUpperBoundLevel == 0 ) ) then do iScalar = 1 , nScalars is_varying ( iElem ) = is_varying ( iElem ) & & . or . var ( iScalar )% deviates ( iElem ) end do end if if ( is_varying ( iElem ) ) then ! At least one of the variables in the data has a variation above ! the threshold and we need to refine this element. newElems = newElems + nChildren refinedElems = refinedElems + 1 else ! No or only small variations in all variables, no need to ! refine, just keep the element with the first degree of freedom ! only. newElems = newElems + 1 end if end do write ( logunit ( 5 ), * ) '        The new mesh will have ' , newelems , & & ' elements.' flush ( logunit ( 5 )) need2refine = ( newElems > curmesh % nElems ) call MPI_Allreduce ( MPI_IN_PLACE , & !sendbuf & need2refine , & !recvbuf & 1 , & !count & MPI_LOGICAL , & !datatype & MPI_LOR , & !op & curmesh % global % comm , & !comm & iError ) !ierror if ( need2refine ) then write ( logunit ( 5 ), * ) '        Need to do a refinement!' ! Mesh needs to be refined, and we need to create a new one. if ( allocated ( map2global )) deallocate ( map2global ) allocate ( map2global ( refinedElems )) iRefElem = 0 do iElem = 1 , curmesh % nElems if ( is_varying ( iElem )) then iRefElem = iRefElem + 1 map2global ( iRefElem ) = iElem end if end do call tem_subtree_from ( me = refine_subtree , & & map2global = map2global , & & comm = curmesh % global % comm ) if ( associated ( oldmesh )) then deallocate ( oldmesh % global % property ) deallocate ( oldmesh % property ) deallocate ( oldmesh ) end if oldmesh => curmesh nullify ( curmesh ) if ( associated ( oldbcs )) deallocate ( oldbcs ) oldbcs => curbcs nullify ( curbcs ) allocate ( curmesh ) allocate ( curbcs ) call tem_refine_global_subtree ( orig_mesh = oldmesh , & & orig_bcs = oldbcs , & & subtree = refine_subtree , & & ndims = ndims , & & new_mesh = curmesh , & & new_bcs = curbcs , & & restrict_to_sub = . false . ) call tem_destroy_subtree ( refine_subtree ) end if ! Apply the same reduction factor for all variables. ! With adaptive dof reduction this might be changed below. reduction_factor = me % dofReducFactor do iScalar = 1 , nScalars maxdeg ( iScalar ) = maxval ( var ( iScalar )% degree ) ReducableElems ( iScalar ) = var ( iScalar )% nDeviating * nChildren end do if ( me % reduction_mode == redux_factor & & . and . me % adaptiveDofReduction & & . and . need2refine ) then ! If adaptive reduction is active, we may increase the factor and ! keep more dofs after the refinement for improved accuracy without ! increased memory. This is computed individually for each variable ! as they all live in separate arrays. ! We only need to compute this factor, if there are actually elements ! to refine, otherwise the target polynomial will always have a degree ! of 0. do iScalar = 1 , nScalars ! The maximal amount of memory required will be: ! `totaldofs = newelems + reducableElems*((r*(maxdeg+1))**nDims - 1)` ! Where `r` is the dof reduction factor. Solving for this factor we ! get: if ( ( newelems <= origsize ( iScalar )) & & . and . ( reducableElems ( iScalar ) > 0 ) ) then memprefac = ( real ( 1 + origsize ( iScalar ) - newelems , kind = rk ) & & / ReducableElems ( iScalar ) ) ** ( 1.0_rk / nDims ) & & / real ( maxdeg ( iScalar ) + 1 , kind = rk ) ! Do not increase the number of dofs, even if memory would allow it. ! (limit factor to 1). memprefac = min ( memprefac , 1.0_rk ) else ! Even a single degree of freedom per element exceeds the original ! memory. We can not increase the factor and maintain more degrees ! of freedom without increasing the memory demand, thus we stick to ! the configured reduction factor. memprefac = reduction_factor ( iScalar ) end if ! Reduction factor has to be at least as large as given by the user, ! but if possible we'll use a larger factor and preserve more modes ! after the refinement. reduction_factor ( iScalar ) = max ( memprefac , & & reduction_factor ( iScalar ) ) end do end if ! Move data of previous iteration to maintain variable names ! (var is moved to prev and the old content of prev is discarded) call ply_sampling_var_move ( source = var , & & destination = prev ) allocate ( var ( nScalars )) variables : do iScalar = 1 , nScalars ! The following code was moved in front of the condition to silence a ! compiler warning about a potentially uninitialized maxtarget variable. ! ! No refinement to be done, just a single degree of freedom per ! element needed. maxtarget = 1 containersize = newelems ! Allocate an array of sufficient size for the refined data. if ( need2refine ) then select case ( me % reduction_mode ) case ( redux_factor ) maxtarget = ceiling ( reduction_factor ( iScalar ) & & * ( maxdeg ( iScalar ) + 1 ) ) case ( redux_decrement ) maxtarget = max ( maxdeg ( iScalar ) - me % dof_decrement + 1 , 1 ) end select containersize = newelems & & + reducableElems ( iScalar ) * ( maxtarget ** nDims - 1 ) end if call ply_sampling_var_allocate ( var = var ( iScalar ), & & nElems = newElems , & & datalen = containersize ) iNewElem = 1 var ( iScalar )% first ( 1 ) = 1 if (. not . need2refine ) then ! No need to refine the mesh, just copy the first degree of freedom ! in each element and skip to next variable. do iElem = 1 , curmesh % nElems firstdof = var ( iScalar )% first ( iNewElem ) oldfirst = prev ( iScalar )% first ( iElem ) var ( iScalar )% first ( iNewElem + 1 ) = firstdof + 1 var ( iScalar )% dat ( firstdof ) = prev ( iScalar )% dat ( oldfirst ) iNewElem = iNewElem + 1 end do CYCLE variables end if ! Iterate over the elements of the old mesh to refine each one as ! needed. do iElem = 1 , oldmesh % nElems oldfirst = prev ( iScalar )% first ( iElem ) firstdof = var ( iScalar )% first ( iNewElem ) varelem : if ( is_varying ( iElem ) ) then ! There is at least one variable that varies in this element, ! need to create all child elements. if ( prev ( iScalar )% deviates ( iElem )) then ! The data of this scalar varies, we need to project it to the ! child elements. if ( reached_limit ( iElem )) then ! If we reached the limit for refinements, we only keep one ! degree of freedom. targetdeg = 0 else select case ( me % reduction_mode ) case ( redux_factor ) targetdeg = ceiling ( reduction_factor ( iScalar ) & & * ( prev ( iScalar )% degree ( iElem ) + 1 ) ) - 1 case ( redux_decrement ) targetdeg = prev ( iScalar )% degree ( iElem ) - me % dof_decrement end select targetdeg = max ( targetdeg , 0 ) end if oldlast = prev ( iScalar )% first ( iElem + 1 ) - 1 lastdof = var ( iScalar )% first ( iNewElem ) & & - 1 + nChildren & & * ( targetdeg + 1 ) ** nDims ndofs = ( targetdeg + 1 ) ** ndims nOlddofs = oldlast - oldfirst + 1 parent_data ( 1 : nOlddofs , 1 : 1 ) & & => prev ( iScalar )% dat ( oldfirst : oldlast ) child_data ( 1 : ndofs , 1 : nChildren ) & & => var ( iScalar )% dat ( firstdof : lastdof ) if ( associated ( filtering )) then call filtering ( & & me = me % filter_element , & & element_degree = prev ( iScalar )% degree ( iElem ), & & element_data = parent_data ) end if call split_element ( parent_degree = prev ( iScalar ) & & % degree ( iElem ), & & child_degree = targetdeg , & & ignore_highmodes = me % ignore_highmodes , & & parent_data = parent_data , & & child_data = child_data ) else ! This scalar does not vary more than the threshold, just keep ! the first degree of freedom. ndofs = 1 targetdeg = 0 lastdof = firstdof + nChildren - 1 var ( iScalar )% dat ( firstdof : lastdof ) = prev ( iScalar )% dat ( oldfirst ) end if do iChild = 1 , nChildren ! todo: Filter modes ! if (filter_tolerance > 0 .and. targetdeg > 1) then !   ! only filter highest modes if there is a tolerance and there !   ! is more than one mode to filter. !   sum abs of modes from last backwards until filter tolerance !   is reached and cut off modes above that. ! end if var ( iScalar )% degree ( iNewElem ) = targetdeg var ( iScalar )% first ( iNewElem + 1 ) = firstdof + iChild * ndofs iNewElem = iNewElem + 1 end do else varelem ! No variation in this element, keep it with a single degree of ! freedom. var ( iScalar )% degree ( iNewElem ) = 0 var ( iScalar )% dat ( firstdof ) = prev ( iScalar )% dat ( oldfirst ) var ( iScalar )% first ( iNewElem + 1 ) = firstdof + 1 iNewElem = iNewElem + 1 end if varelem end do end do variables if ( need2refine ) then if (. not . trackInst % subtree % useGlobalMesh ) then ! Mesh was refined, but we do not track the complete mesh, restrict ! data to the tracked elements again. call tem_create_subTree_of ( inTree = curmesh , & & bc_prop = curbcs , & & subtree = tracked_subtree , & & inShape = trackConfig % geometry ) ! Move data of unrestricted mesh to store the restricted data in var. call ply_sampling_var_move ( source = var , & & destination = prev ) allocate ( var ( nScalars )) newelems = tracked_subtree % nElems do iScalar = 1 , nScalars containersize = sum ( ( prev ( iScalar ) & & % degree ( tracked_subtree & & % map2global ) + 1 ) ** nDims ) call ply_sampling_var_allocate ( var = var ( iScalar ), & & nElems = newElems , & & datalen = containersize ) var ( iScalar )% first ( 1 ) = 1 do iNewElem = 1 , newelems iElem = tracked_subtree % map2global ( iNewElem ) var ( iScalar )% degree ( iNewElem ) = prev ( iScalar )% degree ( iElem ) var ( iScalar )% first ( iNewElem + 1 ) & & = var ( iScalar )% first ( iNewElem ) & & + ( prev ( iScalar )% degree ( iElem ) + 1 ) ** nDims firstdof = var ( iScalar )% first ( iNewElem ) lastdof = var ( iScalar )% first ( iNewElem + 1 ) - 1 oldfirst = prev ( iScalar )% first ( iElem ) oldlast = prev ( iScalar )% first ( iElem + 1 ) - 1 var ( iScalar )% dat ( firstdof : lastdof ) & & = prev ( iScalar )% dat ( oldfirst : oldlast ) end do end do if ( associated ( oldmesh )) then deallocate ( oldmesh % global % property ) deallocate ( oldmesh % property ) deallocate ( oldmesh ) end if oldmesh => curmesh nullify ( curmesh ) if ( associated ( oldbcs )) deallocate ( oldbcs ) oldbcs => curbcs nullify ( curbcs ) allocate ( curmesh ) allocate ( curbcs ) call tem_create_tree_from_sub ( intree = oldmesh , & & subtree = tracked_subtree , & & newtree = curmesh ) end if else ! Nothing to refine anymore, leave the loop. EXIT refining end if end do refining ! Now the refined data is stored in var%dat, and there is only one degree ! of freedom left for each element. ! The final mesh is stored in curmesh. ! Discard old data to free memory. if ( associated ( oldmesh )) then deallocate ( oldmesh % global % property ) deallocate ( oldmesh % property ) deallocate ( oldmesh ) end if if ( associated ( oldbcs )) deallocate ( oldbcs ) call ply_sampling_var_move ( source = var , & & destination = prev ) get_element => get_sampled_element get_params => tem_varSys_getparams_dummy set_params => tem_varSys_setparams_dummy nullify ( get_point ) nullify ( setup_indices ) nullify ( get_valOfIndex ) ! Finally link the data into a structure that is suitable for the method ! data of each variable nVars = trackInst % varmap % varPos % nVals iScalar = 0 do iVar = 1 , nVars varpos = trackInst % varmap % varpos % val ( iVar ) nComponents = varsys % method % val ( varpos )% nComponents allocate ( vardat ) allocate ( vardat % component ( nComponents )) do iComponent = 1 , nComponents iScalar = iScalar + 1 vardat % component ( iComponent )% dat => prev ( iScalar )% dat end do call tem_varSys_append_stateVar ( & & me = resvars , & & varname = varsys % varname % val ( varpos ), & & nComponents = nComponents , & & method_data = c_loc ( vardat ), & & set_params = set_params , & & get_point = get_point , & & get_element = get_element , & & get_params = get_params , & & setup_indices = setup_indices , & & get_valofindex = get_valofindex ) nullify ( vardat ) end do do iScalar = 1 , nScalars nullify ( prev ( iScalar )% dat ) deallocate ( prev ( iScalar )% degree ) deallocate ( prev ( iScalar )% first ) end do deallocate ( prev ) new_mesh = curmesh end subroutine ply_sample_adaptive ! ------------------------------------------------------------------------- ! ! ------------------------------------------------------------------------- ! ! ------------------------------------------------------------------------- ! !> Get sampled data. !! !! This routine provides the get_element function of the variable definition !! to access the sampled data array obtained by ply_sample_data. subroutine get_sampled_element ( fun , varsys , elempos , time , tree , n , & & nDofs , res ) ! -------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> TreeID of the element to get the variable for. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of elements to obtain for this variable (vectorized access). integer , intent ( in ) :: n !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (nComponents of resulting variable) x (nDegrees of freedom) x (nElems) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! -------------------------------------------------------------------- ! type ( sampled_method_data_type ), pointer :: p integer :: iElem integer :: iComp integer :: nComps ! -------------------------------------------------------------------- ! nComps = fun % nComponents call c_f_pointer ( fun % method_data , p ) do iComp = 1 , nComps do iElem = 1 , n res ( iComp + ( iElem - 1 ) * nComps ) & & = p % component ( iComp )% dat ( elempos ( iElem )) end do end do end subroutine get_sampled_element ! ------------------------------------------------------------------------- ! ! ------------------------------------------------------------------------- ! end module ply_sampling_adaptive_module","tags":"","url":"sourcefile/ply_sampling_adaptive_module.f90.html"},{"title":"sdr_canonicalND_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_canonicalnd_module.f90~~AfferentGraph sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2017, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2013 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2013 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> This module provides the routine to load canonical geometrical objects !! to growing array of geometries and their positions in growing array in !! growing array of spatialObj module sdr_canonicalND_module use env_module , only : rk , labelLen use tem_canonicalND_module , only : tem_canonicalND_type , & & tem_load_canonicalND use tem_tools_module , only : upper_to_lower use tem_transformation_module , only : tem_transformation_type use tem_point_module , only : tem_point_type , & & grw_pointArray_type , append use tem_line_module , only : tem_line_type , & & grw_lineArray_type , append use tem_triangle_module , only : tem_triangle_type , & & grw_triangleArray_type , append use tem_box_module , only : tem_box_type , grw_boxArray_type , & & init , append use tem_plane_module , only : tem_plane_type use sdr_spatialObj_module , only : grw_spatialObjArray_type , & & sdr_spatialObj_type , & & point , line , triangle , box , & & append use flu_binding , only : flu_State use aotus_module , only : flu_State , aot_get_val , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length implicit none public :: sdr_load_canonicalND contains ! ***************************************************************************** !> This routine loads canonical geometrial objects like point, line, plane !! and box and add them to the growing array of each primitive geometries !! and the position of this geometries are stored in the growing array !! of spatialObject subroutine sdr_load_canonicalND ( pntArray , lineArray , triArray , boxArray , & & spaObjArray , attr_pos , transform , & & conf , thandle ) ! --------------------------------------------------------------------------! !> growing array of points type ( grw_pointArray_type ), intent ( inout ) :: pntArray !> growing array of line type ( grw_lineArray_type ), intent ( inout ) :: lineArray !> growing array of triangles type ( grw_triangleArray_type ), intent ( inout ) :: triArray !> growing array of boxes type ( grw_boxArray_type ), intent ( inout ) :: boxArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> Position of the attribute to connect this object to. integer , intent ( in ) :: attr_pos !> transformation for spatial object type ( tem_transformation_type ), intent ( in ) :: transform !> lua state type ( flu_state ) :: conf integer , intent ( in ) :: thandle !< handle for canonical objects ! --------------------------------------------------------------------------! integer :: iCano type ( tem_canonicalND_type ), allocatable :: canoND (:) ! --------------------------------------------------------------------------! ! Load canonical object definition call tem_load_canonicalND ( canoND , transform , conf , thandle ) do iCano = 1 , size ( canoND ) select case ( upper_to_lower ( trim ( canoND ( iCano )% kind ))) case ( 'point' ) call append_CanoNDPointToSdrPoint ( canopoint = canoND ( iCano )% point , & & pntArray = pntArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) case ( 'line' ) call append_CanoNDLineToSdrLine ( canoline = canoND ( iCano )% line , & & lineArray = lineArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) case ( 'plane' ) call append_CanoNDPlaneToTriangle ( plane = canoND ( iCano )% plane , & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) case ( 'box' ) if ( canoND ( iCano )% only_surface ) then !hollow box call append_CanoNDBoxToTriangle ( canobox = canoND ( iCano )% box , & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) else !solid box call append_CanoNDBoxToSdrBox ( canobox = canoND ( iCano )% box , & & boxArray = boxArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) endif end select end do end subroutine sdr_load_canonicalND ! ***************************************************************************** ! ***************************************************************************** !> This routine convert canonical point to seeder point array subroutine append_CanoNDPointToSdrPoint ( canopoint , pntArray , spaObjArray , & & attr_pos ) ! --------------------------------------------------------------------------! !> canonical point object type type ( tem_point_type ), intent ( in ) :: canopoint !> growing array of points type ( grw_pointArray_type ), intent ( inout ) :: pntArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> spatial object type integer , intent ( in ) :: attr_pos ! --------------------------------------------------------------------------! !local variables type ( sdr_spatialObj_type ) :: spatialObj ! --------------------------------------------------------------------------! spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = point !append point to point list call append ( pntArray , canopoint ) spatialObj % primitive_position = pntArray % nVals !add spatialObj to spatialObj list call append ( spaObjArray , spatialObj ) end subroutine append_CanoNDPointToSdrPoint ! ***************************************************************************** ! ***************************************************************************** !> This routine convert canonical line to seeder line array subroutine append_CanoNDLineToSdrLine ( canoline , lineArray , spaObjArray , & & attr_pos ) ! --------------------------------------------------------------------------! !> canonical geometry line object type type ( tem_line_type ), intent ( in ) :: canoline !> growing array of line type ( grw_lineArray_type ), intent ( inout ) :: lineArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> spatial object type integer , intent ( in ) :: attr_pos ! --------------------------------------------------------------------------! !local variables type ( sdr_spatialObj_type ) :: spatialObj ! --------------------------------------------------------------------------! spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = line !append point to point list call append ( lineArray , canoline ) spatialObj % primitive_position = lineArray % nVals !add spatialObj to spatialObj list call append ( spaObjArray , spatialObj ) end subroutine append_CanoNDLineToSdrLine ! ***************************************************************************** ! ***************************************************************************** !> This routine convert box to planes and then planes to triangles !! and add triangle to growing array and add position of triangle into !! spatialObj%primitive_position subroutine append_CanoNDBoxToTriangle ( canoBox , triArray , spaObjArray , & & attr_pos ) ! --------------------------------------------------------------------------! !> canonical geometry box object type type ( tem_box_type ), intent ( in ) :: canoBox !> growing array of triangles type ( grw_triangleArray_type ), intent ( inout ) :: triArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> spatial object type integer , intent ( in ) :: attr_pos ! --------------------------------------------------------------------------! !local variables ! --------------------------------------------------------------------------! !plane 1 call append_CanoNDPlaneToTriangle ( plane = canoBox % plane ( 1 ), & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) !plane 2 call append_CanoNDPlaneToTriangle ( plane = canoBox % plane ( 2 ), & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) !plane 3 call append_CanoNDPlaneToTriangle ( plane = canoBox % plane ( 3 ), & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) !plane 4 call append_CanoNDPlaneToTriangle ( plane = canoBox % plane ( 4 ), & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) !plane 5 call append_CanoNDPlaneToTriangle ( plane = canoBox % plane ( 5 ), & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) !plane 6 call append_CanoNDPlaneToTriangle ( plane = canoBox % plane ( 6 ), & & triArray = triArray , & & spaObjArray = spaObjArray , & & attr_pos = attr_pos ) end subroutine append_canoNDBoxToTriangle ! ***************************************************************************** ! ***************************************************************************** !> This routine convert plane to triangle and add triangle to !! growing array and add position of triangle into !! spatialObj%primitive_position subroutine append_CanoNDPlaneToTriangle ( plane , triArray , spaObjArray , & & attr_pos ) ! --------------------------------------------------------------------------! !> canonical plane geometry object type type ( tem_plane_type ), intent ( in ) :: plane !> growing array of triangles type ( grw_triangleArray_type ), intent ( inout ) :: triArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> spatial object type integer , intent ( in ) :: attr_pos ! --------------------------------------------------------------------------! !local variables type ( sdr_spatialObj_type ) :: spatialObj integer :: iTri ! --------------------------------------------------------------------------! spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = triangle !loop over triangles do iTri = 1 , 2 ! two triangles per plane !append triangle into triangle list call append ( triArray , plane % triangle ( iTri ) ) spatialObj % primitive_position = triArray % nVals !add spatialObj to spatialObj list call append ( spaObjArray , spatialObj ) end do end subroutine append_canoNDPlaneToTriangle ! ***************************************************************************** ! ***************************************************************************** !> This routine convert plane to triangle and add triangle to !! growing array and add position of triangle into !! spatialObj%primitive_position subroutine append_CanoNDBoxToSdrBox ( canobox , boxArray , spaObjArray , & & attr_pos ) ! --------------------------------------------------------------------------! !> canonical geometry object type type ( tem_box_type ), intent ( in ) :: canobox !> growing array of boxes type ( grw_boxArray_type ), intent ( inout ) :: boxArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> spatial object type integer , intent ( in ) :: attr_pos ! --------------------------------------------------------------------------! !local variables type ( sdr_spatialObj_type ) :: spatialObj ! --------------------------------------------------------------------------! spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = box call append ( boxArray , canobox ) spatialObj % primitive_position = boxArray % nVals ! Add spatialObj to spatialObj list. call append ( spaObjArray , spatialObj ) end subroutine append_canoNDBoxToSdrBox ! ***************************************************************************** end module sdr_canonicalND_module","tags":"","url":"sourcefile/sdr_canonicalnd_module.f90.html"},{"title":"sdr_config_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_config_module.f90~~EfferentGraph sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_config_module.f90~~AfferentGraph sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2014, 2016 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012, 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** !> This module provides the configuration of the mesh generation. module sdr_config_module use flu_binding , only : flu_State , flu_next use aotus_module , only : aot_get_val , open_config_file , close_config , & & flu_State , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length , aot_table_top , & & aot_table_first use env_module , only : PathLen , labelLen use tem_general_module , only : tem_general_type , tem_load_general use tem_logging_module , only : logunit , tem_logging_load_primary use tem_aux_module , only : tem_abort use tem_tools_module , only : upper_to_lower use tem_comm_module , only : tem_commpattern_type use tem_dyn_array_module , only : dyn_labelArray_type , init , append , & & PositionOfVal use tem_debug_module , only : tem_debug_load_main use sdr_geometry_module , only : sdr_geometry_type , sdr_load_geometry use sdr_attribute_module , only : sdr_seed_object use sdr_subresolution_module , only : sdr_subresolution_type , & & sdr_subresolution_load , & & sdr_subresolution_encolor use sdr_timer_module , only : timer_handle_loadconfig use tem_timer_module , only : tem_startTimer , tem_stopTimer implicit none private public :: sdr_load_config public :: sdr_confHead_type !> This type contains basic information loaded from the config file. type sdr_confHead_type character ( len = PathLen ) :: comment !< Comment line in the file character ( len = PathLen ) :: folder !< folder where to save the mesh integer :: minlevel !< minumum refinement level of the fluid tree type ( tem_general_type ) :: general !> Information on resolution of boundaries within elements using !! polynomials. type ( sdr_subresolution_type ) :: subresolution !> List of colors to invert. !! !! Colors that are listed here, will get their definition inverted, such !! that filled areas are turned void and void areas will get filled if !! they are flooded by the none color. Inverting the none color is not !! possible. type ( dyn_labelArray_type ) :: inverted_colors end type sdr_confHead_type contains ! ***************************************************************************** !> Load the configuration from the Lua script provided on the command line !! or from seeder.lua by default, if no file name is given as program !! argument. !! !! The configuration needs to describe some general properties, like the !! directory where the resulting mesh is to be stored and the geometries, !! that are to be used to define the mesh. subroutine sdr_load_config ( me , geometry ) ! --------------------------------------------------------------------------! !> contains basic information from config file !  @todo: me was filled before so intent has to be inout type ( sdr_confHead_type ), intent ( inout ) :: me !> contains all geometry object defined in the config file type ( sdr_geometry_type ), intent ( out ) :: geometry ! --------------------------------------------------------------------------! ! local variables character ( len = 1024 ) :: filename type ( flu_State ) :: conf integer :: iError ! --------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_loadconfig ) filename = '' ! Get filename from command argument call get_command_argument ( 1 , filename ) if ( trim ( filename ) == '' ) then ! Default to seeder.lua, if no filename is provided on the command line. filename = 'seeder.lua' end if ! Attempt to open the given file as a Lua script. Store a handle to that ! script in conf. call open_config_file ( L = conf , filename = trim ( filename )) ! load and initialize logUnit call tem_logging_load_primary ( conf = conf , & & rank = me % general % proc % rank ) ! load and initialize debug unit call tem_debug_load_main ( conf = conf , & & rank = me % general % proc % rank ) call tem_load_general ( me = me % general , conf = conf ) call aot_get_val ( L = conf , key = 'comment' , & & val = me % comment , ErrCode = iError , default = '' ) write ( logunit ( 3 ), * ) 'Comment in the file: ' // trim ( me % comment ) ! Get the directory, where the resulting mesh is to be stored in. call aot_get_val ( L = conf , key = 'folder' , & & val = me % folder , ErrCode = iError , default = 'mesh_' ) if ( btest ( iError , aoterr_WrongType )) then write ( logunit ( 0 ), * ) \"ERROR: 'folder' to load mesh has wrong type!\" call tem_abort () endif ! Load the minimum refinement level for the mesh call aot_get_val ( L = conf , key = 'minlevel' , & & val = me % minlevel , ErrCode = iError , default = 0 ) if ( btest ( iError , aoterr_WrongType )) then write ( logunit ( 0 ), * ) \"ERROR: minLevel has wrong type!\" call tem_abort () endif write ( logunit ( 1 ), * ) 'Mesh folder: ' // trim ( me % folder ) write ( logunit ( 2 ), * ) 'minlevel: ' , me % minlevel call sdr_subresolution_load ( subres = me % subresolution , & & conf = conf ) call sdr_load_inverted ( me % inverted_colors , conf ) ! Load geometry object from config file. call sdr_load_geometry ( me = geometry , & & subres_colors = me % subresolution % default_colors , & & invert_colors = me % inverted_colors , & & conf = conf ) ! Close the configuration script again. call close_config ( conf ) ! Now go through all colors, and ensure, that there is a definition of ! values for each. If there is no definition given by the user, we default ! to a filling value of 1 and a void value of 0. write ( logunit ( 5 ), * ) 'Getting encoloring values for all colors' call sdr_subresolution_encolor ( me = me % subresolution , & & colors = geometry & & % attribute & & % uni_name ( sdr_seed_object ) ) write ( logunit ( 5 ), * ) 'Done in sdr_load_config' call tem_stopTimer ( timerHandle = timer_handle_loadconfig ) end subroutine sdr_load_config subroutine sdr_load_inverted ( invlist , conf ) !> List of labels for inverted colors. type ( dyn_labelArray_type ), intent ( out ) :: invlist !> Lua script handle to read the inversion list from. type ( flu_State ) :: conf character ( labelLen ) :: cLabel integer :: thandle integer :: nInverted integer :: iInv integer :: pos integer :: iError logical :: wasAdded call aot_table_open ( L = conf , thandle = thandle , & & key = 'inverted_colors' ) if ( thandle > 0 ) then nInverted = aot_table_length ( L = conf , thandle = thandle ) call init ( invlist , length = nInverted ) do iInv = 1 , nInverted call aot_get_val ( L = conf , & & thandle = thandle , & & pos = iInv , & & val = clabel , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logunit ( 0 ), * ) & & 'FATAL Error occured while retrieving color name in the' & & // ' inversion table!' call tem_abort () end if call append ( invlist , upper_to_lower ( trim ( clabel )), & & pos = pos , wasAdded = wasAdded ) end do end if call aot_table_close ( L = conf , thandle = thandle ) end subroutine sdr_load_inverted end module sdr_config_module","tags":"","url":"sourcefile/sdr_config_module.f90.html"},{"title":"sdr_boundary_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_boundary_module.f90~~EfferentGraph sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_boundary_module.f90~~AfferentGraph sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2015, 2017, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012, 2014 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013-2014, 2023 Harald Klimach <harald.klimach@dlr.de> ! Copyright (c) 2014 Matthias Johannink ! Copyright (c) 2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2017 Raphael Haupt <Raphael.Haupt@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> author: Kannan Masilamani !! author: Jiaxing !! This module contains routines for boundary identification !! and qVal computation !! !!@todo HK: This module is utterly confusing, I do not really understand what !!          all this code is actually doing, and it is hard to parse it. !!          The module needs to be redesigned and cleaned up! module sdr_boundary_module use env_module , only : long_k , rk , newunit , isLittleEndian , & & globalMaxLevels use treelmesh_module , only : treelmesh_type use tem_param_module , only : qQQQ , qOffset , qInvDir use tem_mergesort_module , only : mrgrnk use tem_topology_module , only : tem_directChildren , tem_firstIDatLevel , & & tem_CoordOfId , tem_IdOfCoord , & & tem_parentOf , tem_LevelOf use tem_geometry_module , only : tem_eligibleChildren , tem_BaryOfCoord , & & tem_CoordOfReal , tem_BaryOfID , & & tem_ElemSize , tem_vrtxCoordOfId use tem_line_module , only : tem_line_type , intersect_RayTriangle , & & fraction_PointLine use tem_plane_module , only : tem_plane_type use tem_cube_module , only : tem_cube_type , tem_convertTreeIDtoCube use tem_point_module , only : tem_point_type , tem_pointCubeOverlap use tem_triangle_module , only : tem_triangle_close_face , & & tem_triangle_normal_proximity use tem_dyn_array_module , only : PositionOfVal use tem_grow_array_module , only : grw_realArray_type , init , append , destroy use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_debug_module , only : dbgUnit use sdr_prototree_module , only : sdr_protoTree_type , levelValues_type , & & sdr_neighbor_in_proto use sdr_geometry_module , only : sdr_geometry_type use sdr_periodic_module , only : sdr_periodicPlane_type use sdr_node_module , only : sdr_node_type , isFlooded_bit , isLeaf_bit , & & isTarget_bit , IntersectsBoundary_bit , & & isFluidifyable_bit , sdr_nodeProp_btest use sdr_spatialObj_module , only : periodicPlane , triangle use sdr_attribute_module , only : sdr_attrList_type , sdr_Boundary_object implicit none private public :: sdr_identify_boundary public :: needCalcQValByBCID public :: needFldDglByBCID public :: sdr_qValByNode public :: sdr_find_periodic_neighbor !> default qVal when no intersection real ( kind = rk ), parameter , public :: sdr_qVal_no_intersection = - 1._rk contains ! ************************************************************************** ! !> This routine checks for boundary neighbors and level of the boundary !! node !! !! Note, this can not easily be used for target nodes with subelement !! resolution, as it assumes q-Values if the node is intersected by a !! boundary. subroutine sdr_identify_boundary ( node_pos , treeID , coord , leVal , proto , & & geometry , BC_ID , qVal , bc_normal , & & meshUniverse ) ! ---------------------------------------------------------------------- ! !> Position of leaf in the preliminary tree !@todo: the position of what node? integer , intent ( in ) :: node_pos !> treeID of parent node integer ( kind = long_k ), intent ( in ) :: treeID !> Coordinate of treeID integer , intent ( in ) :: coord ( 4 ) !> level value of parent node type ( levelValues_type ), intent ( in ) :: leVal !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> Boundary ID for all 26 neighbor directions integer ( kind = long_k ), intent ( out ) :: BC_ID ( qQQQ ) !> distance from boundary for all 26 neighbor directions real ( kind = rk ), intent ( out ) :: qVal ( qQQQ ) !> Wall normal pointing from the surface to the barycenter of the !! boundary element real ( kind = rk ), intent ( out ) :: bc_normal ( 3 ) !> contains bounding cube information type ( treelmesh_type ), intent ( in ) :: meshUniverse ! ---------------------------------------------------------------------- ! integer :: iDir , neighbor_pos integer :: neighbor_level logical :: unKnownBnd ( qQQQ ) integer :: startDir integer :: unKnownNeighPos ( qQQQ ) real ( kind = rk ) :: elembary ( 3 ) real ( kind = rk ) :: neigh_normal ( 3 , qQQQ ) real ( kind = rk ) :: neigh_distsq ( qQQQ ) integer ( kind = long_k ) :: minBCID logical :: check_unKnownBnd logical :: check_neigh_normals integer :: iDir_tmp integer :: nBCs integer :: nNeigh_normals integer ( kind = long_k ) :: neigh_bcid type ( tem_cube_type ) :: neighcube type ( tem_point_type ) :: neighpoint ! --------------------------------------------------------------------------! !write(dbgUnit(1),*) 'Entering identify boundary' !To detect hanging node in non-direct boundary direction with no !boundary attached to it unKnownBnd = . false . unKnownNeighPos = - 1 ! No need to check for unknownBnd if there is level jump ! i.e. bndLevel > level check_unKnownBnd = . true . ! compute minBCID of this node and use it for unKnownBnd minBCID = huge ( minBCID ) qVal = sdr_qVal_no_intersection bc_normal = 0.0_rk ! Get barycenter of current element elemBary = tem_BaryOfID ( meshUniverse , treeID ) !write(dbgUnit(1),*) 'myID: ', treeID !write(dbgUnit(1),*) 'myBary: ', elemBary ! First check if current node is intersecting a boundary ! then qVal must be active, as nodes with subelement resolution are ! treated seperately. ! So check for intersection of ! link with the geometry intersected by this node. ! If there is no intersection then check its neighbor if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = node_pos , & & bit = intersectsBoundary_bit ) ) then if ( . not . sdr_nodeProp_btest ( node = proto % node , & & iNode = node_pos , & & bit = isFluidifyable_bit ) ) then linkloop : do iDir = 1 , qQQQ call getBCID_and_calcQval ( proto = proto , & & geometry = geometry , & & elemBary = elemBary , & & iDir = iDir , & & bndnode_pos = node_pos , & & level = leVal % level , & & leVal = leVal , & & meshUniverse = meshUniverse , & & bc_id = BC_ID ( iDir ), & & minBCID = minBCID , & & unKnownBnd = unKnownBnd ( iDir ), & & qVal = qVal ( iDir ) ) end do linkloop end if bc_normal = getNormal ( geometry , elemBary , proto % node , node_pos , & & int ( minBCID ) ) end if check_neigh_normals = ( dot_product ( bc_normal , bc_normal ) < tiny ( bc_normal ( 1 ))) if ( check_neigh_normals ) then nNeigh_normals = 0 end if ! For nodes which have a boundary neighbor do iDir = 1 , qQQQ ! Is the current element with boundaries intersected in iDir? noq : if ( qVal ( iDir ) == sdr_qVal_no_intersection ) then ! get position of neighbor in the protoTree which might me ! from different level neighbor_pos = sdr_neighbor_in_proto ( proto , coord , iDir , & & neighbor_level ) unKnownNeighPos ( iDir ) = neighbor_pos bndBit : if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = intersectsBoundary_bit ) ) then ! Neighbor is intersected by a boundary look up the actual boundary ! condition if the neighbor needs qvalue computations or is not ! flooded. ! ! Only consider neighbors that are not flooded by any color for ! boundary conditions or that require qvalues, if the neighbor is ! flooded, this is an internal boundary that probably only separates ! two different colors. ! For those we do not want to create boundary conditions unless we ! have to compute qValues and there is geometry between the current ! element and the flooded, intersected element. neigh_bcid = int ( proto % node % minBCID % val ( neighbor_pos ), kind = long_k ) if ( . not . sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = isFlooded_bit ) & & . or . needCalcQValByBCID ( geometry % attribute , int ( neigh_bcid ) ) & & ) then call getBCID_and_calcQval ( proto = proto , & & geometry = geometry , & & elemBary = elemBary , & & iDir = iDir , & & bndnode_pos = neighbor_pos , & & level = neighbor_level , & & leVal = leVal , & & meshUniverse = meshUniverse , & & bc_id = BC_ID ( iDir ), & & minBCID = minBCID , & & unKnownBnd = unKnownBnd ( iDir ), & & qVal = qVal ( iDir ) ) end if if ( check_neigh_normals ) then neigh_normal (:, nNeigh_normals + 1 ) = getNormal ( & & geometry , elemBary , proto % node , neighbor_pos , int ( minBCID ) ) neighpoint % coord = elemBary - neigh_normal (:, nNeigh_normals + 1 ) call tem_convertTreeIDtoCube ( cube = neighcube , & & tree = meshUniverse , & & treeID = proto % node & & % treeID & & % val ( neighbor_pos ) ) if ( tem_pointCubeOverlap ( neighpoint , neighcube )) then nNeigh_normals = nNeigh_normals + 1 neigh_distsq ( nNeigh_normals ) & & = dot_product ( neigh_normal (:, nNeigh_normals ), & & neigh_normal (:, nNeigh_normals ) ) end if end if else bndBit if ( . not . sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = isFlooded_bit ) ) then ! This non-flooded element does not contain a boundary condition. ! Usually this should not happen, however due to additional ! flooding of qValue elements it might be, that a neighbor is in ! the non-flooded domain. ! This might also happen if there is an element with subelement ! resolution adjacent to a non-flooded domain. ! Special treatment is needed for boundaries in this direction. unKnownBnd ( iDir ) = . true . unKnownNeighPos ( iDir ) = neighbor_pos end if end if bndBit end if noq !write(dbgUnit(5),*) 'iDir = ', iDir, '; bcID = ', bc_ID(iDir),  & !  &                 '; Q-Value = ',qVal(iDir) end do ! iDir if ( check_neigh_normals . and . ( nNeigh_normals > 0 )) then bc_normal = neigh_normal (:, minloc ( neigh_distsq (: nNeigh_normals ), 1 )) end if ! set min bcid for element with no boundary id ! set qVal = 0.5 nBCs = geometry % attribute % kindpos ( sdr_Boundary_object )% nVals checkUnknowns : if ( check_unKnownBnd . and . any ( unKnownBnd )) then do iDir = 1 , qQQQ unknownDir : if ( unKnownBnd ( iDir )) then bc_id ( iDir ) = minBCID write ( logUnit ( 3 ), * ) iDir , 'minBCID of unKnownBnd: ' , minBCID !          bc_id(iDir) = minval(bc_id, bc_id >0) ! need calc qVal? if ( needCalcQValByBCID ( geometry % attribute , int ( bc_id ( iDir )) )) & & qVal ( iDir ) = 0.5_rk if ( bc_id ( iDir ) == 0 . or . bc_id ( iDir ) > nBCs ) then write ( logunit ( 0 ), * ) 'ERROR: Unable to treat the undefined node' write ( logunit ( 0 ), * ) '       No valid boundary IDs are found' write ( logunit ( 0 ), * ) 'startDir    :' , startDir write ( logunit ( 0 ), * ) 'iDir        :' , iDir write ( logunit ( 0 ), * ) 'minBCID     :' , minBCID write ( logunit ( 0 ), * ) 'qVal        :' , qVal ( iDir ) write ( logunit ( 0 ), * ) 'treeID      :' , treeID write ( logunit ( 0 ), * ) 'neighbor_pos:' , unknownNeighPos ( iDir ) write ( logunit ( 0 ), * ) 'neigh_bary  :' , & & tem_baryOfID ( meshUniverse , & & proto % node % treeID & & % val ( unknownNeighPos ( iDir ))) write ( logunit ( 0 ), * ) 'propbit     :' , & & proto % node % PropertyBits & & % val (:, unknownNeighPos ( iDir )) write ( logUnit ( 1 ), * ) 'Other directions:' do iDir_tmp = 1 , qQQQ if ( iDir_tmp /= iDir ) then write ( logUnit ( 1 ), * ) 'iDir: ' , iDir_tmp write ( logUnit ( 1 ), * ) 'Bits:' , & & proto % node % PropertyBits & & % val (:, unknownNeighPos ( iDir_tmp )) write ( logUnit ( 1 ), * ) 'neigh_bary  :' , & & tem_baryOfID ( meshUniverse , & & proto % node % treeID & & % val ( unknownNeighPos ( & & iDir_tmp ))) end if end do call tem_abort () end if end if unknownDir end do end if checkUnknowns !write(dbgUnit(5),*) & !  &     '-----------  ROUTINE OUT: sdr_identify_boundary   -----------' end subroutine sdr_identify_boundary ! **************************************************************************** ! **************************************************************************** !> This routine gets minBCID of the given node position in the protoTree. !! If the minBcid is periodic then it bcID is set to treeID of fluid node !! on the opposite side of periodic plane. !! It also computes the qVal if calc_dist = true. If qVal = -1 then !! there is no intersection and if qVal > 1 then the geometry is intersected !! after the link distance. subroutine getBCID_and_calcQval ( proto , geometry , elemBary , iDir , & & bndnode_pos , level , leVal , meshUniverse , & & bc_id , minBCID , qVal , unKnownBnd ) ! --------------------------------------------------------------------------! !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> current element barycenter real ( kind = rk ), intent ( in ) :: elemBary ( 3 ) !> Current boundary neighbor direction integer , intent ( in ) :: iDir !> position of node treeID in the proto%node list integer , intent ( in ) :: bndnode_pos !> level of the node integer , intent ( in ) :: level !> level value of parent node type ( levelValues_type ), intent ( in ) :: leVal !> contains bounding cube information type ( treelmesh_type ), intent ( in ) :: meshUniverse !> Boundary ID for direction iDir integer ( kind = long_k ), intent ( out ) :: BC_ID !> minimum boundary id of current node before truncation integer ( kind = long_k ), intent ( inout ) :: minBCID !> distance from boundary for direction iDir real ( kind = rk ), intent ( out ) :: qVal !> Is true if a neighbor with no property is encountered logical , intent ( inout ) :: unKnownBnd ! --------------------------------------------------------------------------! !write(dbgUnit(1),*) 'iDir ', iDir bc_id = 0_long_k qVal = sdr_qVal_no_intersection ! Get BC ID for this link BC_ID = int ( proto % node % minBCID % val ( bndnode_pos ), kind = long_k ) !!write(dbgUnit(5),*) 'min bc_id ', bc_id ! If BC_ID == -1 then it is periodic ! because periodic boundary id is set to -1 if ( bc_id == - 1_long_k ) then call sdr_find_periodic_neighbor ( elemBary = elemBary , & & iDir = iDir , & & bc_id = BC_ID , & & qVal = qVal , & & unKnownBnd = unKnownBnd , & & neighbor_pos = bndnode_pos , & & neighbor_level = level , & & leVal = leVal , & & proto = proto , & & geometry = geometry , & & meshUniverse = meshUniverse ) end if ! periodic boundary ! set minBCID before truncation ! needed to set unknown boundary ! KM: bc_id >0 - no periodic boundary if ( BC_ID > 0 ) minBCID = min ( minBCID , BC_ID ) ! JQ: calculate q-values ! in some cases, might qVal > 1 or qVal == -1.0, ! take special treatment in sdr_truncate_qVal ! KM: periodic boundary might have encountered node with qVal on ! periodic domain and it might have already computed qVal. ! So do compute qVal only if there is no_intersection if ( needCalcQValByBCID ( geometry % attribute , int ( BC_ID ) ) & & . and . qVal == sdr_qVal_no_intersection ) then call sdr_qValByNode ( proto , geometry , leVal % dx , iDir , & & elemBary , bndnode_pos , qVal ) call sdr_truncate_qVal ( proto = proto , & & qVal = qVal , & & BCID = bc_id , & & neighPos = bndnode_Pos ) endif !write(dbgUnit(5),*) 'final bc_id ', bc_id !write(dbgUnit(5),*) 'final qVal ', qVal end subroutine getBCID_and_calcQval ! **************************************************************************** ! **************************************************************************** !> This routine find the treeID on the opposite side neighbor of the !! periodic plane for current leaf node subroutine sdr_find_periodic_neighbor ( elemBary , iDir , bc_id , qVal , & & unKnownBnd , neighbor_pos , & & neighbor_level , leVal , proto , & & geometry , meshUniverse ) ! --------------------------------------------------------------------------! !> current element barycenter real ( kind = rk ), intent ( in ) :: elemBary ( 3 ) !> Current boundary neighbor direction integer , intent ( in ) :: iDir !> treeiD of opposite neighbor with periodic plane integer ( kind = long_k ), intent ( inout ) :: bc_ID !> distance from boundary for direction iDir !! !! @todo HK: maybe turn this optional, why is it relevant for periodic? real ( kind = rk ), intent ( out ) :: qVal !> Set to true if a neighbor with no property is encountered logical , intent ( inout ) :: unKnownBnd !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> level of the periodic boundary neighbor node integer , intent ( in ) :: neighbor_level !> position of neighbor treeID in the proto%node list integer , intent ( in ) :: neighbor_pos !> level value of parent node type ( levelValues_type ), intent ( in ) :: leVal !> contains bounding cube information type ( treelmesh_type ), intent ( in ) :: meshUniverse ! --------------------------------------------------------------------------! integer :: opp_periplane_pos , periPlane_pos type ( sdr_periodicPlane_type ) :: plane_curr , plane_opp real ( kind = rk ) :: bary_opp ( 3 ) real ( kind = rk ) :: coordReal_opp_per ( 3 ) !> position of current periodic plane in periodic plane list integer :: iObj integer :: coord_opp ( 4 ) real ( kind = rk ) :: bary_opp_per ( 3 ) integer ( kind = long_k ) :: treeID_opp integer :: treeID_opp_pos integer :: nBCs integer :: minbcid , leafLevel logical :: bc_defined integer :: intersected_first , intersected_last integer :: minLevel_loc ! --------------------------------------------------------------------------! minLevel_loc = min ( leVal % level , neighbor_level ) !write(dbgUnit(1),*) 'myLevel: ', leVal%level, ' neighborLevel: ', neighbor_level qVal = sdr_qVal_no_intersection periPlane_pos = 0 opp_periplane_pos = 0 !starting coordinate for projecting is current element barycenter coordReal_opp_per = elemBary intersected_first = proto % node % userObjPos % val ( neighbor_pos )% first intersected_last = proto % node % userObjPos % val ( neighbor_pos )% last ! get the periodoc plane position in the array of periodic planes do iObj = intersected_first , intersected_last if ( geometry % spatialObj & & % val ( proto % node % intersected_object & & % val ( iObj ) )% geometry_primitive & & . eq . periodicPlane ) then periPlane_pos = geometry % spatialObj & & % val ( proto % node % intersected_object & & % val ( iObj ) )% primitive_position plane_curr = geometry % periPlane % val ( periPlane_pos ) opp_periPlane_pos = geometry % spatialObj % val ( & & geometry % periPlane % val ( & & periPlane_pos )% oppPlane_pos )% primitive_position plane_opp = geometry % periPlane % val ( opp_periPlane_pos ) ! Project current element on current periodic plane ! and translate to opposite plane coordReal_opp_per = projectVecOnPlane ( & & ( coordReal_opp_per - plane_curr % plane % origin ), & & plane_curr % plane ) + & & plane_opp % plane % origin endif enddo !periodic loop ! barycenter of opposite element in the requested direction iDir from ! the opposite periodic plane must be a fluid element ! we are looking for. Check for existence of this fluid element ! in the protoTree later before assigning to bcid ! barycenter of element in opposite periodic plane bary_opp_per = tem_BaryOfID ( meshUniverse , & & tem_IdOfCoord ( & & tem_CoordOfReal ( meshUniverse , & & coordReal_opp_per , leVal % level ) ) ) ! coordinate of element in opposite periodic plane in fluid level coord_opp = tem_coordOfID ( & & tem_IdOfCoord ( & & tem_CoordOfReal ( meshUniverse , & & bary_opp_per , leVal % level ) ) ) ! Get the coordinate of element in the direction of boundary search. ! This element is suppose to be fluid element coord_opp ( 1 : 3 ) = coord_opp ( 1 : 3 ) + qOffset ( iDir ,:) ! treeID of opposite suspected fluid element treeID_opp = tem_IdOfCoord ( coord_opp ) !write(dbgUnit(5),*) 'treeID_opp ', treeID_opp ! Barycenter of opposite suspected fluid element bary_opp = tem_BaryOfID ( meshUniverse , treeID_opp ) !write(dbgUnit(5),*) \"bary_opp  : \",bary_opp ! Get the position of treeID of bary_opp on the current level since the ! solver requires neighbor treeID in the same level . ! Also the treeID must be a leaf because its property are checked later treeID_opp_pos = getTreeIDPosOfCoord ( coordReal = bary_opp , & & mesh = meshUniverse , & & minLevel = minLevel_loc , & & maxLevel = globalMaxLevels , & & leafLevel = leafLevel , & & leafTreeID = treeID_opp , & & proto = proto ) !write(dbgUnit(5),*) 'treeID_opp_pos ', treeID_opp_pos !write(dbgUnit(5),*) 'leaf level, treeID: ', leafLevel, treeID_opp ! if projected suspected fluid element exist in protoTree ! check if min bcid is again periodic. ! This happens if periodic plane cuts the element in the barycenter ! and both elements in the fine level has periodic boundary property. if ( treeID_opp_pos > 0 ) then ! get min BCID from intersected_objects of current code bc_id = proto % node % minBCID % val ( treeID_opp_pos ) !write(dbgUnit(1),*) '1st assign bc_id ', bc_id ! if bc_id == -1, its again periodic. ! happens when periodic plane passes through barycenter of the parent ! node if ( bc_id == - 1 ) then !write(dbgUnit(1),*) 'Its again periodic' ! do last three steps again ! ie. compute new bary_opp by offsetting in normal*dx ! and get the TreeID of bary_opp and treeID position in protoTree. ! Normal of current plane points outwards the fluid domain . bary_opp = bary_opp + plane_curr % plane % unitNormal * leVal % dx !write(dbgUnit(5),*) \"bary_opp  : \",bary_opp ! get the treeID of bary_opp treeID_opp_pos = getTreeIDPosOfCoord ( coordReal = bary_opp , & & mesh = meshUniverse , & & minLevel = minLevel_loc , & & maxLevel = globalMaxLevels , & & leafTreeID = treeID_opp , & & leafLevel = leafLevel , & & proto = proto ) endif endif ! Projected fluid element must exist in protoTree since ! protoTree contains final fluid elements. ! If does not exist then something else is wrong bc_defined = . false . checkTID : if ( treeID_opp_pos > 0 . and . leafLevel > 0 ) then ! if flooded and min bc_id == 0 then its fluid node ! without any intersecting boundary then return treeID of ! opposite side of periodic boundary on the level of fluid element if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = treeID_opp_pos , & & bit = isFlooded_bit ) ) then bc_id = - tem_IdOfCoord ( tem_CoordOfReal ( meshUniverse , & & bary_opp , leVal % level ) ) bc_defined = . true . !write(dbgUnit(1),*) 'Is flooded' !write(dbgUnit(1),*) 'bc_id in fluid_level: ', bc_id else if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = treeID_opp_pos , & & bit = intersectsBoundary_bit ) & & ) then ! if interesected and exist valid bc_id then return that bc_id ! in special case for qVal active for that bc_id, compute ! qVal and do special treatment in sdr_truncate_qVal. !write(dbgUnit(1),*) 'Is intersected boundary' ! get min BCID from intersected_objects of current code minbcid = proto % node % minBCID % val ( treeID_opp_pos ) !write(dbgUnit(1),*) 'minBCID: ', minbcid nBCs = geometry % attribute % kindpos ( sdr_boundary_object )% nVals if ( minbcid > 0 . and . minbcid <= nBCs ) then bc_id = minbcid bc_defined = . true . ! if qVal active for this bc_id if ( needCalcQValByBCID ( geometry % attribute , minbcid ) ) then call sdr_qValByNode ( proto , geometry , leVal % dx , iDir , & & bary_opp_per , treeID_opp_pos , qVal ) !write(dbgUnit(5),*) 'qVal ', qVal ! if qVal > 1 or no intersection and ! current node is also flooded then set bc_id = -treeID_opp ! else keep valid bc_id and set qVal = 1.0. call sdr_truncate_qVal ( proto = proto , & & qVal = qVal , & & BCID = bc_id , & & neighPos = treeID_opp_Pos , & & treeID_periodic = treeID_opp ) !!write(dbgUnit(5),*) '1.1 qVal ', qVal end if !write(dbgUnit(5),*) 'boundary bc_id', bc_id ! return valid bc_id if qVal < 1 else return negative treeID ! of periodic neighbor return end if else ! Periodic neighbor node is not flooded and not intersected i.e ! undefined hanging node, so treat it with minBCID from all direction ! of current node in  sdr_identify_boundary write ( logUnit ( 3 ), * ) 'WARNING: Periodic neighbor is undefined node.' write ( logUnit ( 3 ), * ) '         Setting minBCID from other directions!' write ( logUnit ( 5 ), * ) 'iDir: ' , iDir , 'ElemBary: ' , elemBary write ( logUnit ( 5 ), * ) 'bary_opp' , bary_opp unKnownBnd = . true . return end if else checkTID ! projected fluid treeID not found in protoTree. ! It must be a treeID inside the boundary which has no property and ! also not refined to the same level as boundary so does not exist in ! protoTree bc_id = - treeID_opp unKnownBnd = . true . write ( logunit ( 3 ), * ) 'WARNING: Projected fluid element not found in & &protoTree' !write(logUnit(0),*) 'TreeID_opp_pos ', treeId_opp_pos, ' leaflvl:', leafLevel write ( logUnit ( 5 ), * ) 'iDir: ' , iDir , 'ElemBary: ' , elemBary write ( logUnit ( 5 ), * ) 'bary_opp' , bary_opp return end if checkTID !write(dbgUnit(1),*) 'bcID: ', bc_id !flush(dbgUnit(1)) if (. not . bc_defined ) then write ( logUnit ( 0 ), * ) 'TreeID_opp_pos ' , treeId_opp_pos , ' leaflvl:' , leafLevel write ( logUnit ( 0 ), * ) 'property ' , proto % node % propertyBits % val (:, treeID_opp_pos ) ! If the boundary is not properly defined, the ! direction of the plane is wrong or ! the element has undefined property i.e not flooded nor ! intersected bit due to hollow geometries. write ( logunit ( 0 ), * ) 'ERROR: in periodic projection. Neighbor element of' write ( logunit ( 0 ), * ) ' the opposide periodic plane has undefined property.' write ( logUnit ( 0 ), * ) bary_opp write ( logUnit ( 0 ), * ) 'iDir: ' , iDir , 'ElemBary: ' , elemBary write ( logunit ( 0 ), * ) 'HINT 1: Check the normal direction of the plane' & & // ' ID' , opp_periPlane_pos write ( logunit ( 0 ), * ) '  is wrong.' write ( logunit ( 0 ), * ) 'Solution: Swap the periodic plane vectors to' & & // ' change the normal.' write ( logunit ( 0 ), * ) '          Normal of both periodic must point' & & // ' opposite' write ( logunit ( 0 ), * ) '          fluid domain' write ( logunit ( 0 ), * ) 'HINT 2: If above solution does not work then ' write ( logunit ( 0 ), * ) '        shift the plane position by dx/2' write ( logunit ( 0 ), * ) 'HINT 3: projected element might be inside the hollow' write ( logunit ( 0 ), * ) '        geometry. deactivate hollow geometry' write ( logunit ( 0 ), * ) 'HINT 4: If above solution does not help then' & & // ' periodic' write ( logunit ( 0 ), * ) '        boundary interface does not match.' write ( logunit ( 0 ), * ) '        check debug output for any mismatch on the' write ( logunit ( 0 ), * ) '        periodic boundary planes refinement' call tem_abort () end if end subroutine sdr_find_periodic_neighbor ! **************************************************************************** ! **************************************************************************** !> This function returns the position of treeID of given coordReal in the !! the given mesh !! Start from minLevel which is the level of neighbor and find the treeID !! which is a leaf in protoTree function getTreeIDPosOfCoord ( coordReal , mesh , minLevel , maxLevel , & & leafLevel , leafTreeID , proto ) result ( pos ) ! --------------------------------------------------------------------------! real ( kind = rk ), intent ( in ) :: coordReal ( 3 ) !>Mesh contain geometry universe (bounding cube) info type ( treelmesh_type ), intent ( in ) :: mesh ! treeID of given coordReal in bounding cube in leaf level integer ( kind = long_k ), intent ( inout ) :: leafTreeID !> minlevel integer , intent ( in ) :: minLevel !> maxlevel integer , intent ( in ) :: maxLevel !> level in which leaf node is found integer , intent ( out ) :: leafLevel !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> position of treeID in proto tree integer :: pos ! --------------------------------------------------------------------------! integer :: iLevel ! --------------------------------------------------------------------------! leafLevel = 0 pos = 0 do iLevel = minLevel , maxLevel leafTreeID = tem_IdOfCoord ( tem_CoordOfReal ( mesh , coordReal , iLevel ) ) pos = PositionOfVal ( & & me = proto % node % treeID , & & val = leafTreeID , & & lower = proto % levelNode_first ( iLevel ), & & upper = proto % levelNode_last ( iLevel ) ) ! found leaf return the current treeID position if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = pos , & & bit = isLeaf_bit ) ) then leafLevel = iLevel return end if end do end function getTreeIDPosOfCoord ! **************************************************************************** ! ***************************************************************************** !> This function project given vector on an given plane !! !!Example: projection of vector a onto a vector u is given as !! \\f$ proj_u a = \\frac{a \\cdot u}{|u|&#94;2} \\cdot u \\f$ ! ***************************************************************************** function projectVecOnPlane ( vecU , plane ) result ( res ) ! ---------------------------------------------------------------------------! !> vector to project real ( kind = rk ), intent ( in ) :: vecU ( 3 ) !> plane on which vecU will be projected type ( tem_plane_type ), intent ( in ) :: plane !> output projected value real ( kind = rk ) :: res ( 3 ) ! ---------------------------------------------------------------------------! ! project vecU on plane%vecA and plane%vecB and add them up ! to find the projection of vecU on the plane res = ( dot_product ( vecU , plane % vec (:, 1 )) / & & dot_product ( plane % vec (:, 1 ), plane % vec (:, 1 ) ) ) * plane % vec (:, 1 ) & & + ( dot_product ( vecU , plane % vec (:, 2 )) / & & dot_product ( plane % vec (:, 2 ), plane % vec (:, 2 ) ) ) * plane % vec (:, 2 ) end function projectVecOnPlane ! ***************************************************************************** ! ***************************************************************************** !> This routine computes the minimum distance of a given link and all the !! geometries in a given node:\\n !! the link is given by a vector and a origin point.\\n !! the node is given by the node position in the protoTree.\\n !! If there is no intersection, qVal returns -1.0 subroutine sdr_qValByNode ( proto , geometry , dx , iDir , origin , & & node_pos , qVal ) ! --------------------------------------------------------------------------! !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> dx of current level real ( kind = rk ), intent ( in ) :: dx !> Direction integer , intent ( in ) :: iDir !> position of node to find the geometries integer :: node_pos !> current element barycenter real ( kind = rk ), intent ( in ) :: origin ( 3 ) !> distance from boundary for all 26 neighbor directions real ( kind = rk ), intent ( out ) :: qVal ! --------------------------------------------------------------------------! integer :: iSpatialObj integer :: obj_pos , geom_prim , atb_pos , prim_pos logical :: intersected type ( tem_line_type ) :: line type ( tem_point_type ) :: intersect_p real ( kind = rk ) :: qVal_t integer :: intersected_first , intersected_last ! --------------------------------------------------------------------------! qVal_t = huge ( qVal_t ) ! create line by origin, iDir and dx line % origin = origin line % vec = qOffset ( iDir , :) * dx ! JQ: loop over spatialObjects, check whether need to calc dist ! call routine that calc distance, given vector and triangles ! if intersected, return the smallest distance ! if not intersected, return 0.0 intersected_first = proto % node % userObjPos % val ( node_pos )% first intersected_last = proto % node % userObjPos % val ( node_pos )% last do iSpatialObj = intersected_first , intersected_last ! Object position obj_pos = proto % node % intersected_object % val ( iSpatialObj ) ! Geometry primitive geom_prim = geometry % spatialObj % val ( obj_pos )% geometry_primitive ! geometry primitive position prim_pos = geometry % spatialObj % val ( obj_pos )% primitive_position ! Attribute position atb_pos = geometry % spatialObj % val ( obj_pos )% attribute_position ! check whether to calculate qVal if ( geometry % attribute % dynArray % val ( atb_pos )% calc_dist ) then select case ( geom_prim ) case ( triangle ) ! Compute whether the link (as described by line) is intersecting ! this triangle: intersected = intersect_RayTriangle ( & & line = line , & & triangle = geometry % triangle % val ( prim_pos ), & & intersect_p = intersect_p ) if ( intersected ) then ! calculate fraction as qVal ! compare it with previous one, choose smaller one qVal_t = min ( qVal_t , fraction_PointLine ( intersect_p , line ) ) endif !@todo: add other geometry primitive here case default end select ! geom_prim endif ! whether to calculate qVal enddo ! spatial objects loop ! if ever intersected, take it as output; otherwise, return -1.0 if ( qVal_t /= huge ( qVal_t ) ) then qVal = qVal_t else qVal = sdr_qVal_no_intersection endif end subroutine sdr_qValByNode ! **************************************************************************** ! ****************************************************************************! !> This routine checks if a boundary need calc qVal for a given BCID !! It is used in identify_boundary routine function needCalcQValByBCID ( attribute , bcid ) result ( calc_qVal ) type ( sdr_attrList_type ), intent ( in ) :: attribute integer , intent ( in ) :: bcid integer :: iAtt logical :: calc_qVal if (( bcid <= attribute % kindpos ( sdr_Boundary_object )% nVals ) & & . and . ( bcid >= 1 )) then iAtt = attribute % kindpos ( sdr_Boundary_object )% val ( bcid ) calc_qVal = attribute % dynArray % val ( iAtt )% calc_dist else calc_qVal = . false . end if end function needCalcQValByBCID ! ****************************************************************************! ! ************************************************************************** ! !> Obtain the surface normal of the chosen boundary if the boundary has !! `store_normal` set. Otherwise a null vector is returned. function getNormal ( geometry , elemBary , node , node_pos , bcid ) result ( normal ) ! --------------------------------------------------------------------- ! type ( sdr_geometry_type ), intent ( in ) :: geometry real ( kind = rk ), intent ( in ) :: elemBary ( 3 ) type ( sdr_node_type ), intent ( in ) :: node integer , intent ( in ) :: node_pos integer , intent ( in ) :: bcid real ( kind = rk ) :: normal ( 3 ) ! --------------------------------------------------------------------- ! logical :: calc_normal integer :: iAtt integer :: intersected_first , intersected_last integer :: geom_prim , atb_pos , prim_pos integer :: obj_pos integer :: iSpatialObj integer :: iTriangle integer :: nIntersected integer :: nAdjacent real ( kind = rk ) :: tridistance type ( grw_realArray_type ) :: closedist integer , allocatable :: closekind (:) integer , allocatable :: distrank (:) real ( kind = rk ), allocatable :: closepoint (:,:) real ( kind = rk ), allocatable :: trinormal (:,:) real ( kind = rk ) :: mindist ! --------------------------------------------------------------------- ! normal = 0.0_rk calc_normal = . false . if (( bcid <= geometry % attribute % kindpos ( sdr_Boundary_object )% nVals ) & & . and . ( bcid >= 1 )) then iAtt = geometry % attribute % kindpos ( sdr_Boundary_object )% val ( bcid ) calc_normal = geometry % attribute % dynArray % val ( iAtt )% store_normal end if if ( calc_normal ) then intersected_first = node % userObjPos % val ( node_pos )% first intersected_last = node % userObjPos % val ( node_pos )% last nIntersected = intersected_last - intersected_first + 1 call init ( closedist , length = nIntersected ) allocate ( closekind ( nIntersected )) allocate ( closepoint ( 3 , nIntersected )) allocate ( trinormal ( 3 , nIntersected )) do iSpatialObj = intersected_first , intersected_last obj_pos = node % intersected_object % val ( iSpatialObj ) atb_pos = geometry % spatialObj % val ( obj_pos )% attribute_position same_attr : if ( atb_pos == iAtt ) then geom_prim = geometry % spatialObj % val ( obj_pos )% geometry_primitive prim_pos = geometry % spatialObj % val ( obj_pos )% primitive_position ! TODO: find closest point on the geometrical objects to the !       element bary center. select case ( geom_prim ) case ( triangle ) iTriangle = closedist % nVals + 1 call tem_triangle_normal_proximity ( & & me = geometry % triangle % val ( prim_pos ), & & point = elemBary , & & closest = closePoint (:, iTriangle ), & & closekind = closekind ( iTriangle ), & & distance = tridistance , & & normal = trinormal (:, iTriangle ) ) call append ( closedist , val = tridistance ) end select end if same_attr end do if ( closedist % nVals > 0 ) then normal = trinormal (:, 1 ) if ( closedist % nVals > 1 ) then allocate ( distrank ( closedist % nVals )) ! Rank the closest points of all triangles by their distance call mrgrnk ( closedist % val (: closedist % nVals ), distrank ) normal = trinormal (:, distrank ( 1 )) if ( closekind ( distrank ( 1 )) > tem_triangle_close_face ) then ! The closest point on the triangle lies on the boundary of the ! triangle. We also need to consider adjacent triangles that may ! share this point and average their normals. mindist = closedist % val ( distrank ( 1 )) * ( 1.0_rk + epsilon ( mindist )) nAdjacent = 1 do iTriangle = 2 , closedist % nVals if ( closedist % val ( distrank ( iTriangle )) > mindist ) EXIT normal = normal + trinormal (:, distrank ( iTriangle )) nAdjacent = nAdjacent + 1 end do normal = normal / nAdjacent normal = dot_product ( elemBary - closePoint (:, distrank ( 1 )), normal ) * normal end if deallocate ( distrank ) end if end if deallocate ( closekind ) deallocate ( closepoint ) deallocate ( trinormal ) call destroy ( closedist ) end if end function getNormal ! ************************************************************************** ! ! ****************************************************************************! !> This routine checks if a boundary need flood periphery for diagonal !! directions for a given BCID. !! It is used in identify_boundary routine function needFldDglByBCID ( attribute , bcid ) result ( flood_diagonal ) type ( sdr_attrList_type ), intent ( in ) :: attribute integer , intent ( in ) :: bcid integer :: iAtt logical :: flood_diagonal if (( bcid <= attribute % kindpos ( sdr_Boundary_object )% nVals ) & & . and . ( bcid >= 1 )) then iAtt = attribute % kindpos ( sdr_Boundary_object )% val ( bcid ) flood_diagonal = attribute % dynArray % val ( iAtt )% flood_diagonal else flood_diagonal = . false . end if end function needFldDglByBCID ! ****************************************************************************! ! ****************************************************************************! !> This routine gives special treatment when qVal > 1.0 or qVal == -1.0 !! for flooded neighbor, treat it as normal fluid: clean BCID, !! set qVal to -1 (no itersection). !! for non-flooded neighbor, treat it as high order wall: set qVal to 1 subroutine sdr_truncate_qVal ( proto , qVal , BCID , neighPos , treeID_periodic ) ! --------------------------------------------------------------------------! !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> qValue real ( kind = rk ), intent ( inout ) :: qVal !> boundary id integer ( kind = long_k ), intent ( inout ) :: BCID !> neighbor position in proto tree integer , intent ( in ) :: neighPos !> negative treeID of periodic domain integer ( kind = long_k ), intent ( in ), optional :: treeID_periodic ! --------------------------------------------------------------------------! if ( qVal > 1._rk . or . qVal == sdr_qVal_no_intersection ) then if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = neighPos , & & bit = isFlooded_bit ) ) then ! clear BCID or set periodic boundary treeID if ( present ( treeID_periodic )) then BCID = - treeID_periodic else BCID = 0_long_k endif ! set qVal to no intersection qVal = sdr_qVal_no_intersection else qVal = 1._rk end if end if end subroutine sdr_truncate_qVal ! ****************************************************************************! end module sdr_boundary_module","tags":"","url":"sourcefile/sdr_boundary_module.f90.html"},{"title":"sdr_hvs_config_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_hvs_config_module.f90~~EfferentGraph sourcefile~sdr_hvs_config_module.f90 sdr_hvs_config_module.f90 sourcefile~ply_sampled_tracking_module.f90 ply_sampled_tracking_module.f90 sourcefile~sdr_hvs_config_module.f90->sourcefile~ply_sampled_tracking_module.f90 sourcefile~sdr_hvs_props_module.f90 sdr_hvs_props_module.f90 sourcefile~sdr_hvs_config_module.f90->sourcefile~sdr_hvs_props_module.f90 sourcefile~ply_subresolution_module.f90 ply_subresolution_module.f90 sourcefile~sdr_hvs_props_module.f90->sourcefile~ply_subresolution_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_hvs_config_module.f90~~AfferentGraph sourcefile~sdr_hvs_config_module.f90 sdr_hvs_config_module.f90 sourcefile~sdr_harvesting.f90 sdr_harvesting.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2015 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Neda Ebrahimi Pour <neda.epour@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> Harvesting configuration module for seeder. !! !! The configuration consists of the mesh to read and visualize, the output !! definition providing the format to write, data extraction via trackings !! and the configuration for the sampling of polynomials. module sdr_hvs_config_module use env_module , only : PathLen use flu_binding , only : flu_State use aotus_module , only : aot_get_val , open_config_file , close_config , & & aoterr_Fatal use treelmesh_module , only : treelmesh_type , load_tem use tem_aux_module , only : tem_abort use tem_bc_prop_module , only : tem_bc_prop_type , init_tem_bc_prop use tem_color_prop_module , only : tem_color_prop_type , tem_color_prop_load use tem_general_module , only : tem_general_type , tem_load_general use tem_logging_module , only : logunit , tem_logging_load_primary use tem_tracking_module , only : tem_tracking_type , tem_trackingControl_type , & & tem_load_tracking use tem_varsys_module , only : tem_varsys_type use tem_time_module , only : tem_time_type , tem_time_reset use tem_restart_module , only : tem_restart_type , tem_restart_openRead , & & tem_load_restart use tem_debug_module , only : tem_debug_load_main use ply_sampled_tracking_module , only : ply_sampled_tracking_type , & & ply_sampled_tracking_load use hvs_output_module , only : hvs_output_config_type , hvs_output_load use sdr_hvs_props_module , only : sdr_hvs_props_type , sdr_hvs_props_load implicit none !> This datatype describes the various settings to load from the configuration !! file. type sdr_hvs_config_type !> Location on disk to load the mesh data from. !! !! This prefix will be put before the various filenames of the individual !! mesh data files. character ( len = pathLen ) :: prefix !> Indication on wether to do subsampling. !! !! Subsampling is only necessary if there is any variable with more than a !! single degree of freedom, and the user requests sampling of the !! polynomials. logical :: do_subsampling !> Definition of trackings to extract only parts of the information. !! !! This includes the configuration for subsampling (which is only relevant !! if there is actually subresolved data in the mesh). type ( ply_sampled_tracking_type ) :: ply_sample_track !> Description of how the visualization output should be done. type ( hvs_output_config_type ) :: output end type sdr_hvs_config_type contains !----------------------------------------------------------------------------! !> Read the configuration for the Seeder harvesting from a Lua script. subroutine sdr_hvs_config_load ( me , mesh , property , varsys , general , & & restart , time ) !----------------------------------------------------------------------------! !> Seeder harvesting configuration to load type ( sdr_hvs_config_type ), intent ( out ) :: me !> Treelm mesh description as obtained from the user configuration. type ( treelmesh_type ), intent ( out ) :: mesh !> Properties associated with the mesh. type ( sdr_hvs_props_type ), intent ( out ) :: property !> A variable system, to which the further variables should be appended. type ( tem_varsys_type ), intent ( inout ) :: varsys !> General treelm data to load type ( tem_general_type ), intent ( inout ) :: general !> type ( tem_restart_type ), intent ( inout ) :: restart !> type ( tem_time_type ), intent ( out ) :: time !----------------------------------------------------------------------! character ( len = pathLen ) :: filename type ( flu_State ) :: conf integer :: iError !----------------------------------------------------------------------! ! Load configuration data according to command line arguments. filename = '' ! Get filename from command argument call get_command_argument ( 1 , filename ) if ( trim ( filename ) == '' ) then ! Default to harvester.lua, if no filename is provided on the command ! line. filename = 'harvester.lua' end if ! Attempt to open the given file as a Lua script. Store a handle to that ! script in conf. call open_config_file ( L = conf , filename = trim ( filename )) ! load and initialize logUnit call tem_logging_load_primary ( conf = conf , & & rank = general % proc % rank ) ! load and initialize debug unit call tem_debug_load_main ( conf = conf , & & rank = general % proc % rank ) call tem_load_general ( me = general , conf = conf ) call tem_load_restart ( me = restart , & & conf = conf , & & tree = mesh , & & timing = time , & & globProc = general % proc ) if (. not . restart % controller % readRestart ) then call load_tem ( me = mesh , & & conf = conf , & & myPart = general % proc % rank , & & nParts = general % proc % comm_size , & & comm = general % proc % comm ) end if call sdr_hvs_props_load ( me = property , & & mesh = mesh , & & varsys = varsys , & & proc = general % proc ) call ply_sampled_tracking_load ( me = me % ply_sample_track , & & conf = conf ) ! Subresolved material data is the only information that provides details ! on a subelement resolution and might need sampling of polynomials. ! Activate the sampling only if there are actually subresolution information ! with non-constant data. me % do_subsampling = ( ( me % ply_sample_track % sampling % max_nlevels > 0 ) & & . and . ( property % subres % polydegree > 0 ) ) if ( me % do_subsampling ) then write ( logunit ( 1 ), * ) 'Subresolved data will be sampled with at most ' , & & me % ply_sample_track % sampling % max_nlevels , ' levels.' else me % ply_sample_track % sampling % max_nlevels = 0 if ( property % subres % polydegree > 0 ) then write ( logunit ( 1 ), * ) 'NO sampling of polynomial data will be done!' else write ( logunit ( 3 ), * ) 'NO polynomial data that would require subsampling.' end if end if ! If tracking table is not defined, load output_folder key ! to dump restart input or mesh to disk if (. not . me % ply_sample_track % tracking % control % active ) then ! load output format and other config for output from output table call hvs_output_load ( me = me % output , & & conf = conf , & & isReduce = . false . ) ! Load output folder call aot_get_val ( L = conf , & & key = 'output_folder' , & & val = me % prefix , & & default = './' , & & ErrCode = iError ) write ( logUnit ( 1 ), * ) 'Ouput folder: ' // trim ( me % prefix ) end if ! Close the configuration script again. call close_config ( conf ) write ( logunit ( 5 ), * ) 'Done in sdr_hvs_config_load.' end subroutine sdr_hvs_config_load !----------------------------------------------------------------------------! !----------------------------------------------------------------------------! end module sdr_hvs_config_module","tags":"","url":"sourcefile/sdr_hvs_config_module.f90.html"},{"title":"sdr_cube_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_cube_module.f90~~AfferentGraph sourcefile~sdr_cube_module.f90 sdr_cube_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_cube_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2014 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011 Metin Cakircali <m.cakircali@grs-sim.de> ! Copyright (c) 2012-2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** !> summary: This module contains cube definitions and routine to load !! cube table from config file ! ****************************************************************************** module sdr_cube_module use env_module , only : rk , labelLen use aotus_module , only : flu_State , aot_get_val , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit implicit none !> An auxilary data type to describe a cube. !! !! Here: The origin is the corner from which on the cube is spanned !! with the given length in each direction. type sdr_cube_type real ( kind = rk ) :: origin ( 3 ) !< origin of the cube real ( kind = rk ) :: center ( 3 ) !< center of the cube real ( kind = rk ) :: extent !< length of the cube real ( kind = rk ) :: halfwidth !< half length of the cube end type sdr_cube_type contains ! **************************************************************************** !> This routine loads the boundCube table from config file ! **************************************************************************** subroutine sdr_load_cube ( me , conf , key , pos , parent ) ! --------------------------------------------------------------------------! type ( sdr_cube_type ), intent ( out ) :: me !< seeder cube type type ( flu_state ) :: conf !< lua state !> open cube table by given key character ( len =* ), optional , intent ( in ) :: key !> open cube table by position integer , optional , intent ( in ) :: pos !> if cube is to be load from pos, parent handle is required integer , optional , intent ( in ) :: parent ! --------------------------------------------------------------------------! integer :: thandle !< cube handle integer :: iError , vError ( 3 ), errFatal ( 3 ) real ( kind = rk ) :: deflen ! --------------------------------------------------------------------------! errFatal = aoterr_fatal me % origin = 0.0 deflen = 1.0_rk if ( present ( key )) then ! open cube table from given key call aot_table_open ( L = conf , thandle = thandle , key = trim ( key )) if ( thandle == 0 ) then write ( logunit ( 0 ), * ) 'FATAL Error: cube definition not found with key:' write ( logunit ( 0 ), * ) ( trim ( key )) call tem_abort () end if else if ( present ( parent ) . and . present ( pos )) then ! else open cube from given table pos call aot_table_open ( L = conf , parent = parent , thandle = thandle , pos = pos ) if ( thandle == 0 ) then write ( logunit ( 0 ), * ) & & 'FATAL Error: cube definition not found with pos:' , pos call tem_abort () end if else write ( logunit ( 0 ), * ) 'ERROR: Neither key nor pos is provided to load ' & & // ' cube table' call tem_abort () end if call aot_get_val ( L = conf , thandle = thandle , val = me % origin , ErrCode = vError , & & key = 'origin' , pos = 1 , default = [ 0.0_rk , 0.0_rk , 0.0_rk ] ) if ( any ( btest ( vError , errFatal ))) then write ( logunit ( 0 ), * ) 'FATAL Error occured, while retrieving cube origin.' call tem_abort () end if call aot_get_val ( L = conf , thandle = thandle , & & val = me % extent , ErrCode = iError , & & key = 'length' , pos = 2 , default = deflen ) if ( btest ( iError , aoterr_Fatal )) then write ( logunit ( 0 ), * ) 'FATAL Error occured, while retrieving cube length:' if ( btest ( iError , aoterr_NonExistent )) & & write ( logunit ( 0 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logunit ( 0 ), * ) 'Variable has wrong type!' call tem_abort () else if ( btest ( iError , aoterr_NonExistent )) & & write ( logunit ( 1 ), * ) 'Variable length not set in configuration, ' & & // 'using default value!' end if me % halfwidth = 0.5_rk * me % extent me % center = me % origin + me % halfwidth write ( logunit ( 1 ), * ) ' Cube origin: ' , me % origin write ( logunit ( 1 ), * ) ' Cube length: ' , me % extent call aot_table_close ( L = conf , thandle = thandle ) end subroutine sdr_load_cube ! **************************************************************************** end module sdr_cube_module","tags":"","url":"sourcefile/sdr_cube_module.f90.html"},{"title":"sdr_proto2treelm_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_proto2treelm_module.f90~~EfferentGraph sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_cube_module.f90 sdr_cube_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_cube_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_proto2treelm_module.f90~~AfferentGraph sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2017, 2023 Harald Klimach <harald.klimach@dlr.de> ! Copyright (c) 2012-2015, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012, 2014 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2014 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016, 2018 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2018 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> author: Kannan Masilamani !! author: Jiaxing !! Module to create the actual mesh out of the flooded protoTree. !! !! This module provides the functionality to refine the computational domain !! down to the requested level everywhere and identify the boundary conditions !! in all 26 directions of the elements, which have boundaries. !! module sdr_proto2treelm_module use env_module , only : long_k , rk , newunit , isLittleEndian , & & globalMaxLevels , labelLen use tem_param_module , only : qQQQ use tem_grow_array_module , only : grw_longArray_type , grw_intArray_type , & & grw_realArray_type , grw_char2dArray_type , & & init , append , truncate , destroy use tem_dyn_array_module , only : positionOfVal , append , dyn_intArray_type , & & init , destroy use tem_bc_prop_module , only : tem_bc_prop_type use tem_propHead_module , only : tem_propHead_type use tem_topology_module , only : tem_directChildren , tem_firstIDatLevel , & & tem_CoordOfId , tem_IdOfCoord , & & tem_parentOf , tem_LevelOf use tem_geometry_module , only : tem_eligibleChildren , tem_BaryOfCoord , & & tem_CoordOfReal , tem_BaryOfID , tem_ElemSize use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_property_module , only : prp_hasBnd , prp_solid , prp_hasQVal , & & prp_isColored , prp_hasPolynomial , & & prp_noSolidification , prp_hasNormal use tem_global_module , only : tem_global_type , dump_tem_global use treelmesh_module , only : treelmesh_type use ply_oversample_module , only : ply_convertFromOversample use ply_poly_project_module , only : ply_poly_project_type , & & ply_poly_project_fillbody , & & ply_poly_project_n2m use ply_prj_header_module , only : ply_prj_header_out use sdr_cube_module , only : sdr_cube_type use sdr_prototree_module , only : sdr_protoTree_type , levelValues_type , & & sdr_neighbor_in_proto use sdr_geometry_module , only : sdr_geometry_type , is_intersecting use sdr_periodic_module , only : sdr_periodicPlane_type use sdr_node_module , only : isFlooded_bit , isLeaf_bit , isColored_bit , & & IntersectsBoundary_bit , isTarget_bit , & & hasBoundary_bit , isFluidifyable_bit , & & sdr_nodeColors , sdr_nodeProp_btest , & & sdr_color_log2char , sdr_bitfieldColors , & & isNoSolidification_bit use sdr_attribute_module , only : sdr_Boundary_Object , sdr_Seed_Object use sdr_config_module , only : sdr_confHead_type use sdr_boundary_module , only : sdr_identify_boundary , & & sdr_qVal_no_intersection , & & sdr_find_periodic_neighbor use aot_out_module , only : aot_out_type , aot_out_val , & & aot_out_open , aot_out_close , & & aot_out_open_table , aot_out_close_table use sdr_timer_module , only : timer_handle_proto2treelm , & & timer_handle_dumping_mesh use tem_timer_module , only : tem_startTimer , tem_stopTimer implicit none !> Data type contains final fluid info dumped into mesh file type sdr_temData_type !> list of fluid treeIDs type ( grw_longArray_type ) :: treeID !> list of property bits for fluid nodes type ( grw_longArray_type ) :: propertyBits !> list of boundary iDs for fluid nodes in 26 directions type ( grw_longArray_type ) :: bc_ID ( qQQQ ) !> list of color characters type ( grw_char2dArray_type ) :: colors !> list of color characters indicating their subresolution status. type ( grw_char2dArray_type ) :: subres !> Count number of subresolved elements for each color. integer , allocatable :: color_subres_count (:) !> File unit for the subresolution information of each color. integer , allocatable :: color_subres_unit (:) !> Measure of the volume covered by each color real ( kind = rk ), allocatable :: color_volume (:) !> maxlevel in the fluid domain integer :: maxLevel !> minlevel in the fluid domain integer :: minLevel !> link-wise distances from boundary for fluid nodes in 26 directions type ( grw_realArray_type ) :: qVal ( qQQQ ) !> Surface normals in boundary elements for which it is to be stored type ( grw_realArray_type ) :: bc_normal ( 3 ) !> treelm mesh type contains only bounding cube info !! needed to identify boundary and compute q-values type ( treelmesh_type ) :: meshUniverse !> number of fluidifyable ( solids ) integer :: nSolids = 0 !> Number of fluids on each level integer :: nFluids ( globalMaxLevels ) !> Projection workspace. type ( ply_poly_project_type ) :: projection end type sdr_temData_type contains ! ****************************************************************************! !> This subroutine creates the treelmesh from the flooded prototree. !! !! It will create the treelmesh out of all flooded elements and refine those !! leaves intersected by a refinement object. !! This routine will also identify the elements with boundary conditions !! and store the boundary information accordingly. !! Please keep in mind, that the flooding only considered the 6 face !! neighbors, while we create boundary informations for all 26 neighbors. !! @todo Neighbors that do not intersect boundary objects. !! This means, that it might happen, that any of the 20 further neighbors !! does not actually intersect a boundary object. We need to deal with !! this case properly. !! For example, a boundary condition might be selected based on the !! adjacent face neighbors for the direction in question. subroutine sdr_proto2treelm ( proto , geometry , temData , header ) ! --------------------------------------------------------------------------! !> preliminary tree type ( sdr_protoTree_type ), intent ( inout ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> temData contains final mesh created by this routine type ( sdr_temData_type ), intent ( inout ) :: temData !> Header data. type ( sdr_confHead_type ), intent ( inout ) :: header ! --------------------------------------------------------------------------! integer :: minlevel integer :: ilevel integer :: iDir integer :: iColor type ( levelValues_type ) :: leVal ! --------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_proto2treelm ) !effective bounding info temData % meshUniverse % global % effOrigin = & & huge ( temData % meshUniverse % global % effOrigin ) temData % meshUniverse % global % effLength = & & - huge ( temData % meshUniverse % global % effLength ) minlevel = header % minlevel write ( logunit ( 1 ), * ) 'Creating treelmesh ...' ! Initialize the growing arrays for the new mesh data, they will have to ! contain at least as many elements, as we found flooded leaf nodes so far. call init ( temData % treeID , length = proto % nFloodedLeaves ) call init ( temData % propertyBits , length = proto % nFloodedLeaves ) temData % maxLevel = 0 temData % minLevel = huge ( temData % minLevel ) temData % nFluids = 0 do iDir = 1 , qQQQ call init ( temData % bc_ID ( iDir )) call init ( temData % qVal ( iDir )) end do call init ( temData % bc_normal ( 1 )) call init ( temData % bc_normal ( 2 )) call init ( temData % bc_normal ( 3 )) call init ( me = temData % colors , & & width = proto % node % nColorChars ) call init ( me = temData % subres , & & width = proto % node % nColorChars ) allocate ( temData % color_subres_count ( proto % node % nColors ) ) allocate ( temData % color_subres_unit ( proto % node % nColors ) ) allocate ( temData % color_volume ( proto % node % nColors ) ) temData % color_volume = 0.0_rk temData % color_subres_count = 0 if ( header % subresolution % nLevels > 0 ) then ! If we are going to deal with subresolution, we need to fill the ! projection data now. call ply_poly_project_fillbody ( me = temData % projection , & & proj_init = header % subresolution & & % projection , & & scheme_dim = 3 ) end if ! Set the length of the level cube length to the complete bounding cube ! length for level=0. ! Set some auxilary data describing the current level. leVal % dx = geometry % universe % extent leVal % ID_offset = tem_FirstIdAtLevel ( 0 ) ! first treeID on this level leVal % level = 0 ! level count ! Start with the root node, and recursively iterate down to the leaves. ! As we follow the child ordering from the space filling curve, this ! recursive procedure will result in a sorted list of elements as required ! by treelm. call traverse_tree ( node_pos = 1 , & & leVal = leVal , & & proto = proto , & & geometry = geometry , & & temData = temData , & & header = header , & & meshUniverse = temData % meshUniverse ) ! Close subelement color files again. do iColor = 1 , proto % node % nColors if ( temData % color_subres_count ( iColor ) > 0 ) then close ( temData % color_subres_unit ( iColor )) end if end do write ( logunit ( 1 ), * ) '                      done' write ( logunit ( 2 ), * ) 'Total number of fluids: ' , temData % treeID % nVals write ( logunit ( 2 ), * ) '' if ( temdata % minlevel < temdata % maxlevel ) then ! For multilevel meshes print a summary on element distribution: write ( logunit ( 2 ), '(2(a,i0))' ) 'Distributed across levels ' , & & temdata % minlevel , ' to ' , temdata % maxlevel do iLevel = temdata % minlevel , temdata % maxlevel write ( logunit ( 2 ), '(2(a,i0),a)' ) 'Level ' , iLevel , ': ' , & & temdata % nFluids ( iLevel ), ' Elements' end do write ( logunit ( 2 ), * ) '' end if call tem_stopTimer ( timerHandle = timer_handle_proto2treelm ) end subroutine sdr_proto2treelm ! ************************************************************************** ! ! ************************************************************************** ! !> Recursively traverse the tree in a depth first manner to obtain the !! the ordering required by treelm. !! !! Only consider flooded nodes here, no need to traverse further down any !! non-flooded node, as it does not belong to the computational domain. !! All virtual nodes containing at least one flooded leaf node has already !! been determined and set after flooding in sdr_flood_module::sdr_flood_tree. !! If the leaf node is reached, hand over to the ::refine_leaf routine, to !! find all elements, that actually should be created in the computational !! domain. !! !! @todo KM: Store has_boundary information for every leaf node in !! sdr_refine_leaf routine to avoid excessive boundary checking far !! away from the boundaries. recursive subroutine traverse_tree ( node_pos , leVal , proto , geometry , & & temData , header , meshUniverse ) ! ---------------------------------------------------------------------- ! !> Position of leaf in the preliminary tree integer , intent ( in ) :: node_pos !> level value of current node type ( levelValues_type ), intent ( in ) :: leVal !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> temData contains final treelmesh type ( sdr_temData_type ), intent ( inout ) :: temData !> Header information type ( sdr_confHead_type ), intent ( in ) :: header !> contains bounding cube information type ( treelmesh_type ), intent ( inout ) :: meshUniverse ! ---------------------------------------------------------------------- ! integer :: minlevel integer :: child_pos integer :: iChild logical :: check_bnd type ( levelValues_type ) :: child_leVal integer :: nodeprops character :: nodecolors ( proto % node % nColorChars ) ! ---------------------------------------------------------------------- ! minlevel = header % minlevel nodeprops = ibits ( proto % node % PropertyBits & & % val ( proto % node % propLength , Node_pos ), & & pos = proto % node % lastbyte_pos , len = 8 ) !> If this node is flooded or fluidifyable it needs to be included in the !! final mesh. if ( btest ( nodeprops , isFlooded_bit ) ) then ! If flooded take some action, depending on the node type: ifleaf : if ( btest ( nodeprops , isLeaf_bit ) ) then ! This node IS A LEAF! ! Get its colors: nodecolors = sdr_nodeColors ( proto % node , Node_pos ) ! If this node is colored, set its bit accordingly. if ( any ( ichar ( nodecolors ) > 0 )) then nodeprops = ibset ( nodeprops , isColored_bit ) end if ! Add this leaf or if necessary its children down to the configured ! resolution to the list of fluid elements and find the correct boundary ! conditions. ! JQ: no need to check boundary condition for isFluidifyable nodes ! Check boundary only if it is marked with hasBoundary_bit check_bnd = ( . not . btest ( nodeprops , isFluidifyable_bit ) . and . & & btest ( nodeprops , hasBoundary_bit ) ) ! No need for further refinement. ! Just append the node to temData call proto2Treelm ( & & node_pos = node_pos , & & treeID = proto % node % treeID % val ( node_pos ), & & nodeprops = nodeprops , & & nodecolors = nodecolors , & & leVal = leVal , & & proto = proto , & & geometry = geometry , & & check_bnd = check_bnd , & & temData = temData , & & meshUniverse = meshUniverse ) else ifleaf ! NOT A LEAF ! Check if it is a target element, if so add it as an element and create ! subelement resolution data. ! Otherwise traverse further down through all eight children. iftarget : if ( btest ( nodeprops , isTarget_bit ) ) then ! Target nodes are to be added to the final treelmesh. ! The children below them are only used to describe subelement ! resolved boundaries with the help of polynomials. call create_target ( node_pos = node_pos , & & proto = proto , & & geometry = geometry , & & leVal = leVal , & & meshUniverse = meshUniverse , & & header = header , & & temData = temData ) else iftarget ! This is a virtual element. ! Set some auxilary data describing the next level (common to all ! children). child_leVal % level = leVal % level + 1 child_leVal % dx = 0.5_rk * leVal % dx child_leVal % ID_offset = tem_FirstIdAtLevel ( child_leVal % level ) do iChild = 0 , 7 child_pos = proto % node % linkpos ( 1 )% val ( node_pos ) + iChild call traverse_tree ( node_pos = child_pos , & & leVal = child_leVal , & & proto = proto , & & geometry = geometry , & & temData = temData , & & header = header , & & meshUniverse = meshUniverse ) end do end if iftarget end if ifleaf end if !if flooded end subroutine traverse_tree ! ************************************************************************** ! ! ************************************************************************** ! !> Routine to convert protoTree to Treelm data format. !! append all leaves to the temData%treeID !! !! Add this element to the list of elements in the final tree, by adding: !!       * treeID !!       * propertyBits !! If there is a boundary, also add the correct boundary data into the !! 26 direct neighbors (bc_ID), append to all 26 even if there is no !! boundary condition in the given direction, no boundaries are indicated !! by 0, boundary conditions are decided based on the trumping rule, that !! is the minimal bc_ID of all boundary objects in the corresponding !! neighbor are chosen. !! Treat periodic boundaries here if possible by putting the opposite !! treeID into the bc_ID. subroutine proto2Treelm ( node_pos , treeID , leVal , proto , geometry , check_bnd ,& & temData , nodeprops , nodecolors , meshUniverse ) ! ---------------------------------------------------------------------- ! !> Position of leaf in the preliminary tree integer , intent ( in ) :: node_pos !> treeID of current node integer ( kind = long_k ), intent ( in ) :: treeID !> propertyBits of current node integer , intent ( in ) :: nodeprops !> Color information of the cuurent node character , intent ( in ) :: nodecolors (:) !> level value of current node type ( levelValues_type ), intent ( in ) :: leVal !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> does this node has boundary neighbor logical , intent ( in ) :: check_bnd type ( sdr_temData_type ), intent ( inout ) :: temData !> contains bounding cube information type ( treelmesh_type ), intent ( inout ) :: meshUniverse ! ---------------------------------------------------------------------- ! integer :: iDir integer ( kind = long_k ) :: BC_ID ( qQQQ ) real ( kind = rk ) :: qVal ( qQQQ ) !< link-wise distance for boundary elements real ( kind = rk ) :: bc_normal ( 3 ) ! normal of closest surface integer ( kind = long_k ) :: propBits type ( sdr_cube_type ) :: node_cube integer :: node_coord ( 4 ) real ( kind = rk ) :: elemvol integer :: nodepropbits ( proto % node % propLength ) integer :: iColor , col_int , col_bit ! ---------------------------------------------------------------------- ! ! Intitalize boundary info. BC_ID = 0 qVal = sdr_qVal_no_intersection ! coordinate of current node treeID node_coord = tem_coordOfId ( treeID = treeID , & & offset = leVal % ID_offset ) ! Find which neighbors have boundaries. ! save bcID in `BC_ID`, q-value in `qVal` and surface normal in `bc_normal` if ( check_bnd ) then call sdr_identify_boundary ( node_pos , treeID , node_coord , leVal , proto , & & geometry , BC_ID , qVal , bc_normal , & & meshUniverse ) end if ! Define the cube to intersect with node_cube % origin = leVal % dx * node_coord ( 1 : 3 ) & & + geometry % universe % origin node_cube % halfwidth = 0.5_rk * leVal % dx node_cube % center = node_cube % origin + node_cube % halfwidth node_cube % extent = leVal % dx elemvol = leval % dx ** 3 ! update maxLevel and minLevel according to current level temdata % maxlevel = max ( temdata % maxlevel , leVal % level ) temdata % minlevel = min ( temdata % minlevel , leVal % level ) temdata % nFluids ( leval % level ) = temdata % nFluids ( leval % level ) + 1 ! Append this node to the temData lists call append ( temData % treeID , treeID ) ! compute effective bounding cube origin and length using node origin ! and its extent+origin respectively meshUniverse % global % effOrigin & & = min ( meshUniverse % global % effOrigin , node_cube % origin ) meshUniverse % global % effLength & & = max ( meshUniverse % global % effLength , node_cube % origin + leVal % dx ) propBits = 0_long_k ! The color of the current node. if ( btest ( nodeprops , isColored_bit ) ) then propBits = ibset ( propBits , prp_isColored ) call append ( temData % colors , nodecolors ) ! Check the colored status, to account for the volume fraction of each ! color. nodepropbits = proto % node % PropertyBits % val (:, Node_pos ) do iColor = 1 , proto % node % nColors ! Figure out the bit 0 in the integer field for this color col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 if ( btest ( nodepropbits ( col_int ), col_bit + 1 ) ) then temData % color_volume ( iColor ) = temData % color_volume ( iColor ) & & + elemvol end if end do end if ! Decide on hasBnd, and set temData%PropertyBits and temData%BC_ID ! accordingly. if ( any ( BC_ID /= 0_long_k ) ) then ! there is an adjacent boundary propBits = ibset ( propBits , prp_hasBnd ) ! JQ: if it has qVal, set propertyBits and append qVal if ( any ( qVal > 0.0_rk )) then propBits = ibset ( propBits , prp_hasQVal ) do iDir = 1 , qQQQ call append ( temData % qVal ( iDir ), qVal ( iDir ) ) end do end if if (( bc_normal ( 1 ) ** 2 + bc_normal ( 2 ) ** 2 + bc_normal ( 3 ) ** 2 ) > 0.0_rk ) then propBits = ibset ( propBits , prp_hasNormal ) do iDir = 1 , 3 call append ( temData % bc_normal ( iDir ), bc_normal ( iDir )) end do end if ! append bc_id do iDir = 1 , qQQQ call append ( temData % BC_ID ( iDir ), BC_ID ( iDir ) ) end do end if if ( btest ( nodeprops , isFluidifyable_bit ) ) then propBits = ibset ( propBits , prp_solid ) temData % nSolids = temData % nSolids + 1 end if ! If this node is a noSolidification node, set its bit accordingly. if ( btest ( nodeprops , isNoSolidification_bit ) ) then propbits = ibset ( propbits , prp_noSolidification ) end if ! append propertyBits call append ( temData % PropertyBits , propBits ) end subroutine proto2Treelm ! ****************************************************************************! ! ****************************************************************************! !> Routine to create an element with subelement resolution. !! !! This routine is used to define a target element, that is a node, that !! reached its final level, but contains boundaries, that are to be resolved !! on a subelement basis. For the treelmesh, this is just a normal element !! with additional information attached to it. That additional information !! is covered by a property. !! For the actual information in the subelement resolution, the children of !! the target node need to be considered. !! We use a separate routine for this case, as it is ensured, that this !! element never will be refined, due to adjacent boundaries. (Any such !! refinement was already done during the building of the protoTree). !! Also we will ignore Q-Value complications here for the identification of !! boundaries. If subelement resolution is active, no Q-Values might be used !! and the other way around. subroutine create_target ( node_pos , proto , geometry , leVal , & & meshUniverse , header , temData ) ! --------------------------------------------------------------------------! !> Position of leaf in the preliminary tree integer , intent ( in ) :: node_pos !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto !> contains all geometrical objects type ( sdr_geometry_type ), intent ( in ) :: geometry !> level value of parent node type ( levelValues_type ), intent ( in ) :: leVal !> contains bounding cube information type ( treelmesh_type ), intent ( inout ) :: meshUniverse !> Configuration header. type ( sdr_confHead_type ), intent ( in ) :: header !> Data for the final mesh. type ( sdr_temData_type ), intent ( inout ) :: temData ! --------------------------------------------------------------------------! ! Colors, that are found within this element. character :: nodecolors ( proto % node % nColorChars ) character :: subresolved_colors ( proto % node % nColorChars ) integer :: nodepropbits ( proto % node % propLength ) logical :: color_subresolved ( proto % node % nColors ) logical :: color_subresflooded ( proto % node % nColors ) integer ( kind = long_k ) :: nodeID , propBits integer :: nObjects integer :: obj_pos integer :: iDir , iObject , iColor integer :: attr_kind , attr_pos integer :: bc_color , bcid integer :: col_int , col_bit integer :: node_coord ( 4 ) type ( sdr_cube_type ) :: node_cube integer ( kind = long_k ) :: BC_ID ( qQQQ ) integer ( kind = long_k ) :: fallback_bc integer :: neighbor_pos , neighbor_level real ( kind = rk ) :: dummy_qval logical :: testall character ( len = LabelLen ) :: col_name character ( len = 4 ) :: EndianSuffix integer :: subres_pos real ( kind = rk ), allocatable :: color_modes (:,:) real ( kind = rk ), allocatable :: color_oversampled (:,:) real ( kind = rk ), allocatable :: color_nodes (:,:) real ( kind = rk ) :: elemvol integer :: rl integer :: nDofs integer :: nPoints integer :: nOversampled integer :: record integer :: intersected_first , intersected_last logical :: unKnownBnd ! --------------------------------------------------------------------------! if ( isLittleEndian ) then EndianSuffix = '.lsb' else EndianSuffix = '.msb' end if propBits = 0_long_k nodeID = proto % node % treeID % val ( node_pos ) ! If no boundary is found in a direction, facing a non-flooded element, we ! fallback to the minimal boundary condition in the target element itself. fallback_bc = int ( proto % node % minBCID % val ( node_pos ), kind = long_k ) if ( fallback_bc == - 1_long_k ) then ! Periodic boundaries not allowed in subresolved elements ! write ( logunit ( 1 ), '(a)' ) 'There is a periodic boundary running through a' write ( logunit ( 1 ), '(a,i0,a)' ) 'subresolved element (treeID=' , nodeID , & & ').' write ( logunit ( 1 ), '(a)' ) 'This can not be properly handled!' write ( logunit ( 1 ), '(a)' ) 'Please ensure that periodic boundaries and' write ( logunit ( 1 ), '(a)' ) 'subelement resolved boundaries are sufficiently' write ( logunit ( 1 ), '(a)' ) 'far apart!' write ( logunit ( 1 ), * ) write ( logunit ( 1 ), '(a)' ) 'STOPPING!' call tem_abort () end if ! update maxLevel and minLevel according to current level temdata % maxlevel = max ( temdata % maxlevel , leVal % level ) temdata % minlevel = min ( temdata % minlevel , leVal % level ) ! Define the intersected cube node_coord = tem_coordOfId ( treeID = nodeID , & & offset = leVal % ID_offset ) node_cube % origin = leVal % dx * node_coord ( 1 : 3 ) & & + geometry % universe % origin node_cube % halfwidth = 0.5_rk * leVal % dx node_cube % center = node_cube % origin + node_cube % halfwidth node_cube % extent = leVal % dx elemvol = leVal % dx ** 3 ! compute effective bounding cube origin and length using node origin ! and its extent+origin respectively meshUniverse % global % effOrigin & & = min ( meshUniverse % global % effOrigin , node_cube % origin ) meshUniverse % global % effLength & & = max ( meshUniverse % global % effLength , node_cube % origin + leVal % dx ) ! Look up neighbors and set boundaries accordingly do iDir = 1 , qQQQ BC_ID ( iDir ) = 0_long_k ! Default to no boundary. unKnownBnd = . false . neighbor_pos = sdr_neighbor_in_proto ( proto , node_coord , iDir , & & neighbor_level ) ! Only if the neighbor was not flooded, we need a boundary. ! Flooded neighbors might be target elements or plain fluids, if there ! is a boundary, but no target, the element will not be flooded. if ( . not . sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = isFlooded_bit ) ) then ! The node is not flooded, if it is intersected, we can look up the ! boundary ID to use in this direction. if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = intersectsBoundary_bit ) ) then BC_ID ( iDir ) = int ( proto % node % minBCID % val ( neighbor_pos ), kind = long_k ) ! Treating periodic boundaries identified by an ID of -1: if ( BC_ID ( iDir ) == - 1_long_k ) then call sdr_find_periodic_neighbor ( elemBary = node_cube % center ,& & iDir = iDir , & & bc_id = BC_ID ( iDir ), & & qVal = dummy_qVal , & & unKnownBnd = unKnownBnd , & & neighbor_pos = neighbor_pos , & & neighbor_level = neighbor_level , & & leVal = leVal , & & proto = proto , & & geometry = geometry , & & meshUniverse = meshUniverse ) end if else ! No boundary in this direction, but no flooded element, use the ! fallback boundary. BC_ID ( iDir ) = fallback_bc end if ! if periodic boundary encounters hanging node with no property then ! use fall back boundary if ( unKnownBnd ) BC_ID ( iDir ) = fallback_bc end if end do if ( any ( BC_ID /= 0_long_k ) ) then ! there is at least one adjacent boundary propBits = ibset ( propBits , prp_hasBnd ) ! append bc_id do iDir = 1 , qQQQ call append ( temData % BC_ID ( iDir ), BC_ID ( iDir ) ) end do end if ! test all spatial objects only for root node. ! Check whether to intersect with all geometries testAll = ( leVal % level == 0 ) if ( testAll ) then nObjects = geometry % spatialObj % nVals intersected_first = 1 intersected_last = nObjects else intersected_first = proto % node % userObjPos % val ( node_pos )% first intersected_last = proto % node % userObjPos % val ( node_pos )% last nObjects = intersected_last - intersected_first + 1 end if ! Check which colors actually need to be subresolved. color_subresolved = . false . objLoop : do iObject = intersected_first , intersected_last if ( testAll ) then obj_pos = iObject else obj_pos = proto % node % intersected_object % val ( iObject ) end if attr_pos = geometry % spatialObj % val ( obj_pos )% attribute_position attr_kind = geometry % attribute % dynArray % val ( attr_pos )% kind if ( attr_kind == sdr_Boundary_object ) then bcid = geometry % attribute % dynArray % val ( attr_pos )% id bc_color = geometry % attribute % bc_color_id ( bcid ) if ( bc_color > 0 ) then color_subresolved ( bc_color ) = color_subresolved ( bc_color ) & & . or . geometry % attribute % dynArray & & % val ( attr_pos )% subresolution end if end if end do objLoop ! In retrospect, we now have to remove the flooding status for those colors ! with an intersecting boundary but no subresolution. nodepropbits = proto % node % PropertyBits % val (:, Node_pos ) color_subresflooded = . false . do iColor = 1 , proto % node % nColors ! Figure out the bit 0 in the integer field for this color col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 if ( btest ( nodepropbits ( col_int ), col_bit ) ) then ! If this color is intersected, clear the flooded status, if it is not ! also to be subresolved. if ( . not . color_subresolved ( iColor ) ) then ! Bit 1 for this color indicates the flooding status, clear it if ! there is an intersection, but no subresolution. nodepropbits = ibclr ( nodepropbits ( col_int ), col_bit + 1 ) end if end if ! If the element is flooded by the color, we set the subresolution action ! depending on the intersection status. Ignore the none color here. if ( iColor /= proto % node % none_color_id ) then if ( btest ( nodepropbits ( col_int ), col_bit + 1 ) ) then ! If the element is flooded by any color, set the isColored bit. propBits = ibset ( propBits , prp_isColored ) ! Check each color for its intersection status ! This will only be true, if the element is flooded by the color and ! intersected by a boundary of this color with the subresolution flag. color_subresflooded ( iColor ) = btest ( nodepropbits ( col_int ), col_bit ) ! Count fully flooded elements for the volume fraction of the color. if (. not . color_subresflooded ( iColor )) then temData % color_volume ( iColor ) = temData % color_volume ( iColor ) & & + elemvol end if end if end if end do if ( btest ( propBits , prp_isColored )) then nodecolors = sdr_bitfieldColors ( node = proto % node , & & bitfield = nodepropbits ) call append ( temData % colors , nodecolors ) end if if ( any ( color_subresflooded )) then ! This element provides polynomial informations on the colors, thus ! hasPolynomial bit also needs to be set. propBits = ibset ( propBits , prp_hasPolynomial ) ! Append the bitmask on, which colors are to be found in this element to ! the list of colors. subresolved_colors = sdr_color_log2char ( node = proto % node , & & logicals = color_subresolved ) call append ( temData % subres , subresolved_colors ) end if ! No need for further refinement. ! Append this node to the temData lists call append ( temData % treeID , nodeID ) call append ( temData % PropertyBits , propBits ) nDofs = temData % projection % body_3d % ndofs noversampled = ( temData % projection % oversamp_degree + 1 ) ** 3 nPoints = temData % projection % nQuadPointsPerDir ** 3 allocate ( color_modes ( nDofs , 1 )) allocate ( color_oversampled ( noversampled , 1 )) allocate ( color_nodes ( nPoints , 1 )) inquire ( iolength = rl ) color_modes do iColor = 1 , proto % node % nColors ! Iterate over all colors that are to be subresolved and actually flood ! this element. Only for these we need to create polynomial data. if ( color_subresflooded ( iColor ) ) then col_name = geometry % attribute % uni_name ( sdr_Seed_object )% val ( iColor ) subres_pos = positionofval ( header % subresolution % color_values % label , & & trim ( col_name ) ) write ( logunit ( 6 ), * ) 'Creating subresolution data for color ' & & // trim ( col_name ) write ( logunit ( 6 ), * ) 'in element ' , nodeID temData % color_subres_count ( iColor ) = temData & & % color_subres_count ( iColor ) + 1 record = temData % color_subres_count ( iColor ) if ( temData % color_subres_count ( iColor ) == 1 ) then ! First subresolution info for this color, create a file for it temData % color_subres_unit ( iColor ) = newunit () open ( unit = temData % color_subres_unit ( iColor ), & & file = trim ( header % folder ) // 'subresdata_' & & // trim ( col_name ) // EndianSuffix , & & action = 'write' , access = 'direct' , form = 'unformatted' , & & recl = rl , status = 'replace' ) end if ! Forall color_nodes: sdr_point_color ! nodal2modal(color_nodes, color_modes) ! Maybe do this inplace (without separated color_nodes)? call sdr_color_points ( & & nPoints = nPoints , & & nodals = color_nodes (:, 1 ), & & point = temData % projection % body_3d % nodes , & & fill = header % subresolution % color_values & & % fill % val ( subres_pos ), & & void = header % subresolution % color_values & & % void % val ( subres_pos ), & & target_pos = node_pos , & & proto = proto , & & iColor = iColor ) call ply_poly_project_n2m ( me = temData % projection , & & dim = 3 , & & nVars = 1 , & & nodal_data = color_nodes , & & modal_data = color_oversampled ) call ply_convertFromOversample ( modalCoeffs = color_oversampled , & & poly_proj = temData % projection , & & nDim = 3 , & & state = color_modes ) ! Account the volume fraction for the color. temData % color_volume ( iColor ) = temData % color_volume ( iColor ) & & + elemvol * color_modes ( 1 , 1 ) write ( temData % color_subres_unit ( iColor ), rec = record ) color_modes end if end do deallocate ( color_nodes ) deallocate ( color_oversampled ) deallocate ( color_modes ) end subroutine create_target ! ****************************************************************************! ! **************************************************************************** !> Get the color at all given points. !! !! Points need to be in the interval [-1,1]. subroutine sdr_color_points ( nodals , nPoints , point , target_pos , fill , void , & & proto , iColor ) ! --------------------------------------------------------------------------! real ( kind = rk ), intent ( out ) :: nodals (:) integer , intent ( in ) :: nPoints !> Point for which to evaluate the color. real ( kind = rk ), intent ( in ) :: point (:,:) !> Position of leaf in the preliminary tree integer , intent ( in ) :: target_pos real ( kind = rk ), intent ( in ) :: fill , void !> preliminary tree type ( sdr_protoTree_type ), intent ( in ) :: proto integer , intent ( in ) :: iColor ! --------------------------------------------------------------------------! integer :: subelem integer :: iPoint integer :: col_int , col_bit integer :: iChild real ( kind = rk ) :: child_origin ( 3 ) real ( kind = rk ) :: child_point ( 3 ) integer :: point_coord ( 3 ) ! --------------------------------------------------------------------------! col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 + 1 do iPoint = 1 , nPoints ! Switch to next point in list child_point = point ( iPoint ,:) ! Reset to target element subelem = target_pos ! Loop over levels (until value is found) lvl_loop : do ! Polynomial points in the range (-1,1), coord(point) = ceil(point) ! Use maximum to ensure integer coordinates in {0,1} point_coord = max ( ceiling ( child_point ), 0 ) iChild = point_coord ( 1 ) + 2 * point_coord ( 2 ) + 4 * point_coord ( 3 ) subelem = proto % node % linkpos ( 1 )% val ( subelem ) + iChild ! Rescale point position to the child element child_origin = [ - 0.5_rk , - 0.5_rk , - 0.5_rk ] + point_coord child_point = ( child_point - child_origin ) * 2 if ( btest ( proto % node % PropertyBits % val ( col_int , subelem ), & & col_bit ) ) then ! Flooded, check wether we reached the leaf if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = subelem , & & bit = isLeaf_bit ) ) then ! Reached a flooded leaf, return the foreground nodals ( iPoint ) = fill EXIT lvl_loop end if else ! Not flooded: done return background nodals ( iPoint ) = void EXIT lvl_loop end if end do lvl_loop end do end subroutine sdr_color_points ! ****************************************************************************! ! **************************************************************************** !> This routine dumps the final fluid tree leaves in the disk subroutine sdr_dump_treelm ( temData , geometry , confHeader ) ! --------------------------------------------------------------------------! !> temData contains final treelmesh type ( sdr_temData_type ), intent ( in ) :: temData !> Bounding cube, the prototree lives in. type ( sdr_geometry_type ), intent ( in ) :: geometry !> config header info. type ( sdr_confHead_type ), intent ( inout ) :: confHeader ! --------------------------------------------------------------------------! character ( len = 4 ) :: EndianSuffix type ( tem_global_type ) :: tem_global integer :: iElem integer :: meshunit , bndunit , rl , distunit , colunit character ( len = 300 ) :: ElemFileName character ( len = 300 ) :: BndFileName character ( len = 300 ) :: ColFileName character ( len = 300 ) :: BndDistFileName !< Boundary Distance File Name character ( len = LabelLen ) :: col_name type ( aot_out_type ) :: conf !< aotus lua state to write output integer ( kind = long_k ) :: BC_id ( qQQQ ) real ( kind = rk ) :: qVal ( qQQQ ) real ( kind = rk ) :: bc_normal ( 3 ) integer :: iDir , iAttr , iProp , iBC , iColor integer :: nProperties_max type ( tem_propHead_type ), allocatable :: property (:) integer :: nColors integer :: nBCs integer :: vpos integer ( kind = long_k ) :: id integer :: uni_id integer :: iUnibc real ( kind = rk ) :: cval type ( dyn_intArray_type ) :: actBC ! --------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_dumping_mesh ) write ( logunit ( 1 ), * ) 'dumping treelmesh to dir: ' // trim ( confHeader % folder ) if ( isLittleEndian ) then EndianSuffix = '.lsb' else EndianSuffix = '.msb' end if ! Initialize nProperties tem_global % nProperties = 0 nProperties_max = 4 ! allocate property list and propHeader infos allocate ( property ( nProperties_max ) ) ! --------------------------------------------------------------------------- ! Dump boundary only if bnd nElems > 0 ! --------------------------------------------------------------------------- ! Dump boundary info to bnd.lua if ( temData % bc_ID ( 1 )% nVals > 0 ) then tem_global % nProperties = tem_global % nProperties + 1 ! property 1 is boundary property ( tem_global % nProperties )% bitpos = prp_hasBnd property ( tem_global % nProperties )% label = 'has boundaries' property ( tem_global % nProperties )% nElems = temData % bc_ID ( 1 )% nVals ! ------------------------------------------------------------------------- ! Dump boundary ID to bnd.lsb or bnd.msb bndunit = newunit () BndFileName = trim ( confHeader % folder ) // 'bnd' // EndianSuffix inquire ( iolength = rl ) BC_id (:) open ( unit = bndunit , file = trim ( BndFileName ), action = 'write' , & & form = 'unformatted' , access = 'direct' , & & recl = rl ) do iElem = 1 , temData % BC_ID ( 1 )% nVals do iDir = 1 , qQQQ ! Boundaries might be defined, but not actually appear in the mesh. ! This is especially true for multi-color meshes, where there can be ! interfaces between colors, without a real color. ! We sort out these boundaries and renumber the boundary references ! accordingly. Negative values, that indicate other elements, need ! to be maintained. ! The mapping from the final bc_ids to the original unique boundaries ! is stored in actBC. id = temData % BC_ID ( iDir )% val ( iElem ) if ( id > 0_long_k ) then iAttr = geometry % attribute % kindpos ( sdr_Boundary_object ) & & % val ( id ) uni_id = geometry % attribute % dynArray % val ( iAttr )% uni_id call append ( me = actBC , & & val = uni_id , & & pos = iBC ) BC_id ( iDir ) = int ( iBC , kind = long_k ) else BC_id ( iDir ) = temData % BC_ID ( iDir )% val ( iElem ) end if end do write ( bndunit , rec = iElem ) BC_id end do nBCs = actBC % nVals call aot_out_open ( conf , trim ( confHeader % folder ) // 'bnd.lua' ) call aot_out_val ( put_conf = conf , vname = 'nSides' , val = qQQQ ) call aot_out_val ( put_conf = conf , vname = 'nBCtypes' , & & val = nBCs ) call aot_out_open_table ( conf , 'bclabel' ) do iBC = 1 , nBCs iUnibc = actBC % val ( iBC ) call aot_out_val ( conf , & & val = geometry % attribute & & % uni_name ( sdr_Boundary_object ) & & % val ( iUnibc ) ) end do call aot_out_close_table ( conf ) call aot_out_close ( conf ) close ( bndunit ) end if ! --------------------------------------------------------------------------- ! --------------------------------------------------------------------------- ! Dump qVal only if qVal nElems > 0 ! --------------------------------------------------------------------------- ! JQ: Dump qVal info to qval.lua if ( temData % qVal ( 1 )% nVals > 0 ) then tem_global % nProperties = tem_global % nProperties + 1 ! JQ: add prp_hasQVal property information ! propery 2 is has qval property ( tem_global % nProperties )% bitpos = prp_hasQVal property ( tem_global % nProperties )% label = 'has qVal' property ( tem_global % nProperties )% nElems = temData % qVal ( 1 )% nVals call aot_out_open ( conf , trim ( confHeader % folder ) // 'qval.lua' ) ! Dump logical variables that indicate whether the corresponding BC ! has qVal call aot_out_open_table ( conf , 'hasQVal' ) do iBC = 1 , actBC % nVals iUnibc = actBC % val ( iBC ) call aot_out_val ( conf , & & val = geometry % attribute % bc_uni_calcdist % val ( iUnibc ) ) end do call aot_out_close_table ( conf ) call aot_out_close ( conf ) ! ------------------------------------------------------------------------- ! ------------------------------------------------------------------------- ! JQ: Dump boundary qVal to file qval.lsb distUnit = newunit () BndDistFileName = trim ( confHeader % folder ) // 'qval' // EndianSuffix inquire ( iolength = rl ) qVal (:) open ( unit = distunit , file = trim ( BndDistFileName ), action = 'write' , & & form = 'unformatted' , access = 'direct' , & & recl = rl ) do iElem = 1 , temData % qVal ( 1 )% nVals do iDir = 1 , qQQQ qVal ( iDir ) = temData % qVal ( iDir )% val ( iElem ) enddo write ( distunit , rec = iElem ) qVal end do close ( distUnit ) endif ! temData%qVal(1)%nVals > 0 ! --------------------------------------------------------------------------- ! --------------------------------------------------------------------------- ! Dump store_normal info to normals.lua anyNormals : if ( temData % bc_normal ( 1 )% nVals > 0 ) then tem_global % nProperties = tem_global % nProperties + 1 property ( tem_global % nProperties )% bitpos = prp_hasNormal property ( tem_global % nProperties )% label = 'has normal' property ( tem_global % nProperties )% nElems = temData % bc_normal ( 1 )% nVals call aot_out_open ( conf , trim ( confHeader % folder ) // 'normals.lua' ) ! Dump logical variables that indicate whether the corresponding BC ! has normals stored for it call aot_out_open_table ( conf , 'hasNormal' ) do iBC = 1 , actBC % nVals iUnibc = actBC % val ( iBC ) call aot_out_val ( conf , & & val = geometry % attribute % bc_uni_storenormal % val ( iUnibc ) ) end do call aot_out_close_table ( conf ) call aot_out_close ( conf ) call destroy ( actBC ) ! ------------------------------------------------------------------------- ! ------------------------------------------------------------------------- ! Dump boundary normals to normals.lsb distUnit = newunit () BndDistFileName = trim ( confHeader % folder ) // 'normals' // EndianSuffix inquire ( iolength = rl ) bc_normal (:) open ( unit = distunit , file = trim ( BndDistFileName ), action = 'write' , & & form = 'unformatted' , access = 'direct' , & & recl = rl ) do iElem = 1 , temData % bc_normal ( 1 )% nVals do iDir = 1 , 3 bc_normal ( iDir ) = temData % bc_normal ( iDir )% val ( iElem ) end do write ( distunit , rec = iElem ) bc_normal end do close ( distUnit ) end if anyNormals ! --------------------------------------------------------------------------- ! --------------------------------------------------------------------------- ! JQ: Dump property prp_solid into header file if ( temData % nSolids > 0 ) then tem_global % nProperties = tem_global % nProperties + 1 ! JQ: add prp_solid property information ! propery 3 is has qval property ( tem_global % nProperties )% bitpos = prp_solid property ( tem_global % nProperties )% label = 'solid' property ( tem_global % nProperties )% nElems = temData % nSolids end if ! --------------------------------------------------------------------------- ! --------------------------------------------------------------------------- ! Dump color info to colors.lua if ( temData % colors % nVals > 0 ) then tem_global % nProperties = tem_global % nProperties + 1 property ( tem_global % nProperties )% bitpos = prp_isColored property ( tem_global % nProperties )% label = 'is colored' property ( tem_global % nProperties )% nElems = temData % colors % nVals call aot_out_open ( conf , trim ( confHeader % folder ) // 'colors.lua' ) call aot_out_open_table ( conf , 'color_label' ) nColors = 0 do iColor = 1 , geometry % attribute % uni_name ( sdr_Seed_object )% nVals col_name = geometry % attribute % uni_name ( sdr_Seed_object )% val ( iColor ) if ( trim ( col_name ) /= 'none' ) then write ( logunit ( 2 ), * ) 'Color ' , trim ( col_name ), ' with a volume of ' , & & temData % color_volume ( iColor ) write ( logunit ( 2 ), * ) 'in the mesh.' call aot_out_val ( conf , val = trim ( col_name ) ) nColors = nColors + 1 end if end do call aot_out_close_table ( conf ) call aot_out_val ( put_conf = conf , vname = 'nColors' , & & val = nColors ) call aot_out_open_table ( conf , 'color_fill' ) do iColor = 1 , geometry % attribute % uni_name ( sdr_Seed_object )% nVals col_name = geometry % attribute % uni_name ( sdr_Seed_object )% val ( iColor ) if ( trim ( col_name ) /= 'none' ) then vpos = confHeader % subresolution % value_pos ( iColor ) cval = confHeader % subresolution % color_values % fill % val ( vpos ) call aot_out_val ( conf , val = cval ) end if end do call aot_out_close_table ( conf ) call aot_out_open_table ( conf , 'color_void' ) do iColor = 1 , geometry % attribute % uni_name ( sdr_Seed_object )% nVals col_name = geometry % attribute % uni_name ( sdr_Seed_object )% val ( iColor ) if ( trim ( col_name ) /= 'none' ) then vpos = confHeader % subresolution % value_pos ( iColor ) cval = confHeader % subresolution % color_values % void % val ( vpos ) call aot_out_val ( conf , val = cval ) end if end do call aot_out_close_table ( conf ) call aot_out_open_table ( conf , 'color_volume' ) do iColor = 1 , geometry % attribute % uni_name ( sdr_Seed_object )% nVals col_name = geometry % attribute % uni_name ( sdr_Seed_object )% val ( iColor ) if ( trim ( col_name ) /= 'none' ) then vpos = confHeader % subresolution % value_pos ( iColor ) cval = confHeader % subresolution % color_values % void % val ( vpos ) call aot_out_val ( conf , val = temData % color_volume ( iColor ) ) end if end do call aot_out_close_table ( conf ) call aot_out_close ( conf ) ! ------------------------------------------------------------------------- ! Dump element colors to colors.ascii colunit = newunit () ColFileName = trim ( confHeader % folder ) // 'colors.ascii' inquire ( iolength = rl ) temData % colors % val (:, 1 ) open ( unit = colunit , file = trim ( ColFileName ), action = 'write' , & & form = 'unformatted' , access = 'stream' ) write ( colunit ) temData % colors % val close ( colunit ) end if ! --------------------------------------------------------------------------- ! --------------------------------------------------------------------------- ! Dump subresolution info to subresolution.lua if ( temData % subres % nVals > 0 ) then tem_global % nProperties = tem_global % nProperties + 1 property ( tem_global % nProperties )% bitpos = prp_hasPolynomial property ( tem_global % nProperties )% label = 'has polynomial' property ( tem_global % nProperties )% nElems = temData % subres % nVals call aot_out_open ( conf , trim ( confHeader % folder ) // 'subresolution.lua' ) call aot_out_val ( put_conf = conf , & & vname = 'polydegree' , & & val = confHeader % subresolution % polydegree ) call aot_out_val ( put_conf = conf , & & vname = 'polyspace' , & & val = confHeader % subresolution % polyspace ) call aot_out_open_table ( conf , 'projection' ) call ply_prj_header_out ( me = confheader % subresolution % project_header , & & conf = conf ) call aot_out_close_table ( conf ) call aot_out_open_table ( conf , 'color_subres_nelems' ) do iColor = 1 , geometry % attribute % uni_name ( sdr_Seed_object )% nVals col_name = geometry % attribute % uni_name ( sdr_Seed_object )% val ( iColor ) if ( trim ( col_name ) /= 'none' ) then call aot_out_val ( conf , val = temData % color_subres_count ( iColor ) ) end if ! Close the data files now, they were already written in create_target. if ( temData % color_subres_count ( iColor ) > 0 ) then close ( temData % color_subres_unit ( iColor ) ) end if end do call aot_out_close_table ( conf ) call aot_out_close ( conf ) ! ------------------------------------------------------------------------- ! Dump subresolved element colors to subres.ascii colunit = newunit () ColFileName = trim ( confHeader % folder ) // 'subres.ascii' inquire ( iolength = rl ) temData % subres % val (:, 1 ) open ( unit = colunit , file = trim ( ColFileName ), action = 'write' , & & form = 'unformatted' , access = 'stream' ) write ( colunit ) temData % subres % val close ( colunit ) end if ! --------------------------------------------------------------------------- if ( temData % bc_ID ( 1 )% nVals > 0 ) then call destroy ( actBC ) end if !mesh header info tem_global % BoundingCubeLength = geometry % universe % extent tem_global % Origin = geometry % universe % origin tem_global % effOrigin = temData % meshUniverse % global % effOrigin tem_global % effLength = temData % meshUniverse % global % effLength & & - temData % meshUniverse % global % effOrigin tem_global % nElems = temData % treeID % nVals tem_global % nParts = 1 tem_global % myPart = 0 tem_global % minLevel = temData % minlevel tem_global % maxLevel = temData % maxlevel tem_global % label = 'fluidTree' tem_global % comment = trim ( confHeader % comment ) tem_global % dirname = trim ( confHeader % folder ) ! allocate property list and propHeader infos allocate ( tem_global % property ( tem_global % nProperties ) ) do iProp = 1 , tem_global % nProperties tem_global % property ( iProp ) = property ( iProp ) end do deallocate ( property ) ! Dump global mesh info to header.lua. call dump_tem_global ( tem_global ) ! --------------------------------------------------------------------------- ! Dump mesh to elemlist.lsb or elemlist.msb meshunit = newunit () ElemFileName = trim ( tem_global % dirname ) // 'elemlist' // EndianSuffix inquire ( iolength = rl ) 0_long_k , 0_long_k open ( unit = meshunit , file = trim ( ElemFileName ), action = 'write' , & & form = 'unformatted' , access = 'direct' , & & recl = rl ) do iElem = 1 , temData % treeID % nVals write ( meshunit , rec = iElem ) temData % treeID % val ( iElem ), & & temData % PropertyBits % val ( iElem ) end do close ( meshunit ) write ( logunit ( 1 ), * ) 'Seeder created mesh successfully!' call tem_stopTimer ( timerHandle = timer_handle_dumping_mesh ) end subroutine sdr_dump_treelm end module sdr_proto2treelm_module","tags":"","url":"sourcefile/sdr_proto2treelm_module.f90.html"},{"title":"sdr_stl_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_stl_module.f90~~AfferentGraph sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2014 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012 Sathish Krishnan P S <s.krishnan@grs-sim.de> ! Copyright (c) 2013 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** !> This module provides a adapter rouinte to load stl file and add triangles !! to spatial objects !! !! \\author Kannan Masilamani !! module sdr_stl_module ! include treelm modules use env_module , only : rk , PathLen use tem_aux_module , only : tem_abort use tem_tools_module , only : tem_horizontalSpacer use tem_logging_module , only : logunit use tem_stlb_io_module , only : tem_read_stlb , tem_size_stlb use tem_triangle_module , only : tem_triangle_type , & & grw_triangleArray_type , append use tem_transformation_module , only : tem_transformation_type use tem_stl_module , only : tem_load_stl , tem_stlData_type ! include seeder modules use stla_io , only : stla_read , stla_size , stla_check use sdr_spatialObj_module , only : grw_spatialObjArray_type , & & sdr_spatialObj_type , triangle , append ! include aotus modules use flu_binding , only : flu_State use aotus_module , only : flu_State , aot_get_val , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length implicit none private public :: sdr_load_stl contains ! ***************************************************************************** !> This routine loads STL files from config and reads the triangles from the !! files into the dynamic array of triangles. subroutine sdr_load_stl ( triArray , spaObjArray , attr_pos , transform , & & conf , thandle ) ! --------------------------------------------------------------------------! !> Dynamic array of triangles type ( grw_triangleArray_type ), intent ( inout ) :: triArray !> Growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> Position of the attribute, this object is connected to. integer , intent ( in ) :: attr_pos !> transformation for spatial object type ( tem_transformation_type ), intent ( in ) :: transform !> Lua state type ( flu_state ) :: conf integer , intent ( in ) :: thandle !< handle for canonical objects ! --------------------------------------------------------------------------! integer :: iTri type ( tem_stlData_type ) :: stl_data type ( sdr_spatialObj_type ) :: spatialObj type ( tem_triangle_type ) :: loc_tri ! --------------------------------------------------------------------------! call tem_load_stl ( stl_Data , transform , conf , thandle ) ! Fix spatial object entries for all triangles from this STL. spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = triangle do iTri = 1 , stl_data % nTris loc_tri % nodes (:, 1 ) = stl_data % nodes ( :, stl_data % tri_node ( 1 , iTri ) ) loc_tri % nodes (:, 2 ) = stl_data % nodes ( :, stl_data % tri_node ( 2 , iTri ) ) loc_tri % nodes (:, 3 ) = stl_data % nodes ( :, stl_data % tri_node ( 3 , iTri ) ) ! Append triangle into list of all triangles. call append ( triArray , loc_tri ) ! Store the position of this triangle for identification in the list of ! all spatial objectes. spatialObj % primitive_position = triArray % nVals ! Append spatialObj to list of spatialObjs. call append ( spaObjArray , spatialObj ) end do ! Deallocate nodes and triangle array in stl_data. deallocate ( stl_data % nodes ) deallocate ( stl_data % tri_node ) end subroutine sdr_load_stl ! ***************************************************************************** end module sdr_stl_module !> \\page stl STL !! stl files can be used as geometry kind. At first, seeder load the !! triangles from stl files to the temporary stl_data type and !! then each triangle in the stl_data is converted to sdr_triangle_type.\\n !! stl geometry requires filename and stl file format. If file format !! is not provided, default is set to binary. !! Valid definition: !! \\li Single stl !! \\verbatim !! geometry={ !!   kind='stl', !!     object={ !!       filename='cube.stl', !!       format = 'ascii' -- if not provided, default is binary !!     } !! } !! \\endverbatim !! !! \\li Multiple stls !! \\verbatim !! geometry={ !!   kind='stl', !!     object={ !!       { !!       filename = 'cube.stl' !!       }, !!       { !!       filename = 'cylinder.stl' !!       } !!     } !! } !! \\endverbatim !! \\n\\n !! Seeder file to create mesh with single 'stl' geometry: !! \\include testsuite/stl/seeder.lua !! \\n\\n !! Mesh with 'stl' geometry created by seeder file: !! \\image html stl_cylinder.png !! \\endverbatim !! Example lua file is available at \\link testsuite/stl/seeder.lua !! \\example testsuite/stl/seeder.lua","tags":"","url":"sourcefile/sdr_stl_module.f90.html"},{"title":"ply_nodes_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_nodes_module.f90~~EfferentGraph sourcefile~ply_nodes_module.f90 ply_nodes_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_nodes_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_nodeset_module.f90 ply_nodeset_module.f90 sourcefile~ply_nodes_module.f90->sourcefile~ply_nodeset_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013-2014 Verena Krupp ! Copyright (c) 2013-2014, 2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2014-2015 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2014,2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2017 Neda Ebrahimi Pour <neda.epour@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Verena Krupp, Peter Vitt, ! Tobias Girresser, Nikhil Anand and Neda Ebrahimi Pour for University of ! Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Description of point sets. module ply_nodes_module use env_module , only : rk , labelLen use fftw_wrap , only : fftw_available use aotus_module , only : flu_State , aot_get_val use tem_aux_module , only : tem_abort use ply_nodeset_module , only : ply_nodeset_coords , & & ply_nodeset_legendre , & & ply_nodeset_chebyshev , & & ply_nodeset_chebyloba use ply_nodes_header_module , only : ply_nodes_header_type , assignment ( = ) implicit none private !> Datatype to represent facewise nodes type ply_faceNodes_type !> The number of face nodes integer :: nquadPoints !> The face nodes. !! First index goes from 1 to nPoints and second index !! from 1 to 3 for the 3 spatial coordinates. real ( kind = rk ), allocatable :: points (:,:) end type ply_faceNodes_type public :: ply_nodes_create public :: ply_faceNodes_type contains ! ------------------------------------------------------------------------ ! !> Initialize points with the Chebyshev quadrature points, 3D subroutine ply_nodes_create ( me , nodes , faces , nQuadPointsPerDir , ndims ) ! -------------------------------------------------------------------- ! type ( ply_nodes_header_type ), intent ( in ) :: me real ( kind = rk ), allocatable , intent ( out ) :: nodes (:,:) type ( ply_faceNodes_type ), allocatable , intent ( out ) :: faces (:,:) integer , intent ( in ) :: nQuadPointsPerDir integer , intent ( in ) :: ndims ! -------------------------------------------------------------------- ! procedure ( ply_nodeset_coords ), pointer :: nodeset => NULL () integer :: iDir ! -------------------------------------------------------------------- ! select case ( trim ( me % nodes_kind )) case ( 'gauss-legendre' ) nodeset => ply_nodeset_legendre case ( 'chebyshev' ) if ( me % lobattoPoints ) then nodeset => ply_nodeset_chebyloba else nodeset => ply_nodeset_chebyshev end if end select ! Build the Chebyshev nodes on the reference element (volume) call ply_nodes_volume_coords ( & & num_intp_per_direction = nQuadPointsPerDir , & & nDims = nDims , & & nodeset = nodeset , & & points = nodes ) ! Build the Chebyshev nodes on the reference faces allocate ( faces ( ndims , 2 ) ) faces (:,:)% nquadpoints = nQuadPointsPerDir ** ( nDims - 1 ) do iDir = 1 , ndims call ply_nodes_surface_coords ( & & num_intp_per_direction = nQuadPointsPerDir , & & nDims = ndims , & & nodeset = nodeset , & & left = faces ( iDir , 1 )% points , & & right = faces ( iDir , 2 )% points , & & dir = iDir ) end do end subroutine ply_nodes_create ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Create multidimensional points from given 1D set of nodes in the cubic !! reference element. !! !! The points will be created by a tensor product of the provided 1d nodeset !! for the given number of dimensions. subroutine ply_nodes_volume_coords ( num_intp_per_direction , & & nDims , nodeset , points ) ! -------------------------------------------------------------------- ! !> Number auf integration points in each direction. integer , intent ( in ) :: num_intp_per_direction !> Number of dimensions to create the points for. integer , intent ( in ) :: nDims !> Set of node coordinates to use in the element. procedure ( ply_nodeset_coords ) :: nodeset !> Resulting list of points. First index runs over all points, second !! indicates the coordinate dimension (x=1,y=2,z=3). !! !! For ndims smaller than 3, the higher dimensions will be set to 0. real ( kind = rk ), allocatable , intent ( out ) :: points (:,:) ! -------------------------------------------------------------------- ! integer :: n1d integer :: numQuadPoints ! -------------------------------------------------------------------- ! n1d = num_intp_per_direction numQuadPoints = n1d ** nDims allocate ( points ( numQuadPoints , 3 )) points = 0.0_rk call ply_point_tensor ( nPoints1D = n1d , & & nDims = nDims , & & nodeset = nodeset , & & points = points (:,: nDims ) ) end subroutine ply_nodes_volume_coords ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Create the integration points on the surface of (cubical) elements. subroutine ply_nodes_surface_coords ( & & num_intp_per_direction , ndims , nodeset , & & left , right , dir ) ! -------------------------------------------------------------------- ! !> Number of integration points in each direction integer , intent ( in ) :: num_intp_per_direction !> Number of dimensions in the element. integer , intent ( in ) :: ndims !> Set of node coordinates to use in the element for which the surface !! points are to be defined. procedure ( ply_nodeset_coords ) :: nodeset !> The points on the left surface. real ( kind = rk ), allocatable , intent ( out ) :: left (:,:) !> The points on the right surface. real ( kind = rk ), allocatable , intent ( out ) :: right (:,:) !> The spatial direction of the face. \\n !! 1 -> x direction \\n !! 2 -> y direction \\n !! 3 -> z direction integer :: dir ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: surface (:,:) integer :: nquadPoints integer :: n1d integer :: tangents ( 2 , 3 ) ! -------------------------------------------------------------------- ! tangents (:, 1 ) = [ 2 , 3 ] tangents (:, 2 ) = [ 1 , 3 ] tangents (:, 3 ) = [ 1 , 2 ] n1d = num_intp_per_direction nQuadPoints = n1d ** ( ndims - 1 ) allocate ( left ( nQuadPoints , 3 )) allocate ( right ( nQuadPoints , 3 )) ! Ensure that the higher dimensions are set to 0, ! if not all three dimensions are used. left = 0.0_rk right = 0.0_rk left (:, dir ) = - 1.0_rk right (:, dir ) = 1.0_rk if ( nDims >= 2 ) then allocate ( surface ( nQuadPoints , nDims - 1 )) call ply_point_tensor ( nPoints1D = n1d , & & nDims = nDims - 1 , & & nodeset = nodeset , & & points = surface ) left (:, tangents (: nDims - 1 , dir )) = surface right (:, tangents (: nDims - 1 , dir )) = surface end if end subroutine ply_nodes_surface_coords ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Compute a multi-dimensional tensor for the given set of nodes. subroutine ply_point_tensor ( nPoints1D , nDims , nodeset , points ) ! -------------------------------------------------------------------- ! !> Number auf integration points in each direction. integer , intent ( in ) :: nPoints1D !> Number of dimensions to create the points for. integer , intent ( in ) :: nDims !> Set of node coordinates to use in the element. procedure ( ply_nodeset_coords ) :: nodeset !> Resulting list of points. First index runs over all points, second !! indicates the coordinate dimension (x=1,y=2,z=3). real ( kind = rk ), intent ( out ) :: points ( nPoints1D ** nDims , nDims ) ! -------------------------------------------------------------------- ! integer :: j , k integer :: jk integer :: n1d integer :: nPlane real ( kind = rk ), allocatable :: gaussp1D (:) integer :: numQuadPoints ! -------------------------------------------------------------------- ! n1d = nPoints1D numQuadPoints = n1d ** nDims nPlane = n1d ** ( nDims - 1 ) if ( numQuadPoints > 1 ) then ! Only if there are multiple integration points to compute look into ! the nodeset. allocate ( gaussp1D ( n1d )) gaussp1D = nodeset ( n1d ) ! X coordinates do jk = 1 , nPlane points (( jk - 1 ) * n1d + 1 : jk * n1d , 1 ) = gaussp1D end do if ( nDims >= 2 ) then ! Y coordinates do jk = 1 , nPlane j = mod ( jk - 1 , n1D ) + 1 points (( jk - 1 ) * n1d + 1 : jk * n1d , 2 ) = gaussp1D ( j ) end do if ( nDims >= 3 ) then ! Y coordinates do k = 1 , n1D points (( k - 1 ) * nPlane + 1 : k * nPlane , 3 ) = gaussp1D ( k ) end do end if end if else ! Just a single integration point, return the center. points = 0.0_rk end if end subroutine ply_point_tensor ! ------------------------------------------------------------------------ ! end module ply_nodes_module","tags":"","url":"sourcefile/ply_nodes_module.f90.html"},{"title":"ply_legser_module.f90 – Seeder","text":"Source Code !> This module provides Piessens Algorithm 473 from the Communications of the !! ACM, January 1974, Volume 17, Number 1. !! !! Its unrestricted use in a computer is permitted. !! !! This Algorithm transforms a known Chebyshev expansion into a Legendre !! expansion in N&#94;2 time complexity. module ply_legser_module use env_module , only : rk implicit none private public :: ply_legser contains ! ************************************************************************ ! !> Subroutine to convert Chebyshev (A) to Legendre (B) coefficients. !! !! This is Piessens Algorithm, which can be found as Algorithm 473 in the !! Communications of the ACM, January 1974, Volume 17, Number 1, page 25. !! It is slightly modified to account for Fortran 90 practices. !! !! Algorithm makes use of the recurrence relation, by which the integral !! of the product of the nth Legendre polynomial with the kth Chebyshev !! polynomial I_{n,k} is given by: !! !! I_{n,k+2} = {[(k-1)*k - n(n+1)]*(k+2) / ([(k+3)*(k+2) - n*(n+1)]*k)} !!           * I_{n,k} !! with I_{0,0} and I_{n,k} = 0 if k < n. For I_{n,n} we have: !! I_{n,n} = 2&#94;{2n}*(n!)&#94;2/(2n+1)! if n > 0 subroutine ply_legser ( A , B , n ) ! -------------------------------------------------------------------- ! !> Number of coefficients. integer , intent ( in ) :: n !> Known coefficients of the Chebyshev approximation. real ( kind = rk ), intent ( in ) :: A ( n ) !> Computed corresponding coefficients of the Legendre approximation. real ( kind = rk ), intent ( out ) :: B ( n ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ak , al , bb , c , d integer :: k , l , ll ! -------------------------------------------------------------------- ! ak = 0.0_rk ! Calculation of the first Legendre coefficient b ( 1 ) = 0.5_rk * a ( 1 ) do k = 3 , n , 2 ak = ak + 2.0_rk b ( 1 ) = b ( 1 ) - a ( k ) / ( ak * ak - 1.0_rk ) end do c = 2.0_rk / 3.0_rk al = 0.0_rk ! Start main loop (remaining Legendre coefficients) do l = 2 , n ! Calculation of the Lth coefficient ll = l + 2 al = al + 1.0_rk bb = c * a ( l ) d = c ak = al do k = ll , n , 2 d = ( ( ak - 1.0_rk ) * ak - al * ( al + 1.0_rk ) ) & & * ( ak + 2.0_rk ) & & * d & & / ( (( ak + 3.0_rk ) * ( ak + 2.0_rk ) - al * ( al + 1.0_rk )) * ak ) bb = bb + a ( k ) * d ak = ak + 2.0_rk end do c = 4.0_rk * c * ( al + 1.0_rk ) * ( al + 1.0_rk ) & & / ( ( al + al + 3.0_rk ) * ( al + al + 2.0_rk ) ) b ( l ) = ( al + 0.5_rk ) * bb end do end subroutine ply_legser ! ************************************************************************ ! end module ply_legser_module","tags":"","url":"sourcefile/ply_legser_module.f90.html"},{"title":"seeder.f90 – Seeder","text":"This file depends on sourcefile~~seeder.f90~~EfferentGraph sourcefile~seeder.f90 seeder.f90 sourcefile~sdr_aux_module.f90 sdr_aux_module.f90 sourcefile~seeder.f90->sourcefile~sdr_aux_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~seeder.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_cube_module.f90 sdr_cube_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_cube_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2016 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011 Daniel Harlacher <d.harlacher@grs-sim.de> ! Copyright (c) 2011, 2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011-2015 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011-2012 Metin Cakircali <m.cakircali@grs-sim.de> ! Copyright (c) 2011 Aravindh Krishnamoorthy <aravindh28.4@gmail.com> ! Copyright (c) 2011 Khaled Ibrahim <k.ibrahim@grs-sim.de> ! Copyright (c) 2011-2012 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Raphael Haupt <Raphael.Haupt@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ******************************************************************************! !> S E E D E R !! Mesh generator within the APES suite !! !! For a documentation, run ./waf gendoxy and find the documentation at !! ./Documentation/html/index.html program seeder ! treelm modules use tem_general_module , only : tem_start , tem_finalize use tem_debug_module , only : main_debug use tem_timer_module , only : tem_stopTimer ! seeder modules use sdr_aux_module , only : sdr_init_global use sdr_config_module , only : sdr_load_config , sdr_confHead_type use sdr_geometry_module , only : sdr_geometry_type use sdr_protoTree_module , only : sdr_protoTree_type , sdr_build_protoTree , & & sdr_write_proto_as_restart use sdr_flooding_module , only : sdr_flood_tree use sdr_proto2treelm_module , only : sdr_temData_type , sdr_proto2treelm , & & sdr_dump_treelm use sdr_refinePT_module , only : sdr_refine_leaf , sdr_smooth_leaf , & & sdr_inHerit_distanceRefineObject use sdr_timer_module , only : sdr_addTimers , sdr_dumptimers implicit none ! ----------------------------------------------------------------------------- type ( sdr_confHead_type ) :: header !< global header variable type ( sdr_geometry_type ) :: geometry !< contains all geometry object type ( sdr_protoTree_type ) :: protoTree !< preliminary tree type ( sdr_temData_type ) :: temData !< TreElM data to produce ! ----------------------------------------------------------------------------- ! Initialize environment. call tem_start ( codeName = 'Seeder' , & & version = 'pre2.0' , & & general = header % general ) ! add a timer object to measure time in different steps of seeder call sdr_addTimers () if ( header % general % proc % rank == 0 ) then ! Initialize seeder screen and solveHead type. call sdr_init_global ( header % general % solver ) end if ! Load configuration data according to command line arguments. call sdr_load_config ( header , geometry ) ! Build the preliminary prototree to narrow down the boundaries of the ! computational domain down to the desired resolution. call sdr_build_protoTree ( protoTree , geometry , header ) !copy bounding cube info to temData temData % meshUniverse % global % origin = geometry % universe % origin temData % meshUniverse % global % BoundingCubeLength = geometry % universe % extent if ( main_debug % active ) & & call sdr_write_proto_as_restart ( protoTree , geometry , 0 , header ) ! Flood the prototree, starting from the seed, to identify all elements that ! are to be part of the computational domain. call sdr_flood_tree ( protoTree , geometry , header , temData % meshUniverse ) ! Dump proto tree if requested. if ( main_debug % active ) & & call sdr_write_proto_as_restart ( protoTree , geometry , 1 , header , & & 'flooded' ) ! Inherit intersected distance refine objects if ( protoTree % node % distanceRefine ) & & call sdr_inHerit_distanceRefineObject ( protoTree , geometry ) ! Refine protoTree leafs to its finest level defined by refinement ! object or minlevel call sdr_refine_leaf ( protoTree , geometry ) ! Dump proto tree if requested. ! Smooth protoTree to avoid level jump > 1 if ( geometry % smoothLevels ) then ! Dump protoTree before smooth setup if debug is active if ( main_debug % active ) & & call sdr_write_proto_as_restart ( protoTree , geometry , 2 , header , & & 'refined' ) call sdr_smooth_leaf ( protoTree , header , protoTree % nLevels ) end if ! Dump proto tree if requested. if ( main_debug % active ) & & call sdr_write_proto_as_restart ( protoTree , geometry , 100 , header , & & 'final' ) ! Everything is ready now to define the computational mesh itself. ! For this we have to refine within defined refinement objects and ! identify boundary conditions. call sdr_proto2treelm ( protoTree , geometry , temData , header ) ! Write the treelmesh and boundary list to disk. call sdr_dump_treelm ( temData , geometry , header ) ! stop seeder timer before dump timing call tem_stopTimer ( timerHandle = header % general % solver % timerHandle ) ! dump timers to timing output file call sdr_dumptimers ( general = header % general , & & nFluids = temData % treeID % nVals , & & nBnds = temData % BC_ID ( 1 )% nVals ) ! Finalize environment. call tem_finalize ( header % general ) end program seeder !>\\page sdr_algorithm Seeder Algorithm !!\\author Kannan Masilamani !! !! In a first step, Seeder will create a protoTree, that refines all domain !! boundaries with the required resolution. This is done iteratively level by !! level, and each node, that is intersected by a domain boundary is further !! refined on the next level, if the maximum level of all intersected objects !! or global minimum level is not reached yet. !! At the end of this process the boundaries of the domain are resolved as !! requested everywhere. !! !! After the boundaries are properly resolved, it needs to be decided, what is !! actually part of the domain itself. For this elements are marked as flooded !! based upon their neighborhood. Obviously this only works properly if there !! is some initial starting point to get the flooding running. This is achieved !! by the user defined seed objects, which will mark all the elements that they !! intersect as flooded initially, as long as the elements do not intersect !! boundaries at the same time. Elements which intersect boundaries are never !! flooded!. !! !! Before flooding, the neighbors of each leaf node is identified for !! each node faces which is necassary for flooding to find the state of !! neighbor node. !! !! This flooding is done iteratively until a iteration did not change any !! element state anymore. All flooded elements identify the computational !! domain now. !! !! Finally the computational domain is refined to the desired level everywhere, !! as given by refinement objects or the global minimal refinement level and !! boundary conditions are assigned. !! This data is then written in treelm format to disk at the location, specified !! by the user in the configuration file. Note, that if this is a directory, !! you should not forget the trailing path separator in the definition and !! create the directory beforehand. !>\\page Boundary conditions !! !! Boundary conditions are defined by the label attached to a boundary object. !! Multiple boundary objects might have the same label and therefore attached !! to the same boundary condition. !! If there are multiple boundaries in a given direction of an element, the !! one defined first in the configuration, will be used. This allows you to !! set the precedence order of boundaries that should be used at any !! intersections. !! !! Only boundary labels that actually appear in the final mesh will be written !! to the header description of the boundaries in the mesh. !>\\page Colored seeds !! !! Seeds might have colors and thereby define different areas within the mesh. !! This is for example useful to ascribe special material parameters to parts !! of the domain. !! Each colored seed is bounded by a boundary of the same color, or boundaries !! which have the color 'none' or 'all'. !! Elements which have a non 'none' color attached to them will have the !! isColored property and the additional property information about which colors !! are attached to that element will be stored. !! There might be an arbitrary number of colors and multiple colors can be !! assigned to each element. !! Color names can be chosen arbitrarily and are case insensitive. !! !! We achieve this by using a bitfield for each color and basically do the !! flooding for each color. With up to three colors there should be little to !! no memory overhead imposed by this approach, as each color requires only one !! byte in the integer bitfield, that we use (the last byte is reserved for !! general node information). Beyond that additional integers will be used as !! needed by the number of colors. !! In the mesh on the disk, colors are stored in ASCII characters with 7 colors !! per byte, and meshes without coloring ('none' color everywhere as only color) !! no color information will be written at all. !! !! Note: colored boundaries are subject to the same rules of boundary labels !! as none colored boundaries and if they intersect with none colored boundaries !! will take precedence over those, if configured first. !! As this is typically not desired, you probably want to define your colored !! boundary objects after the none colored ones! !>\\page Subresolved boundaries !! !! Boundaries with a color might be resolved beyond the stair-case representation !! offered by the mesh by creating a polynomial representation of the color !! values within the intersected elements. !! For this you need to define a subresolution table, describing at least the !! polynomial degree that should be used for this information. !! When this table is defined, you can indicate that a (colored) boundary is to !! be subresolved by stating 'subresolution = true' in its attribute. !! !! Polynomial information will be created per color and is accessible as a !! property in the mesh afterwards. !>\\page Distance refinement !! !! !>\\page Smoothing !> \\page special Special geometries !! Seeder can create some special geometries. !! Currently is supports only one special geometry, spacer. !! \\li \\ref spacers \"Spacers\" !! !> \\example testsuite/plane/seeder.lua","tags":"","url":"sourcefile/seeder.f90.html"},{"title":"ply_filter_element_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_filter_element_module.f90~~AfferentGraph sourcefile~ply_filter_element_module.f90 ply_filter_element_module.f90 sourcefile~ply_sampling_adaptive_module.f90 ply_sampling_adaptive_module.f90 sourcefile~ply_sampling_adaptive_module.f90->sourcefile~ply_filter_element_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019 Harald Klimach <harald.klimach@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> This module provides methods to filter polynomial representation in !! elements based on their shape. !! !! The main goal of this filtering is to smooth out Gibbs oscillations while !! maintaining the strong gradients at discontinuities. module ply_filter_element_module use env_module , only : rk , labelLen use aotus_module , only : flu_State , aot_get_val use aot_table_module , only : aot_table_open , aot_table_close use aot_err_module , only : aoterr_fatal use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_tools_module , only : upper_to_lower implicit none private public :: ply_filter_element public :: ply_filter_element_oddfract public :: ply_filter_element_type public :: ply_filter_element_load integer , parameter :: filter_strat_none = 0 integer , parameter :: filter_strat_oddfract = 1 !> Paramaters describing the filtering to apply to elemental polynomial data. type ply_filter_element_type !> Filter strategy to use. integer :: strategy = filter_strat_none !> Maximal order for exponential spectral filtering to use !! where little filtering is to be done. integer :: max_order !> Minimal order for exponential spectral filtering to use. integer :: min_order !> Exponent to use for the fraction. integer :: fract_exponent !> Function pointer for 1D filtering procedure ( ply_filter_element ), pointer :: filter1D => NULL () !> Function pointer for 2D filtering procedure ( ply_filter_element ), pointer :: filter2D => NULL () !> Function pointer for 3D filtering procedure ( ply_filter_element ), pointer :: filter3D => NULL () end type ply_filter_element_type abstract interface !> Filter the polynomial data in a given element. subroutine ply_filter_element ( me , element_degree , element_data ) ! -------------------------------------------------------------------- ! import :: rk , ply_filter_element_type !> Parameters of the filter. class ( ply_filter_element_type ), intent ( in ) :: me !> Polynomial degree in the parent element. integer , intent ( in ) :: element_degree !> Polynomial data in element. The first index describes the !! degrees of freedom. The second index refers to the elements to filter. real ( kind = rk ), intent ( inout ) :: element_data (:,:) ! -------------------------------------------------------------------- ! end subroutine ply_filter_element end interface contains ! ------------------------------------------------------------------------ ! !> Loading parameters for the filtering from the configuration script. !! This needs to be performed before any call of the actual transformation !! [[ply_split_element_1D]]. !! !! The initialization will compute the transformation matrix for Legendre !! polynomials with at least nMaxModes. If the initialization was already !! called before with the same or larger nMaxModes, the matrix will not be !! changed. Thus, calling this routine will only increase the size of the !! module variable split_legendre, never decrease it. subroutine ply_filter_element_load ( me , conf , parent ) ! -------------------------------------------------------------------- ! !> Data structure that holds the filter parameters. type ( ply_filter_element_type ), intent ( out ) :: me !> Lua script to get the filter parameters from. type ( flu_state ) :: conf !> Table handle to a possible parent, that contains the filter table !! to load. integer , optional , intent ( in ) :: parent ! -------------------------------------------------------------------- ! integer :: thandle character ( len = labelLen ) :: stratname integer :: iError ! -------------------------------------------------------------------- ! nullify ( me % filter1D ) nullify ( me % filter2D ) nullify ( me % filter3D ) call aot_table_open ( L = conf , & & parent = parent , & & thandle = thandle , & & key = 'filter_element' ) call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'strategy' , & & val = stratname , & & ErrCode = iError , & & default = 'none' ) me % strategy = filter_strat_none stratname = upper_to_lower ( trim ( stratname )) select case ( trim ( stratname )) case ( 'oddfract' ) me % strategy = filter_strat_oddfract case ( 'none' ) me % strategy = filter_strat_none case default write ( logunit ( 1 ), * ) 'ERROR: Strategy ' , trim ( stratname ), ' for filter' & & // ' element not known!' write ( logunit ( 1 ), * ) 'Available options are:' write ( logunit ( 1 ), * ) '* oddfract: filter based on the fraction of odd' write ( logunit ( 1 ), * ) '            modes in the spectral energy' write ( logunit ( 1 ), * ) '* none: deactivate element filtering' call tem_abort () end select select case ( me % strategy ) case ( filter_strat_oddfract ) ! Get parameters for the odd mode fraction filtering strategy. call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'max_order' , & & val = me % max_order , & & ErrCode = iError , & & default = 10 ) if ( btest ( iError , aoterr_Fatal ) ) then write ( logunit ( 1 ), * ) 'ERROR: max_order for filter_element needs to be' & & // ' an integer!' write ( logunit ( 1 ), * ) 'You provided max_order but not in a form that' & & // ' could be interpreted as a number.' write ( logunit ( 1 ), * ) 'Aborting the execution, please check your config!' call tem_abort () end if call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'min_order' , & & val = me % min_order , & & ErrCode = iError , & & default = 2 ) if ( btest ( iError , aoterr_Fatal ) ) then write ( logunit ( 1 ), * ) 'ERROR: min_order for filter_element needs to be' & & // ' an integer!' write ( logunit ( 1 ), * ) 'You provided min_order but not in a form that' & & // ' could be interpreted as a number.' write ( logunit ( 1 ), * ) 'Aborting the execution, please check your config!' call tem_abort () end if call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'fract_exponent' , & & val = me % fract_exponent , & & ErrCode = iError , & & default = 2 ) if ( btest ( iError , aoterr_Fatal ) ) then write ( logunit ( 1 ), * ) 'ERROR: fract_exponent for filter_element needs' & & // ' to be an integer!' write ( logunit ( 1 ), * ) 'You provided fract_exponent but not in a form' & & // ' that could be interpreted as a number.' write ( logunit ( 1 ), * ) 'Aborting the execution, please check your config!' call tem_abort () end if write ( logunit ( 3 ), * ) 'Using element filtering with the odd fraction' write ( logunit ( 3 ), * ) 'strategy of data before each refinement.' write ( logunit ( 3 ), * ) 'Following parameters are used:' write ( logunit ( 3 ), * ) '* min_order=' , me % min_order write ( logunit ( 3 ), * ) '* max_order=' , me % max_order write ( logunit ( 3 ), * ) '* fract_exponent=' , me % fract_exponent me % filter1D => ply_filter_oddfract_1D me % filter2D => ply_filter_oddfract_2D me % filter3D => ply_filter_oddfract_3D end select call aot_table_close ( L = conf , & & thandle = thandle ) end subroutine ply_filter_element_load ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Filter a polynomial representation in elements in one dimension according !! to its odd mode fraction. !! !! Odd and even modes are weighed with their polynomial degree (so it's a !! little like actually using the derivative), squared and summed !! respectively. !! We then compute a spectral damping order with fraction of the odd mode !! energy in the total modal energy. The larger the fraction, the larger !! damping order and the weaker the filtering. !! `uscale` is given by `(me%max_order-me%min_order+1)`. !! `odd_fraction` is given by `odd / (odd+even)` and the damping order is !! then computed by `me%min_order + floor(uscale * odd_fraction**me%fract_ex)` !! The `fract_exponent` provides a mechanism to take larger odd fractions !! stronger into account than smaller ones. !! !! As we need to perform this operation in all dimensions, it would be good !! to shift the indices around. When doing this, we can stick to the same !! implementation for all directions, without the need to put any logic in !! here to decide on the current direction. !! In 3D we would end up with this chain: !! (x,y,z) -> filter_element for Z -> (z,x,y) !!         -> filter_element for Y -> (y,z,x) !!         -> filter_element for X -> (x,y,z) !! Thus, the logic is that we perform the filter on the last dimension, and !! cycle the indices in the output. !! !! We can generalize this to arbitrary dimensions. !! In 2D it would look like this: !! (x,y) -> filter_element for Y -> (y,x) !!       -> filter_element for X -> (x,y) !! And in 1D, we just need to perform one transformation: !! (x) -> filter_element for X -> (x) !! !! We need: nDofs in the direction where the transformation is to be done !!          and the nDofs for all normal directions. subroutine ply_filter_element_oddfract ( me , nDims , inLen , element_data , & & filtered_data ) ! -------------------------------------------------------------------- ! !> Filter parameters. class ( ply_filter_element_type ), intent ( in ) :: me !> Number of dimensions of the polynomial data. integer , intent ( in ) :: nDims !> Number degrees of freedom for each direction in element_data. !! !! The first index of element_data needs to have a length equal to the !! product of all inLen components. !! The splitting operation will be done in the last dimension. integer , intent ( in ) :: inLen ( nDims ) !> Polynomial representation in the elements. !! !! The first index are the degrees of freedom in elements, the second index !! are the elements. !! In the first index the shape of data has to be in the form !! (inLen(1), inLen(2), ... , inLen(nDims)). !! The filtering operation is performed on the last dimension in that !! data. real ( kind = rk ), intent ( in ) :: element_data (:,:) !> The filtered polynomial modes. !! !! The ordering is rotated, such, that the filtered dimension becomes the !! first one, and all others are shifted by one to the right. !! Thus, the new data has the layout (inLen(nDims), inLen(1), inLen(2), ...) real ( kind = rk ), intent ( out ) :: filtered_data (:,:) ! -------------------------------------------------------------------- ! integer :: iDir integer :: iParent integer :: parentMode integer :: maxcol integer :: indep integer :: nIndeps integer :: nParents integer :: parentpos , filterpos integer :: upper_scale real ( kind = rk ) :: dof_fract real ( kind = rk ) :: damping real ( kind = rk ), allocatable :: even (:,:) real ( kind = rk ), allocatable :: odd (:,:) real ( kind = rk ) :: spenergy integer , allocatable :: damp_ord (:,:) ! -------------------------------------------------------------------- ! nParents = size ( element_data , 2 ) ! The number of independent modes (in normal directions) is given ! by the product of the length in all directions, except the last one. nIndeps = 1 do iDir = 1 , nDims - 1 nIndeps = nIndeps * inLen ( iDir ) end do maxcol = inLen ( nDims ) allocate ( damp_ord ( nIndeps , nParents )) allocate ( even ( nIndeps , nParents )) allocate ( odd ( nIndeps , nParents )) even = 0.0_rk odd = 0.0_rk parmodes : do parentMode = 2 , maxcol - 1 , 2 do iParent = 1 , nParents do indep = 1 , nIndeps parentpos = indep + nIndeps * ( parentMode - 1 ) odd ( indep , iParent ) = odd ( indep , iParent ) & & + ( ( parentMode - 1 ) & & * element_data ( parentpos , iParent ) & & ) ** 2 even ( indep , iParent ) = even ( indep , iParent ) & & + ( ( parentMode - 1 ) & & * element_data ( parentpos + nIndeps , iParent ) & & ) ** 2 end do end do end do parmodes if (( mod ( maxcol , 2 ) == 0 )) then do iParent = 1 , nParents do indep = 1 , nIndeps parentpos = indep + nIndeps * ( maxcol - 1 ) even ( indep , iParent ) = even ( indep , iParent ) & & + ( ( parentMode - 1 ) & & * element_data ( parentpos , iParent ) & & ) ** 2 end do end do end if upper_scale = me % max_order - me % min_order + 1 do iParent = 1 , nParents do indep = 1 , nIndeps spenergy = even ( indep , iParent ) + odd ( indep , iParent ) if ( spenergy > epsilon ( damping ) ** 2 ) then damp_ord ( indep , iParent ) = me % min_order & & + floor ( upper_scale & & * ( odd ( indep , iParent ) & & / spenergy ) ** me % fract_exponent ) else damp_ord ( indep , iParent ) = me % max_order end if end do end do oldmodes : do parentMode = 1 , maxcol dof_fract = real ( parentMode - 1 , kind = rk ) / real ( max ( maxcol - 1 , 1 ), kind = rk ) elemloop : do iParent = 1 , nParents do indep = 1 , nIndeps parentpos = indep + nIndeps * ( parentMode - 1 ) filterpos = parentMode + maxcol * ( indep - 1 ) spenergy = even ( indep , iParent ) + odd ( indep , iParent ) if ( spenergy > epsilon ( damping ) ** 2 ) then damp_ord = me % min_order & & + floor ( ( me % max_order + 1 ) & & * ( odd ( indep , iParent ) & & / spenergy ) ** me % fract_exponent ) else damp_ord = me % max_order end if damping = exp ( - 36 * ( dof_fract ** damp_ord ( indep , iParent ))) filtered_data ( filterpos , iParent ) = damping & & * element_data ( parentpos , iParent ) end do end do elemloop end do oldmodes deallocate ( damp_ord ) deallocate ( even ) deallocate ( odd ) end subroutine ply_filter_element_oddfract ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Filter one-dimensional elements of degree element_degree. subroutine ply_filter_oddfract_1D ( me , element_degree , element_data ) ! -------------------------------------------------------------------- ! !> Filter parameters. class ( ply_filter_element_type ), intent ( in ) :: me !> Polynomial degree in the parent element. integer , intent ( in ) :: element_degree !> Polynomial data in the parent element. The first index describes the !! degrees of freedom. The second index refers to the elements to split. real ( kind = rk ), intent ( inout ) :: element_data (:,:) ! -------------------------------------------------------------------- ! integer :: pardofs real ( kind = rk ), allocatable :: filtered_data (:,:) ! -------------------------------------------------------------------- ! pardofs = element_degree + 1 allocate ( filtered_data ( pardofs , size ( element_data , 2 )) ) call ply_filter_element_oddfract ( me = me , & & nDims = 1 , & & inLen = [ pardofs ], & & element_data = element_data , & & filtered_data = filtered_data ) element_data = filtered_data deallocate ( filtered_data ) end subroutine ply_filter_oddfract_1D ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Filter two-dimensional elements of degree element_degree. subroutine ply_filter_oddfract_2D ( me , element_degree , element_data ) ! -------------------------------------------------------------------- ! !> Filter parameters. class ( ply_filter_element_type ), intent ( in ) :: me !> Polynomial degree in the parent element. integer , intent ( in ) :: element_degree !> Polynomial data in the parent element. The first index describes the !! degrees of freedom. The second index refers to the elements to split. real ( kind = rk ), intent ( inout ) :: element_data (:,:) ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: ysplit (:,:) integer :: pardofs ! -------------------------------------------------------------------- ! pardofs = element_degree + 1 allocate ( ysplit ( pardofs * pardofs , size ( element_data , 2 ))) call ply_filter_element_oddfract ( me = me , & & nDims = 2 , & & inLen = [ pardofs , pardofs ], & & element_data = element_data , & & filtered_data = ysplit ) call ply_filter_element_oddfract ( me = me , & & nDims = 2 , & & inLen = [ pardofs , pardofs ], & & element_data = ysplit , & & filtered_data = element_data ) deallocate ( ysplit ) end subroutine ply_filter_oddfract_2D ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Filter three-dimensional elements of degree element_degree. subroutine ply_filter_oddfract_3D ( me , element_degree , element_data ) ! -------------------------------------------------------------------- ! !> Filter parameters. class ( ply_filter_element_type ), intent ( in ) :: me !> Polynomial degree in the parent element. integer , intent ( in ) :: element_degree !> Polynomial data in the parent element. The first index describes the !! degrees of freedom. The second index refers to the elements to split. real ( kind = rk ), intent ( inout ) :: element_data (:,:) ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: ysplit (:,:) integer :: pardofs ! -------------------------------------------------------------------- ! pardofs = element_degree + 1 allocate ( ysplit ( pardofs * pardofs , size ( element_data , 2 ))) call ply_filter_element_oddfract ( me = me , & & nDims = 3 , & & inLen = [ pardofs , pardofs , & & pardofs ], & & element_data = element_data , & & filtered_data = ysplit ) call ply_filter_element_oddfract ( me = me , & & nDims = 3 , & & inLen = [ pardofs , pardofs , & & pardofs ], & & element_data = ysplit , & & filtered_data = element_data ) call ply_filter_element_oddfract ( me = me , & & nDims = 3 , & & inLen = [ pardofs , pardofs , & & pardofs ], & & element_data = element_data , & & filtered_data = ysplit ) element_data = ysplit deallocate ( ysplit ) end subroutine ply_filter_oddfract_3D ! ======================================================================== ! end module ply_filter_element_module","tags":"","url":"sourcefile/ply_filter_element_module.f90.html"},{"title":"ply_LegPolyProjection_module.f90 – Seeder","text":"Source Code ! Copyright (c) 2016 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! Copyright (c) 2017 Daniel Petró <daniel.petro@student.uni-siegen.de> ! Copyright (c) 2017, 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2018 Raphael Haupt <Raphael.Haupt@student.uni-siegen.de> ! ! Parts of this file were written by Daniel Fleischer, Daniel Petró, Peter Vitt ! and Raphael Haupt for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Module for projection of Q Legendre Polynomials from parent cell !! to child cells. !! module ply_LegPolyProjection_module ! include treelm modules use env_module , only : rk use tem_param_module , only : PI use tem_aux_module , only : tem_abort use treelmesh_module , only : treelmesh_type use tem_param_module , only : childPosition implicit none private public :: ply_gauleg ! ************************************************************************ ! !> Parameter to specify Legendre polynomials as the degrees of freedoms !! of the elements. The multidimensional polynomias are build as !! Q-polynomials. !! The projection is a L2-Projection onto the ansatz function of the finer !! elements. integer , parameter :: ply_QLegendrePoly_prp = 1 ! ************************************************************************ ! ! ************************************************************************ ! !> Datatype storing the coefficients arising for the projection !! of solutions on a parent cell to its children during the subsampling !! routines. type ply_ProjCoeff_type !> Array holding all the projection coefficients for the projection !! of a degree of freedom on the parent element (first index) to !! a degree of freedom on the child element (second index) for !! a given child element (third index). !! Therefore the dimension of this array is (nDofs, nDofs, 8). real ( kind = rk ), allocatable :: projCoeff (:,:,:) end type ply_ProjCoeff_type ! ************************************************************************ ! ! ************************************************************************ ! type ply_subsample_type !> Is subsampling active logical :: isActive = . false . !> The current sampling lvl. integer :: sampling_lvl !> The type of projection we use to subsample the elemental data. integer :: projectionType = ply_QLegendrePoly_prp !> Maximal Level down to which subsampling should be done. integer :: caplevel = 20 !> Minimal subsampling depth: integer :: minsub = 0 !> Maximal subsampling depth: integer :: maxsub = 0 !> Maximum allowed oscillation of the solution. !! For adaptive subsampling only. real ( kind = rk ) :: eps_osci !> Factor for the reduction of the degrees of freedom in one subsampling !! step (per spatial direction). real ( kind = rk ) :: dofReducFactor !> Indicator for limitation of total memory consumption logical :: adaptiveDofReduction !> Absolute upper bound level to refine to. integer :: AbsUpperBoundLevel end type ply_subsample_type ! ************************************************************************ ! ! ************************************************************************ ! type ply_array_type real ( kind = rk ), allocatable :: dat (:) end type ply_array_type ! ************************************************************************ ! public :: ply_subsample_type public :: ply_QPolyProjection public :: ply_array_type contains ! ************************************************************************ ! !> Subsampling by L2-Projection of the Q-Tensorproduct Legendre polynomials. subroutine ply_QPolyProjection ( subsamp , dofReduction , tree , meshData , & & varDofs , ndims , varcomps , refine_tree , & & new_refine_tree , newMeshData , newVarDofs ) ! -------------------------------------------------------------------- ! !> Parameters for the subsampling. type ( ply_subsample_type ), intent ( in ) :: subsamp !> Factor for reducion of degrees of freedom. real ( kind = rk ), intent ( in ) :: dofReduction (:) !> The tree the data is written for. type ( treelmesh_type ), intent ( in ) :: tree !> The data to sub-sample. type ( ply_array_type ), intent ( in ) :: meshData (:) !> The number of degrees of freedom for each scalar variable. integer , intent ( in ) :: varDofs (:) !> Number of dimensions in the polynomial representation. integer , intent ( in ) :: ndims !> Number of components integer , intent ( in ) :: varcomps (:) !> Logical array that marks elements for refinement from the last sampling ! level. logical , intent ( in ) :: refine_tree (:) !> Logical array that marks elements for refinment. logical , intent ( in ) :: new_refine_tree (:) !> The subsampled data. type ( ply_array_type ), allocatable , intent ( out ) :: newMeshData (:) !> The number of dofs for the subsampled dofs. integer , allocatable , intent ( out ) :: newVarDofs (:) ! -------------------------------------------------------------------- ! integer :: nChilds , nVars , nDofs , nComponents integer :: iVar type ( ply_ProjCoeff_type ) :: projection type ( ply_ProjCoeff_type ) :: projection_oneDof ! Working tree and working data real ( kind = rk ), allocatable :: workDat (:) real ( kind = rk ), allocatable :: newWorkDat (:) integer :: nChildDofs , oneDof ! -------------------------------------------------------------------- ! if ( subsamp % projectionType . ne . ply_QLegendrePoly_prp ) then call tem_abort ( 'ERROR in ply_QPolyProjection: subsampling is ' & & // 'only implemented for Q-Legendre-Polynomials' ) end if nVars = size ( varDofs ) allocate ( newVarDofs ( nVars )) allocate ( newMeshData ( nVars )) varLoop : do iVar = 1 , nVars nDofs = varDofs ( iVar ) nComponents = varcomps ( iVar ) allocate ( workDat ( size ( meshData ( iVar )% dat ))) workDat = meshData ( iVar )% dat ! All elements in refine_tree marked with .TRUE. will get ! a projection to the next sampling level while all other elements ! will get their integral mean value ( projection till there is only ! one dof left ) ! Reduce the number of dofs per direction in each subsample nChildDofs = ( ceiling ( nint ( nDofs ** ( 1.0_rk / real ( ndims , kind = rk ))) & & * dofReduction ( iVar ))) ** nDims if ( nChildDofs > nDofs ) then nChildDofs = nDofs elseif ( nChildDofs < 1 ) then nChildDofs = 1 end if if ( subsamp % sampling_lvl == subsamp % maxsub ) then nChildDofs = 1 end if ! Set the correct number of Childs for the projection to reduced Dofs. nChilds = 2 ** ndims ! init the projection coefficients for the current number of child dofs. call ply_initQLegProjCoeff ( doftype = subsamp % projectionType , & & nDofs = nDofs , & & ndims = ndims , & & nChilds = nChilds , & & nChildDofs = nChildDofs , & & projection = projection ) ! init the projection coefficients for the reduction to polynomial ! degree of 0. oneDof = 1 ! Set the correct number of childs for the projection to one dof. nChilds = 1 call ply_initQLegProjCoeff ( doftype = subsamp % projectionType , & & ndofs = nDofs , & & ndims = ndims , & & nChilds = nChilds , & & nChildDofs = oneDof , & & projection = projection_oneDof ) ! ... subsample the data call ply_subsampleData ( tree = tree , & & meshData = workDat , & & nDofs = nDofs , & & nChildDofs = nChildDofs , & & nComponents = nComponents , & & projection = projection , & & projection_oneDof = projection_oneDof , & & refine_tree = refine_tree , & & new_refine_tree = new_refine_tree , & & ndims = ndims , & & subsamp = subsamp , & & newMeshData = newWorkDat ) allocate ( newMeshData ( iVar )% dat ( size ( newWorkDat ))) newMeshData ( iVar )% dat = newWorkDat newVarDofs ( iVar ) = nChildDofs deallocate ( workDat ) deallocate ( projection % projCoeff ) deallocate ( projection_oneDof % projCoeff ) end do varLoop end subroutine ply_QPolyProjection ! ************************************************************************ ! ! ************************************************************************ ! !> Routine to initialize the projection coefficients for a usage in the !! subsampling routine to project degrees of freedoms of a parent cell !! to the degrees of freedoms of a child cell if the degrees of !! freedoms are Q-Legendre polynomials. subroutine ply_initQLegProjCoeff ( doftype , nDofs , ndims , nChilds , & & nChildDofs , projection ) ! -------------------------------------------------------------------- ! !> The type of degrees of freedom we have in our cells. integer , intent ( in ) :: dofType !> The number of degrees of freedom for the parent cells. integer , intent ( in ) :: nDofs !> The  number of dimensions in the polynomial representation. integer , intent ( in ) :: ndims !> The number of child cells. integer , intent ( in ) :: nChilds !> The number of degrees of freedom for the child cells. integer , intent ( in ) :: nChildDofs !> The subsampling coefficients that will be initialized by this routine. type ( ply_ProjCoeff_type ), intent ( out ) :: projection ! -------------------------------------------------------------------- ! integer :: iParentDof , iChildDof , iChild integer :: xShift , yShift , zShift integer :: xParentAnsFunc , yParentAnsFunc , zParentAnsFunc integer :: xChildAnsFunc , yChildAnsFunc , zChildAnsFunc ! First index is Legendre polynomial on the parent element, second index ! is the Legendre polynomial on the child element, third index is left ! or right projection. real ( kind = rk ), allocatable :: projCoeffOneDim (:,:,:) real ( kind = rk ) :: dimexp ! -------------------------------------------------------------------- ! select case ( dofType ) case ( ply_QLegendrePoly_prp ) allocate ( projection % projCoeff ( nDofs , nChildDofs , nChilds )) projection % projCoeff = 0.0_rk ! Create projection of one-dimensional Legendre polynomials for the ! reference interval [-1,+1]  (child-element) and the double length ref ! element [-1,+3] (parent element). dimexp = 1.0_rk / real ( ndims , kind = rk ) projCoeffOneDim = ply_QLegOneDimCoeff ( nint ( nDofs ** dimexp ), & & nint ( nChildDofs ** dimexp ) ) ! Loop over the children of this element childLoop : do iChild = 1 , nChilds ! get the right index for the x,y,z shift of the current child with ! respect to the parent cell. if ( childPosition ( iChild , 1 ). eq . - 1 ) then xShift = 1 else xShift = 2 end if if ( childPosition ( iChild , 2 ). eq . - 1 ) then yShift = 1 else yShift = 2 end if if ( childPosition ( iChild , 3 ). eq . - 1 ) then zShift = 1 else zShift = 2 end if ! Loop over the parent dofs and calculate the projection coefficients ! for each of the child dofs parentDofLoop : do iParentDof = 1 , nDofs ! convert the number of the parent dof to ansatz function numbers in ! the spatial direction. call ply_dofToQPoly ( dof = iParentDof , & & nDofs = nDofs , & & ndims = ndims , & & xAnsFunc = xParentAnsFunc , & & yAnsFunc = yParentAnsFunc , & & zAnsFunc = zParentAnsFunc ) childDofLoop : do iChildDof = 1 , nChildDofs ! convert the number of the child dof to ansatz function numbers in ! the spatial direction. call ply_dofToQPoly ( dof = iChildDof , & & nDofs = nChildDofs , & & ndims = ndims , & & xAnsFunc = xChildAnsFunc , & & yAnsFunc = yChildAnsFunc , & & zAnsFunc = zChildAnsFunc ) ! reuse the one-dimensional projection coefficients to build up the ! 3D projection % projCoeff ( iParentDof , iChildDof , iChild ) & & = projCoeffOneDim ( xParentAnsFunc , xChildAnsFunc , xShift ) & & * projCoeffOneDim ( yParentAnsFunc , yChildAnsFunc , yShift ) & & * projCoeffOneDim ( zParentAnsFunc , zChildAnsFunc , zShift ) end do childDofLoop end do parentDofLoop end do childLoop case default call tem_abort ( 'ERROR in ply_initProjCoeff: initialization of ' & & // 'projection coefficients for subsampling is implemented only ' & & // 'for Q-Legendre polynomials' ) end select deallocate ( projCoeffOneDim ) end subroutine ply_initQLegProjCoeff ! ************************************************************************ ! ! ************************************************************************ ! !> Routine to create one-dimensional projection coefficient for a coarse !! element to a fine element. function ply_QLegOneDimCoeff ( nDofsOneDim , nChildDofsOneDim ) & & result ( projCoeffOneDim ) ! -------------------------------------------------------------------- ! !> The number of dofs in one dimension. integer , intent ( in ) :: nDofsOneDim !> The number of dofs in one dimension for the children. integer , intent ( in ) :: nChildDofsOneDim !> Projected one-dimensional coefficients. !! !! First index is Legendre polynomial on the parent element, second index !! is the Legendre polynomial on the child element, third index is left !! or right projection. real ( kind = rk ), allocatable :: projCoeffOneDim (:,:,:) ! -------------------------------------------------------------------- ! integer :: nIntP , iParentFunc , iChildFunc real ( kind = rk ), allocatable :: points (:), weights (:), & & pointsLeft (:), pointsRight (:), & & parentFuncVal (:,:), childFuncVal (:,:) ! -------------------------------------------------------------------- ! allocate ( projCoeffOneDim ( nDofsOneDim , nChildDofsOneDim , 2 )) ! Create the gauss legendre quadrature points for the reference element ! [-1,+1] nIntP = ceiling (( max ( nDofsOneDim , nChildDofsOneDim ) ) / 2.0 ) ** 2 call ply_gauleg ( - 1.0_rk , + 1.0_rk , points , weights , nIntP ) ! Now, project ansatz function of the parent for the left child. ! We apply a Gaussian quadrature and take case of composition of ! the mapping from reference to physical element (for child and ! parent). ! So, we evaluate the parent Legendre polynomial at shifted quadrature ! points ( shifted by 0.5 x - 0.5 ) and evaluate the child Legendre ! quadrature points at the original Gauss-Legendre points. allocate ( pointsLeft ( size ( points )) ) pointsLeft (:) = 0.5_rk * points (:) - 0.5_rk parentFuncVal = ply_legVal ( pointsLeft , nIntP , nDofsOneDim - 1 ) childFuncVal = ply_legVal ( points , nIntP , nChildDofsOneDim - 1 ) do iParentFunc = 1 , nDofsOneDim do iChildFunc = 1 , nChildDofsOneDim ! ... calculate the integral by the quadrature rule. projCoeffOneDim ( iParentFunc , iChildFunc , 1 ) & & = sum ( weights (:) * parentFuncVal ( iParentFunc ,:) & & * childFuncVal ( iChildFunc ,:) ) ! ... and normalize by the norm of the child function. projCoeffOneDim ( iParentFunc , iChildFunc , 1 ) & & = projCoeffOneDim ( iParentFunc , iChildFunc , 1 ) & & * ( 1.0_rk / ply_QLegSqNorm ( iChildFunc )) end do end do deallocate ( parentFuncVal ) deallocate ( childFuncVal ) deallocate ( pointsLeft ) ! now, project ansatz function of the parent for the right child. We apply ! the same procedure as for the left child, but with a different shift of ! the quadrautre point for the parent function. allocate ( pointsRight ( size ( points )) ) pointsRight (:) = 0.5_rk * points (:) + 0.5_rk parentFuncVal = ply_legVal ( pointsRight , nIntP , nDofsOneDim - 1 ) childFuncVal = ply_legVal ( points , nIntP , nChildDofsOneDim - 1 ) do iParentFunc = 1 , nDofsOneDim do iChildFunc = 1 , nChildDofsOneDim ! ... calculate the integral by the quadrature rule. projCoeffOneDim ( iParentFunc , iChildFunc , 2 ) & & = sum ( weights (:) * parentFuncVal ( iParentFunc ,:) & & * childFuncVal ( iChildFunc ,:) ) ! ... and normalize by the norm of the child function. projCoeffOneDim ( iParentFunc , iChildFunc , 2 ) & & = projCoeffOneDim ( iParentFunc , iChildFunc , 2 ) & & * ( 1.0_rk / ply_QLegSqNorm ( iChildFunc )) end do end do deallocate ( parentFuncVal ) deallocate ( childFuncVal ) deallocate ( pointsRight ) end function ply_QLegOneDimCoeff ! ************************************************************************ ! ! ************************************************************************ ! !> Function to calculate the squared L2-Norm of a given Legendre polynomial !! on the reference element [-1,+1]. function ply_QLegSqNorm ( polyIndex ) result ( sqNorm ) ! -------------------------------------------------------------------- ! !> The Legendre polynomial index to calculate the squared norm for. !! The first polynomial has index 1. integer , intent ( in ) :: polyIndex !> The squared L2 Norm of the Legendre polynomial. real ( kind = rk ) :: sqNorm ! -------------------------------------------------------------------- ! sqNorm = 2.0_rk / ( 2.0_rk * polyIndex - 1.0_rk ) end function ply_QLegSqNorm ! ************************************************************************ ! ! ************************************************************************ ! !> Evaluate a given set of Legendre polynomials a given set of 1D points. !! function ply_legVal ( points , nPoints , maxPolyDegree ) result ( val ) ! -------------------------------------------------------------------- ! !> A given set of 1D points. real ( kind = rk ), intent ( in ) :: points (:) !> The number of points to evaluate the polynomials at. integer , intent ( in ) :: nPoints !> The maximal polynomial degree to evaluate for. integer , intent ( in ) :: maxPolyDegree !> Function values for for all Legendre polynomials up to degree !! maxPolyDegree at all given points. !! Therefore the dimension of this array is (maxPolyDegree+1, nPoints) real ( kind = rk ), allocatable :: val (:,:) ! -------------------------------------------------------------------- ! integer :: iAns ! -------------------------------------------------------------------- ! allocate ( val ( maxPolyDegree + 1 , nPoints )) ! the first Legendre polynomial is constant. val ( 1 ,:) = 1.0_rk if ( maxPolyDegree > 0 ) then ! the second Legendre ploynomial is identity. val ( 2 ,:) = points (:) ! apply the recursion do iAns = 3 , maxPolyDegree + 1 val ( iAns ,:) = ( ( 2.0_rk * ( iAns - 1.0_rk ) - 1.0_rk ) & & * points (:) * val ( iAns - 1 ,:) & & - (( iAns - 1 ) - 1 ) & & * val ( iAns - 2 ,:) ) & & / ( iAns - 1 ) end do end if end function ply_legVal ! ************************************************************************ ! ! ************************************************************************ ! !> Subroutine to convert linearized dof index to ansatz function number for !! Q-Polynomials. subroutine ply_dofToQPoly ( dof , nDofs , ndims , xAnsFunc , yAnsFunc , zAnsFunc ) ! -------------------------------------------------------------------- ! !> The linearized degree of freedom index. integer , intent ( in ) :: dof !> The number of dofs for all directions. integer , intent ( in ) :: nDofs !> The number of Dimensions in the polynomial representation. integer , intent ( in ) :: ndims !> The ansatz function number in x direction. integer , intent ( out ) :: xAnsFunc !> The ansatz function number in y direction. integer , intent ( out ) :: yAnsFunc !> The ansatz function number in z direction. integer , intent ( out ) :: zAnsFunc ! -------------------------------------------------------------------- ! integer :: nDofsPerDir ! -------------------------------------------------------------------- ! ! The number of dofs in each direction nDofsPerDir = nint ( nDofs ** ( 1.0_rk / real ( ndims , kind = rk ))) ! now, we compute the ansatz function numbers ! Works for polynomials of all dimensionality, as dof will never reach ! sufficiently high values for lower dimensions. zAnsFunc = ( dof - 1 ) / ( nDofsPerDir ** 2 ) + 1 yAnsFunc = ( dof - 1 - ( zAnsFunc - 1 ) * ( nDofsPerDir ** 2 )) / nDofsPerDir + 1 xAnsFunc = dof - ( zAnsFunc - 1 ) * ( nDofsPerDir ** 2 ) - ( yAnsFunc - 1 ) * nDofsPerDir end subroutine ply_dofToQPoly ! ************************************************************************ ! ! ************************************************************************ ! !> Routine to subsample mesh information for one refinement level. subroutine ply_subsampleData ( tree , meshData , nDofs , nChildDofs , & & nComponents , projection , projection_oneDof , & & refine_tree , new_refine_tree , ndims , & & subsamp , newMeshData ) ! -------------------------------------------------------------------- ! !> The tree the data is written for. type ( treelmesh_type ), intent ( in ) :: tree !> The data to sub-sample. real ( kind = rk ), intent ( in ) :: meshData (:) !> The number of degrees of freedom for each scalar variable. integer , intent ( in ) :: nDofs !> The number of degrees of freedom per scalar variable on the child !! elements. integer , intent ( in ) :: nChildDofs !> Number of components integer , intent ( in ) :: nComponents !> Projection coefficients for the given data. type ( ply_ProjCoeff_type ), intent ( in ) :: projection !> Projection coeffiecients for the the reduction to polynomial !! degree of 0. type ( ply_ProjCoeff_type ), intent ( in ), optional :: projection_oneDof !> Logical array that marks all elements for refinement from the last !! sampling lvl. logical , intent ( in ), optional :: refine_tree (:) !> Logical array that marks all elements for refinement logical , intent ( in ) :: new_refine_tree (:) !> The number of dimensions in the polynomial representation. integer , intent ( in ) :: ndims !> Parameters for the subsampling. type ( ply_subsample_type ), intent ( in ) :: subsamp !> The subsampled data. real ( kind = rk ), allocatable , intent ( out ) :: newMeshData (:) ! -------------------------------------------------------------------- ! integer :: nElems , nChilds , nParentElems , nElemsToRefine , nElemsNotToRefine integer :: iElem , iParentElem , iChild integer :: lowElemIndex , upElemIndex , lowChildIndex , upChildIndex integer :: oneDof , noChilds , childpos real ( kind = rk ), allocatable :: childData (:) ! -------------------------------------------------------------------- ! nChilds = 2 ** ndims nElems = tree % nElems nElemsToRefine = count ( new_refine_tree ) nElemsNotToRefine = nElems - nElemsToRefine nParentElems = size ( refine_tree ) ! Now, we set the correct data for the newMeshData. allocate ( newMeshData (( nElemsToRefine * nChilds * nChildDofs & & + nElemsNotToRefine ) * nComponents )) newMeshData = 0.0_rk upChildIndex = 0 upElemIndex = 0 childPos = 0 if ( subsamp % sampling_lvl > 1 ) then elementLoop : do iParentElem = 1 , nParentElems ! Check if the parent cell was already refined... if ( refine_tree ( iParentElem )) then ! Parent cell was already refined so it contains data with nDofs childLoop : do iChild = 1 , nChilds childPos = childPos + 1 ! Check if the child elems will be refined... if ( new_refine_tree ( childPos )) then ! Child cell will be refined. ! ! Need to project current elem data to new childs with reduced ! dofs. allocate ( childData ( nChildDofs * nChilds * nComponents )) ! Create lower and upper indices for all data of iElem in ! meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Project these dofs from the coarse element to the ! finer elements. call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = nDofs , & & nChildDofs = nChildDofs , & & nComponents = nComponents , & & nChilds = nChilds , & & projection = projection , & & childData = childData ) ! Iterate over all childDofs and set the data corectly in ! newMeshData lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nChilds * nChildDofs & & * nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) else ! Child cell won't be refined. ! ! Need projecton from current dofs to 1 dof. allocate ( childData ( nComponents )) ! Create lower and upper indices for all data of iElem in ! meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Projection from nDofs to oneDof (integral mean valuea). oneDof = 1 noChilds = 1 call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = nDofs , & & nChildDofs = oneDof , & & nComponents = nComponents , & & nChilds = noChilds , & & projection = projection_oneDof , & & childData = childData ) ! Iterate over all childDofs and set the data corectly in ! newMeshData lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) end if end do childLoop else ! Parent cell wasn't refined so it contains data with only one dof ! left. ! Simple copying. allocate ( childData ( nComponents )) lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nComponents childData = meshData ( lowElemIndex : upElemIndex ) lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData childpos = childpos + 1 deallocate ( childData ) end if end do elementLoop else elemLoop : do iElem = 1 , nElems if ( new_refine_tree ( iElem )) then allocate ( childData ( nChildDofs * nChilds * nComponents )) ! Create lower and upper indices for all data of iElem in meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Project these dofs from the coarse element to the ! finer elements. call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = nDofs , & & nChildDofs = nChildDofs , & & nComponents = nComponents , & & nChilds = nChilds , & & projection = projection , & & childData = childData ) ! Iterate over all childDofs and set the data corectly in newMeshData lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nChilds * nChildDofs * nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) else allocate ( childData ( nComponents )) ! Create lower and upper indices for all data of iElem in meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Projection from nDofs to oneDof (integral mean valuea). oneDof = 1 noChilds = 1 call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = nDofs , & & nChildDofs = oneDof , & & nComponents = nComponents , & & nChilds = noChilds , & & projection = projection_oneDof , & & childData = childData ) ! Iterate over all childDofs and set the data corectly in newMeshData lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) end if end do elemLoop end if end subroutine ply_subsampleData ! ************************************************************************ ! ! ************************************************************************ ! !> Subroutine to project elemental data from a parent cell to one of !! its children. subroutine ply_projDataToChild ( parentData , nParentDofs , nChildDofs , & & nComponents , nChilds , projection , childData ) ! -------------------------------------------------------------------- ! !> Linearized data for a single variable (can have multiple components) !! and a single degree of freedom of the parent cell. real ( kind = rk ), intent ( in ) :: parentData (:) !> The number of dofs of the parent element. integer , intent ( in ) :: nParentDofs !> The total number of dofs for the child cells. integer , intent ( in ) :: nChildDofs !> The number of componentns of the given variable. integer , intent ( in ) :: nComponents !> The number of children. integer , intent ( in ) :: nChilds !> The information about the projection coefficients for the parent !! dofs to the child dofs. type ( ply_ProjCoeff_type ), intent ( in ) :: projection !> The created childData. real ( kind = rk ), intent ( out ) :: childData (:) ! -------------------------------------------------------------------- ! integer :: iChildDof , iComp , iChild , iParentDof integer :: childDof_pos , parentDof_pos real ( kind = rk ) :: projCoeff ! -------------------------------------------------------------------- ! childData (:) = 0.0_rk childLoop : do iChild = 1 , nChilds parentDofLoop : do iParentDof = 1 , nParentDofs childDofLoop : do iChildDof = 1 , nChildDofs ! Get the projection coefficient for iChild, parentDof and iChildDof. projCoeff = projection % projCoeff ( iParentDof , iChildDof , iChild ) compLoop : do iComp = 1 , nComponents ! Position of the child dof in childData. childDof_pos = iComp + ( iChildDof - 1 ) * nComponents & & + ( iChild - 1 ) * nChildDofs * nComponents ! Position of the parent dof in parentData. parentDof_pos = iComp + ( iParentDof - 1 ) * nComponents childData ( childDof_pos ) = childData ( childDof_pos ) & & + projCoeff * parentData ( parentDof_pos ) end do compLoop end do childDofLoop end do parentDofLoop end do childLoop end subroutine ply_projDataToChild ! ************************************************************************ ! ! ************************************************************************ ! !> subroutine to create gauss points and weights for one-dimensional !! integration on the interval [x1,x2]. subroutine ply_gauleg ( x1 , x2 , x , w , nIntP ) ! -------------------------------------------------------------------- ! !> The coordinates of the gauss points on the interval [-1,1]. !! The array has the length nIntP. real ( kind = rk ), allocatable , intent ( inout ) :: x (:) !> The quadrature weights. The array has the length nIntP. real ( kind = rk ), allocatable , intent ( inout ) :: w (:) !> The number of integration points. integer , intent ( in ) :: nIntP !> lower limit of integration interval real ( kind = rk ), intent ( in ) :: x1 !> upper limit of integration interval real ( kind = rk ), intent ( in ) :: x2 ! -------------------------------------------------------------------- ! ! some work variables real ( kind = rk ) :: z1 , z , xm , xl , pp , p3 , p2 , p1 ; ! the relative precision of the points real ( kind = rk ) :: EPS integer :: m , i , j ! -------------------------------------------------------------------- ! allocate ( x ( nIntP ), w ( nIntP )) EPS = 1.0 / ( 1 0.0 ** ( PRECISION ( 1.0_rk ) - 2 ) ) m = ( nIntP + 1 ) / 2 ; xm = 0.5 * ( x2 + x1 ); xl = 0.5 * ( x2 - x1 ); do i = 1 , m z = cos ( PI * (( i - 1 ) + 0.75_rk ) / ( nIntP + 0.5_rk )); loopToExit : do p1 = 1.0_rk ; p2 = 0.0_rk ; do j = 0 , nIntP - 1 p3 = p2 ; p2 = p1 ; p1 = (( 2.0_rk * j + 1.0_rk ) * z * p2 - j * p3 ) / ( j + 1.0_rk ); end do pp = nIntP * ( z * p1 - p2 ) / ( z * z - 1.0_rk ); z1 = z ; z = z1 - p1 / pp ; if ( abs ( z - z1 ) < EPS ) then exit loopToExit end if end do loopToExit x ( i ) = xm - xl * z ; x ( nIntP - i + 1 ) = xm + xl * z ; w ( i ) = 2.0_rk * xl / (( 1.0_rk - z * z ) * pp * pp ); w ( nIntp - i + 1 ) = w ( i ); end do end subroutine ply_gauleg ! ************************************************************************ ! end module ply_LegPolyProjection_module ! **************************************************************************** !","tags":"","url":"sourcefile/ply_legpolyprojection_module.f90.html"},{"title":"ply_split_legendre_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_split_legendre_module.f90~~AfferentGraph sourcefile~ply_split_legendre_module.f90 ply_split_legendre_module.f90 sourcefile~ply_split_element_module.f90 ply_split_element_module.f90 sourcefile~ply_split_element_module.f90->sourcefile~ply_split_legendre_module.f90 sourcefile~ply_sampling_adaptive_module.f90 ply_sampling_adaptive_module.f90 sourcefile~ply_sampling_adaptive_module.f90->sourcefile~ply_split_element_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2017,2019 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2018-2019 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach and Peter Vitt for ! University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> This module provides the functionality to split Legendre polynomials into !! a left and right subinterval with transformed coordinates. !! !! The original polynomial is defined on the interval [-1,1] and the two !! new polynomial representations are computed in the intervals [-1,0] and !! [0,1] but in the changed coordinate system, with the interval [-1,1] for !! each. !! Thus, if we refer to the coordinates in the original (coarse) element as !! x and to the respective coordinates in the two halfed elements as xi_left !! and xi_right, we compute the modal representation of the original Legendre !! polynomial series under these transformations: !!  x = 0.5 \\cdot \\xi_{left} - 0.5  !!  x = 0.5 \\cdot \\xi_{right} + 0.5  !! !! This is needed when refining elements. module ply_split_legendre_module use env_module , only : rk implicit none private public :: ply_split_legendre_matrix public :: ply_split_legendre_test contains ! ------------------------------------------------------------------------ ! !> Compute the transformation matrix for a projection to the left and right !! half-interval of Legendre polynomials for the given maximal number of !! modes. !! !! Note: The transformation matrices to each subinterval are triangular, and !!       the diagonal entries are the same. To save memory both matrices are !!       stored in a single 2 dimensional array of size !!       (nModes, nModes). !! !! This matrix only needs to be computed once for a sufficiently high order, !! as submatices out of it can by used to perform the transformation for !! any lower polynomial degree. !! !! The upper triangular matrix is created for the right subinterval, !! while the lower triangular matrix is used to store the rotated version !! for the left subinterval. !! For the right interval we interpret the first index as row index !! and the second as column. For the left interval this is reverted and !! we interpret the first index as columns of the matrix. !! !>@note Why is this a function? The reasoning for making this a function !!      is that we need to return exactly one thing (the split matrix). !!      It is then quite natural to refer to this by !!      ply_split_legendre_matrix. A subroutine on the other hand usually !!      describes something that should be done. Thus the name for a !!      subroutine would then be ply_split_legendre_compute_matrix !!      (describing the action performed by the subroutine). !!      When using OpenMP it sometimes is better to use subroutines, even !!      though it would be more natural to use a function. However, here !!      we do not expect this to be the case, as this is expected to be !!      called only once. !!@endnote pure function ply_split_legendre_matrix ( nModes ) result ( split_matrix ) ! -------------------------------------------------------------------- ! !> The maximal number of modes to compute the transformation for. !! !! The resulting matrix v will be max_modes x max_modes large and can !! be used for the transformation of all polynomials with up to this !! many modes. integer , intent ( in ) :: nModes real ( kind = rk ) :: split_matrix ( nModes , nModes ) ! -------------------------------------------------------------------- ! integer :: m integer :: orig integer :: sign_factor ! We only consider the split into the two halves. Thus, the according ! coordinate transformation factors in x = scaling*xi + shifting, are ! constant. real ( kind = rk ), parameter :: shifting = 0.5_rk real ( kind = rk ), parameter :: scaling = 0.5_rk ! -------------------------------------------------------------------- ! ! The split matrix looks like this: ! indicing: split_matrix(row, column) for the right half. ! ! (1,:)   [1.0  --  --     shift=0.5   ] ! (2,:)   | |  0.5  --                 | ! (3,:)   | |   |  0.25             ...| ! (4,:)   |             0.125          | ! (i,:)   | shift=-0.5        0.0625   | !   :     [    :                    ...] ! ! To compute the matrix we use the Clenshaw algorithm to iteratively ! compute the modal representation step by step for the right halfinterval ! and we store each step as a column in the upper triangular matrix. ! The left halfinterval can then easily obtained from that due to the ! symmetry of this problem, as only the sign in the shifting is changed. ! The first step (column) is always just 1 in the first mode (row). if ( nModes > 0 ) split_matrix ( 1 , 1 ) = 1.0_rk atleast2 : if ( nModes > 1 ) then ! In the next step (second column) we multiply the previous column ! by scaling and shift all modes one up. (There would also be a ! down-shifting but we now that all higher modes of the previous step are ! 0 anyway.) ! Then we add the shifting in the first mode. For the second step ! we can easily write this down explicitly: split_matrix ( 1 , 2 ) = shifting split_matrix ( 2 , 2 ) = scaling atleast3 : if ( nModes > 2 ) then ! For all higher modes we now actually need to compute something. do orig = 3 , nModes m = 1 ! Skip terms from below 1 (we shift 0 in). split_matrix ( m , orig ) = beta ( orig - 1 ) & & * split_matrix ( m , orig - 2 ) & & + shifting * alpha ( orig - 1 ) & & * split_matrix ( m , orig - 1 ) & & - scaling * alpha_beta ( m + 1 , orig - 1 ) & & * split_matrix ( m + 1 , orig - 1 ) do m = 2 , orig - 2 split_matrix ( m , orig ) = beta ( orig - 1 ) & & * split_matrix ( m , orig - 2 ) & & + shifting * alpha ( orig - 1 ) & & * split_matrix ( m , orig - 1 ) & & - scaling * alpha_beta ( m + 1 , orig - 1 ) & & * split_matrix ( m + 1 , orig - 1 ) & & + scaling * alpha_frac ( m - 1 , orig - 1 ) & & * split_matrix ( m - 1 , orig - 1 ) end do ! Skip all terms from beyond the diagonal (they are 0). m = orig - 1 split_matrix ( m , orig ) = shifting * alpha ( orig - 1 ) & & * split_matrix ( m , orig - 1 ) & & + scaling * alpha_frac ( m - 1 , orig - 1 ) & & * split_matrix ( m - 1 , orig - 1 ) m = orig split_matrix ( m , orig ) = scaling * alpha_frac ( m - 1 , orig - 1 ) & & * split_matrix ( m - 1 , orig - 1 ) end do end if atleast3 ! Due to the symmetry of the problem (the left subinterval has just ! the shifting with a changed sign), we can fill the other half of ! the matrix by copying the already computed values accordingly with ! a change in sign, as needed (alternatingly). do orig = 1 , nModes sign_factor = mod ( orig , 2 ) * 2 - 1 !NEC$ ivdep do m = 1 , orig - 1 , 2 split_matrix ( orig , m ) = sign_factor * split_matrix ( m , orig ) end do !NEC$ ivdep do m = 2 , orig - 1 , 2 split_matrix ( orig , m ) = - sign_factor * split_matrix ( m , orig ) end do end do end if atleast2 end function ply_split_legendre_matrix ! ======================================================================== ! ! !!!!!!! ! ! private ! ! !!!!!!! ! ! ------------------------------------------------------------------------ ! !> Coefficient alpha from the recursive formulation of Legendre polynomials, !! for the Legendre mode 'mode'. !! !! L_n(x) = \\alpha \\cdot x \\cdot L_{n-1}(x) + \\beta \\cdot L_{n-2}(x) !! !! For Legendre polynomials we have: !! !! \\alpha = \\frac{2 n - 1}{n} elemental function alpha ( mode ) ! -------------------------------------------------------------------- ! !> The Legendre mode to compute \\alpha for. integer , intent ( in ) :: mode real ( kind = rk ) :: alpha ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! if ( mode > 0 ) then alpha = real (( 2 * mode - 1 ), kind = rk ) / real ( mode , kind = rk ) else alpha = 0.0_rk end if end function alpha ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Coefficient beta from the recursive formulation of Legendre polynomials, !! for the Legendre mode 'mode'. !! !! L_n(x) = \\alpha \\cdot x \\cdot L_{n-1}(x) + \\beta \\cdot L_{n-2}(x) !! !! For Legendre polynomials we have: !! !! \\beta = \\frac{1 - n}{n} !! !>@note This is negative for all modes > 1. elemental function beta ( mode ) ! -------------------------------------------------------------------- ! !> The Legendre mode to compute \\beta for. integer , intent ( in ) :: mode real ( kind = rk ) :: beta ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! if ( mode > 1 ) then beta = real (( 1 - mode ), kind = rk ) / real ( mode , kind = rk ) else beta = 0.0_rk end if end function beta ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Quotient of two alpha values. !! !! This function computes alpha(numerator)/alpha(denominator). !! !>@note This is intended to keep as many integer operations together as !!      possible. elemental function alpha_frac ( denominator , numerator ) ! -------------------------------------------------------------------- ! !> Legendre mode of the \\alpha to use in the denominator. integer , intent ( in ) :: denominator !> Legendre mode of the \\alpha to use in the numeratorr. integer , intent ( in ) :: numerator real ( kind = rk ) :: alpha_frac ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! if ( denominator > 0 . and . numerator > 0 ) then if ( denominator == numerator ) then alpha_frac = 1.0_rk else alpha_frac = real (( 2 * numerator - 1 ) * denominator , kind = rk ) & & / real (( 2 * denominator - 1 ) * numerator , kind = rk ) end if else alpha_frac = 0.0_rk end if end function alpha_frac ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) as !! needed by the Clenshaw algorithm in ply_split_legendre_matrix. elemental function alpha_beta ( denominator , numerator ) ! -------------------------------------------------------------------- ! !> Legendre mode for the \\alpha in the numerator. integer , intent ( in ) :: numerator !> Legendre mode for the \\alpha in the denominator and the \\beta. integer , intent ( in ) :: denominator real ( kind = rk ) :: alpha_beta ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! if ( numerator > 0 . and . denominator > 0 ) then if ( denominator == numerator ) then alpha_beta = real (( 1 - denominator ), kind = rk ) & & / real ( denominator , kind = rk ) else alpha_beta = real (( 2 * numerator - 1 ) * ( 1 - denominator ), kind = rk ) & & / real ( numerator * ( 2 * denominator - 1 ), kind = rk ) end if else alpha_beta = 0.0_rk end if end function alpha_beta ! ======================================================================== ! ! !!!!!!! ! ! testing ! ! !!!!!!! ! ! ------------------------------------------------------------------------ ! !> A small testing routine to check the functions of this module. !! subroutine ply_split_legendre_test ( success ) ! -------------------------------------------------------------------- ! !> Indication whether the tests were completed successfully. logical , intent ( out ) :: success ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: large_mat (:,:) real ( kind = rk ), allocatable :: small_mat (:,:) real ( kind = rk ) :: res integer :: iiter integer :: jiter ! -------------------------------------------------------------------- ! success = . true . ! Expected values for alpha: res = alpha ( 1 ) if ( abs ( res - 1.0_rk ) > epsilon ( res )) success = . false . res = alpha ( 2 ) if ( abs ( res - 1.5_rk ) > epsilon ( res )) success = . false . res = alpha ( 4 ) if ( abs ( res - 1.75_rk ) > epsilon ( res )) success = . false . res = alpha ( 5 ) if ( abs ( res - 1.8_rk ) > epsilon ( res )) success = . false . res = alpha ( 10 ) if ( abs ( res - 1.9_rk ) > epsilon ( res )) success = . false . res = alpha ( 100 ) if ( abs ( res - 1.99_rk ) > epsilon ( res )) success = . false . if (. not . success ) then write ( * , * ) 'Alpha check failed' RETURN end if ! Expected values for beta: res = beta ( 1 ) if ( abs ( res ) > tiny ( res )) success = . false . res = beta ( 2 ) if ( abs ( res + 0.5_rk ) > epsilon ( res )) success = . false . res = beta ( 4 ) if ( abs ( res + 0.75_rk ) > epsilon ( res )) success = . false . res = beta ( 5 ) if ( abs ( res + 0.8_rk ) > epsilon ( res )) success = . false . res = beta ( 10 ) if ( abs ( res + 0.9_rk ) > epsilon ( res )) success = . false . res = beta ( 100 ) if ( abs ( res + 0.99_rk ) > epsilon ( res )) success = . false . if (. not . success ) then write ( * , * ) 'Beta check failed' RETURN end if ! Expected properties for alpha_frac: ! * It should be the same as dividing the corresponding values of alpha ! * If both modes are identic, it should be one ! * If the modes are exchanged the value should be inversed do iiter = 1 , 100 res = alpha_frac ( iiter , iiter ) if ( abs ( res - 1.0_rk ) > epsilon ( res )) success = . false . do jiter = iiter + 1 , 100 res = alpha_frac ( iiter , jiter ) if ( abs ( res - ( alpha ( jiter ) / alpha ( iiter ))) > epsilon ( res )) & & success = . false . if ( abs ( res - ( 1._rk / alpha_frac ( jiter , iiter ))) > epsilon ( res )) & & success = . false . end do end do ! Some expected values for alpha_frac: res = alpha_frac ( 1 , 2 ) if ( abs ( res - 1.5_rk ) > epsilon ( res )) success = . false . res = alpha_frac ( 1 , 4 ) if ( abs ( res - 1.75_rk ) > epsilon ( res )) success = . false . res = alpha_frac ( 1 , 5 ) if ( abs ( res - 1.8_rk ) > epsilon ( res )) success = . false . res = alpha_frac ( 2 , 4 ) if ( abs ( res - ( 1.75_rk / 1.5_rk )) > epsilon ( res )) success = . false . res = alpha_frac ( 2 , 5 ) if ( abs ( res - ( 1.8_rk / 1.5_rk )) > epsilon ( res )) success = . false . res = alpha_frac ( 4 , 5 ) if ( abs ( res - ( 1.8_rk / 1.75_rk )) > epsilon ( res )) success = . false . if (. not . success ) then write ( * , * ) 'alpha_frac check failed' RETURN end if ! Expected properties for alpha_beta: ! * It should be the same as when using alpha and beta accordingly ! * If both modes are identic, it should be the same as beta(mode) do iiter = 1 , 100 res = alpha_beta ( iiter , iiter ) if ( abs ( res - beta ( iiter )) > epsilon ( res )) success = . false . do jiter = iiter + 1 , 100 res = alpha_beta ( iiter , jiter ) if ( abs ( res - (( alpha ( jiter ) * beta ( iiter )) / alpha ( iiter ))) & & > epsilon ( res ) ) success = . false . end do end do ! Some expected values for alpha_beta: res = alpha_beta ( 1 , 2 ) if ( abs ( res ) > tiny ( res )) success = . false . res = alpha_beta ( 1 , 4 ) if ( abs ( res ) > tiny ( res )) success = . false . res = alpha_beta ( 1 , 5 ) if ( abs ( res ) > tiny ( res )) success = . false . res = alpha_beta ( 2 , 4 ) if ( abs ( res + ( 7.0_rk / 1 2.0_rk )) > epsilon ( res )) success = . false . res = alpha_beta ( 2 , 5 ) if ( abs ( res + 0.6_rk ) > epsilon ( res )) success = . false . res = alpha_beta ( 4 , 5 ) if ( abs ( res + ( 2 7.0_rk / 3 5.0_rk )) > epsilon ( res )) success = . false . if (. not . success ) then write ( * , * ) 'alpha_beta check failed' RETURN end if ! Some expected properties of the ply_split_legendre_matrix function allocate ( large_mat ( 100 , 100 )) large_mat = ply_split_legendre_matrix ( 100 ) ! * The diagonal should be 0.5**(row-1) do iiter = 1 , 100 if (( large_mat ( iiter , iiter ) - 0.5_rk ** ( iiter - 1 )) > epsilon ( res )) & & success = . false . end do ! * For smaller modes, we should just get submatrices of the larger one. do iiter = 1 , 99 allocate ( small_mat ( iiter , iiter )) small_mat = ply_split_legendre_matrix ( iiter ) if ( maxval ( abs ( large_mat (: iiter , : iiter ) - small_mat )) > epsilon ( res )) & & success = . false . deallocate ( small_mat ) end do if (. not . success ) then write ( * , * ) 'ply_split_legendre_matrix check failed' RETURN end if end subroutine ply_split_legendre_test ! ======================================================================== ! end module ply_split_legendre_module","tags":"","url":"sourcefile/ply_split_legendre_module.f90.html"},{"title":"ply_fxt_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_fxt_module.f90~~EfferentGraph sourcefile~ply_fxt_module.f90 ply_fxt_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_fxt_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015 Kay Langhammer <kay.langhammer@student.uni-siegen.de> ! Copyright (c) 2015,2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2015 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016-2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Parts of this file were written by Kay Langhammer, Harald Klimach, Nikhil ! Anand, Tobias Girresser and Peter Vitt for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Fast polynomial transformation using the FXTPACK implementation of a !! fast multipole method. module ply_fxt_module use env_module , only : rk use fxt_fwrap , only : fxtf_flptld_type , & & fxtf_flptld_n2m , & & fxtf_flptld_m2n , & & fxtf_flptld_init use ply_fxt_header_module , only : ply_fxt_header_type implicit none private type ply_fxt_type type ( fxtf_flptld_type ) :: flpt real ( kind = rk ) :: prec integer :: ndims end type ply_fxt_type public :: ply_fxt_type public :: ply_init_fxt public :: ply_fxt_m2n_1D , ply_fxt_m2n_2D , ply_fxt_m2n_3D public :: ply_fxt_n2m_1D , ply_fxt_n2m_2D , ply_fxt_n2m_3D contains ! ************************************************************************ ! !> Initialize the flpt data structure for fast legendre polynomial !! transformation via the fxtpack. subroutine ply_init_fxt ( fxt , header , degree ) ! -------------------------------------------------------------------- ! !> Handle to the resulting fast polynomial table. type ( ply_fxt_type ), intent ( out ) :: fxt type ( ply_fxt_header_type ), intent ( in ) :: header !> Polynomial degree. integer , intent ( in ) :: degree ! -------------------------------------------------------------------- ! integer :: nPoints ! -------------------------------------------------------------------- ! nPoints = degree + 1 call fxtf_flptld_init ( flpt = fxt % flpt , & & degree = degree , & & nPoints = nPoints , & & prec = header % prec ) end subroutine ply_init_fxt ! ************************************************************************ ! ! ************************************************************************ ! !> Convert modal data to nodal data in 1D using flpt. !! !! This encapsualtes the pure C-Interface, with extraction of the array !! sizes and dealing with the flpt data. !! !! Note: The modal and nodal data array sizes need to match the flpt !! definitions, provided in the fxtf_flptld_init call. subroutine ply_fxt_m2n_1D ( fxt , modal_data , nodal_data ) ! -------------------------------------------------------------------- ! !> Description of the Fast Legendre Polynomial Transform type ( ply_fxt_type ) :: fxt !> Nodal data real ( kind = rk ), target , intent ( inout ) :: nodal_data (:) !> Modal data real ( kind = rk ), target , intent ( inout ) :: modal_data (:) ! -------------------------------------------------------------------- ! call fxtf_flptld_m2n ( flpt = fxt % flpt , & & modal_data = modal_data , & & nodal_data = nodal_data ) end subroutine ply_fxt_m2n_1D ! ************************************************************************ ! ! ************************************************************************ ! !> Convert modal data to nodal data in 2D using flpt. subroutine ply_fxt_m2n_2D ( fxt , modal_data , nodal_data , oversamp_degree ) ! -------------------------------------------------------------------- ! !> Description of the Fast Legendre Polynomial Transform type ( ply_fxt_type ) :: fxt !> Nodal data real ( kind = rk ), target , intent ( inout ) :: nodal_data (:) !> Modal data real ( kind = rk ), target , intent ( inout ) :: modal_data (:) integer , intent ( in ) :: oversamp_degree ! -------------------------------------------------------------------- ! integer :: ub , lb , iLine , iColumn , nModesPerDim , msq ! -------------------------------------------------------------------- ! nModesPerDim = ( oversamp_degree + 1 ) msq = nModesPerDim * nModesPerDim do iLine = 1 , oversamp_degree + 1 lb = ( iLine - 1 ) * ( oversamp_degree + 1 ) + 1 ub = lb + oversamp_degree call fxtf_flptld_m2n ( flpt = fxt % flpt , & & modal_data = modal_data ( lb : ub ), & & nodal_data = nodal_data ( lb : ub ) ) end do do iColumn = 1 , oversamp_degree + 1 lb = iColumn call fxtf_flptld_m2n ( flpt = fxt % flpt , & & modal_data = nodal_data ( lb : msq : oversamp_degree + 1 ), & & nodal_data = modal_data ( lb : msq : oversamp_degree + 1 ) ) end do nodal_data = modal_data end subroutine ply_fxt_m2n_2D ! ************************************************************************ ! ! ************************************************************************ ! !> Convert modal data to nodal data in 3D using flpt. subroutine ply_fxt_m2n_3D ( fxt , modal_data , nodal_data , oversamp_degree ) ! -------------------------------------------------------------------- ! !> Description of the Fast Legendre Polynomial Transform type ( ply_fxt_type ) :: fxt !> Nodal data real ( kind = rk ), target , intent ( inout ) :: nodal_data (:) !> Modal data real ( kind = rk ), target , intent ( inout ) :: modal_data (:) integer , intent ( in ) :: oversamp_degree ! -------------------------------------------------------------------- ! integer :: ub , lb , iLine , iColumn , nModesPerDim , msq , ntotalDofs real ( kind = rk ), pointer :: tmp_in (:), tmp_out (:) ! -------------------------------------------------------------------- ! nModesPerDim = ( oversamp_degree + 1 ) msq = nModesPerDim * nModesPerDim nTotalDofs = ( oversamp_degree + 1 ) ** 3 allocate ( tmp_in ( nModesPerDim )) allocate ( tmp_out ( nModesPerDim )) tmp_in = - 42 tmp_out = - 42 ! The loop for msq stripes for independent x Dir evaluations do iLine = 1 , msq lb = ( iLine - 1 ) * ( oversamp_degree + 1 ) + 1 ub = lb + oversamp_degree tmp_in = modal_data ( lb : ub ) call fxtf_flptld_m2n ( flpt = fxt % flpt , & & modal_data = tmp_in , & & nodal_data = tmp_out ) nodal_data ( lb : ub ) = tmp_out end do ! The loop for msq stripes for independent y Dir evaluations do iColumn = 1 , msq lb = int ( ( iColumn - 1 ) / nModesPerDim ) * msq & & + mod ( iColumn - 1 , nModesPerDim ) & & + 1 ub = lb + msq - 1 call fxtf_flptld_m2n ( flpt = fxt % flpt , & & modal_data = nodal_data ( lb : ub : nModesPerDim ), & & nodal_data = modal_data ( lb : ub : nModesPerDim ) ) end do ! The loop for msq stripes for independent z Dir evaluations ub = nTotalDofs do iColumn = 1 , msq lb = iColumn call fxtf_flptld_m2n ( flpt = fxt % flpt , & & modal_data = modal_data ( lb : ub : msq ), & & nodal_data = nodal_data ( lb : ub : msq ) ) end do end subroutine ply_fxt_m2n_3D ! ************************************************************************ ! ! ************************************************************************ ! !> Convert nodal data to modal data using flpt. !! !! This encapsualtes the pure C-Interface, with extraction of the array !! sizes and dealing with the flpt data. !! !! Note: The modal and nodal data array sizes need to match the flpt !! definitions, provided in the fxtf_flptld_init call. subroutine ply_fxt_n2m_1D ( fxt , nodal_data , modal_data ) ! -------------------------------------------------------------------- ! !> Description of the Fast Legendre Polynomial Transform type ( ply_fxt_type ) :: fxt !> Nodal data real ( kind = rk ), target , intent ( inout ) :: nodal_data (:) !> Modal data real ( kind = rk ), target , intent ( inout ) :: modal_data (:) ! -------------------------------------------------------------------- ! call fxtf_flptld_n2m ( flpt = fxt % flpt , & & nodal_data = nodal_data , & & modal_data = modal_data ) end subroutine ply_fxt_n2m_1D ! ************************************************************************ ! ! ************************************************************************ ! subroutine ply_fxt_n2m_2D ( fxt , nodal_data , modal_data , oversamp_degree ) ! -------------------------------------------------------------------- ! !> Description of the Fast Legendre Polynomial Transform type ( ply_fxt_type ) :: fxt !> Nodal data real ( kind = rk ), target :: nodal_data (:) !> Modal data real ( kind = rk ), target :: modal_data (:) integer , intent ( in ) :: oversamp_degree ! -------------------------------------------------------------------- ! integer :: ub , lb , iLine , iColumn , nModesPerDim , msq ! -------------------------------------------------------------------- ! nModesPerDim = ( oversamp_degree + 1 ) msq = nModesPerDim * nModesPerDim do iLine = 1 , oversamp_degree + 1 lb = ( iLine - 1 ) * ( oversamp_degree + 1 ) + 1 ub = lb + oversamp_degree call fxtf_flptld_n2m ( flpt = fxt % flpt , & & nodal_data = nodal_data ( lb : ub ), & & modal_data = modal_data ( lb : ub ) ) end do do iColumn = 1 , oversamp_degree + 1 lb = iColumn call fxtf_flptld_n2m ( flpt = fxt % flpt , & & nodal_data = modal_data ( lb : msq : oversamp_degree + 1 ), & & modal_data = nodal_data ( lb : msq : oversamp_degree + 1 ) ) end do modal_data = nodal_data end subroutine ply_fxt_n2m_2D ! ************************************************************************ ! ! ************************************************************************ ! subroutine ply_fxt_n2m_3D ( fxt , nodal_data , modal_data , oversamp_degree ) ! -------------------------------------------------------------------- ! !> Description of the Fast Legendre Polynomial Transform type ( ply_fxt_type ) :: fxt !> Nodal data real ( kind = rk ), target , intent ( inout ) :: nodal_data (:) !> Modal data real ( kind = rk ), target , intent ( inout ) :: modal_data (:) integer , intent ( in ) :: oversamp_degree ! -------------------------------------------------------------------- ! integer :: ub , lb , iLine , iColumn , nModesPerDim , msq , ntotalDofs ! -------------------------------------------------------------------- ! nModesPerDim = ( oversamp_degree + 1 ) msq = nModesPerDim * nModesPerDim nTotalDofs = ( oversamp_degree + 1 ) ** 3 ! The loop for msq stripes for independent x Dir evaluations do iLine = 1 , msq lb = ( iLine - 1 ) * ( oversamp_degree + 1 ) + 1 ub = lb + oversamp_degree call fxtf_flptld_n2m ( flpt = fxt % flpt , & & nodal_data = nodal_data ( lb : ub ), & & modal_data = modal_data ( lb : ub ) ) end do ! The loop for msq stripes for independent y Dir evaluations do iColumn = 1 , msq lb = int ( ( iColumn - 1 ) / nModesPerDim ) * msq & & + mod ( iColumn - 1 , nModesPerDim ) & & + 1 ub = lb + msq - 1 call fxtf_flptld_n2m ( flpt = fxt % flpt , & & nodal_data = modal_data ( lb : ub : nModesPerDim ), & & modal_data = nodal_data ( lb : ub : nModesPerDim ) ) end do ! The loop for msq stripes for independent z Dir evaluations ub = nTotalDofs do iColumn = 1 , msq lb = iColumn call fxtf_flptld_n2m ( flpt = fxt % flpt , & & nodal_data = nodal_data ( lb : ub : msq ), & & modal_data = modal_data ( lb : ub : msq ) ) end do end subroutine ply_fxt_n2m_3D ! ************************************************************************ ! end module ply_fxt_module","tags":"","url":"sourcefile/ply_fxt_module.f90.html"},{"title":"ply_space_integration_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_space_integration_module.f90~~AfferentGraph sourcefile~ply_space_integration_module.f90 ply_space_integration_module.f90 sourcefile~ply_l2p_module.f90 ply_l2p_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_space_integration_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2012 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2012-2014,2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2013 Melven Zoellner <yameta@freenet.de> ! Copyright (c) 2012 Vyacheslav Korchagin <v.korchagin@grs-sim.de> ! Copyright (c) 2013-2014, 2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2013-2014 Verena Krupp <v.krupp@grs-sim.de> ! Copyright (c) 2015 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2016-2017 Daniel Petró <daniel.petro@student.uni-siegen.de> ! ! Parts of this file were written by Jens Zudrop, Vyacheslav Korchagin, Melven ! Zoellner and Harald Klimach for German Research School for Simulation ! Sciences GmbH. ! ! Parts of this file were written by Harald Klimach, Verena Krupp, Peter Vitt, ! Daniel Petró and Nikhil Anand for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Spatial integration with the Gauss-Legendre numerical integration. module ply_space_integration_module use env_module , only : rk use tem_param_module , only : PI implicit none private public :: ply_gaussLegPoints contains ! ------------------------------------------------------------------------ ! !> Create Gauss-Legendre integration points and weights for one-dimensional !! integration on the interval [x1,x2]. subroutine ply_gaussLegPoints ( x1 , x2 , x , w , nIntP ) ! -------------------------------------------------------------------- ! !> lower limit of integration interval real ( kind = rk ), intent ( in ) :: x1 !> upper limit of integration interval real ( kind = rk ), intent ( in ) :: x2 !> The coordinates of the gauss points on the interval [x1,x2]. !! The array has the length nIntP. real ( kind = rk ), intent ( out ) :: x (:) !> The quadrature weights. The array has the length nIntP. real ( kind = rk ), intent ( out ) :: w (:) !> The number of integration points. integer , intent ( in ) :: nIntP ! -------------------------------------------------------------------- ! !> some working variables real ( kind = rk ) :: z1 , z , xm , xl , pp , p3 , p2 , p1 ; !> the relative precision of the points real ( kind = rk ) :: EPS integer :: m , i , j ! -------------------------------------------------------------------- ! EPS = 1.0 / ( 1 0.0 ** ( PRECISION ( 1.0_rk ) - 2 ) ) m = ( nIntP + 1 ) / 2 xm = 0.5 * ( x2 + x1 ) xl = 0.5 * ( x2 - x1 ) do i = 1 , m z = cos ( PI * (( i - 1 ) + 0.75_rk ) / ( nIntP + 0.5_rk )) loopToExit : do p1 = 1.0_rk p2 = 0.0_rk do j = 0 , nIntP - 1 p3 = p2 p2 = p1 p1 = (( 2.0_rk * j + 1.0_rk ) * z * p2 - j * p3 ) / ( j + 1.0_rk ) end do pp = nIntP * ( z * p1 - p2 ) / ( z * z - 1.0_rk ) z1 = z z = z1 - p1 / pp if ( abs ( z - z1 ) < EPS ) EXIT loopToExit end do loopToExit x ( i ) = xm - xl * z x ( nIntP - i + 1 ) = xm + xl * z w ( i ) = 2.0_rk * xl / (( 1.0_rk - z * z ) * pp * pp ) w ( nIntp - i + 1 ) = w ( i ) end do end subroutine ply_gaussLegPoints ! ------------------------------------------------------------------------ ! end module ply_space_integration_module","tags":"","url":"sourcefile/ply_space_integration_module.f90.html"},{"title":"ply_prj_header_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_prj_header_module.f90~~EfferentGraph sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ply_prj_header_module.f90~~AfferentGraph sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013-2014 Verena Krupp ! Copyright (c) 2013-2014, 2016-2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2014-2015 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2014-2015 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2017 Daniel Petró <daniel.petro@student.uni-siegen.de> ! Copyright (c) 2019 Neda Ebrahimi Pour <neda.epour@uni-siegen.de> ! ! Parts of this file were written by Verena Krupp, Peter Vitt, Harald Klimach, ! Nikhil Anand, Daniel Petró and Neda Ebrahimi Pour for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! module ply_prj_header_module use env_module , only : labelLen use fftw_wrap , only : fftw_available use aotus_module , only : flu_State , aot_get_val use aot_out_module , only : aot_out_type , aot_out_val use tem_aux_module , only : tem_abort use tem_tools_module , only : upper_to_lower use tem_logging_module , only : logUnit use ply_fpt_header_module use ply_l2p_header_module use ply_fxt_header_module implicit none private !> Configurable projection settings. type ply_prj_header_type !> Kind of projection. Currently available: !! - 'l2p', L2-Projection !! - 'fpt', Fast Polynomial Transformation. Requires the FFTW. character ( len = labelLen ) :: kind type ( ply_fpt_header_type ) :: fpt_header type ( ply_l2p_header_type ) :: l2p_header type ( ply_fxt_header_type ) :: fxt_header end type ply_prj_header_type interface assignment ( = ) module procedure copy_poly_proj_header end interface interface operator ( == ) module procedure isEqual end interface interface operator ( /= ) module procedure isUnequal end interface interface operator ( < ) module procedure isSmaller end interface interface operator ( <= ) module procedure isSmallerOrEqual end interface interface operator ( > ) module procedure isGreater end interface interface operator ( >= ) module procedure isGreaterOrEqual end interface public :: ply_prj_header_type public :: ply_prj_header_load public :: ply_prj_header_out public :: assignment ( = ) public :: operator ( == ), operator ( /= ), operator ( < ), operator ( <= ) public :: operator ( > ), operator ( >= ) contains ! ************************************************************************ ! pure subroutine Copy_poly_proj_header ( left , right ) ! -------------------------------------------------------------------- ! !> fpt to copy to type ( ply_prj_header_type ), intent ( out ) :: left !> fpt to copy from type ( ply_prj_header_type ), intent ( in ) :: right ! -------------------------------------------------------------------- ! left % kind = right % kind left % fpt_header = right % fpt_header left % l2p_header = right % l2p_header left % fxt_header = right % fxt_header end subroutine copy_poly_proj_header ! ************************************************************************ ! ! ************************************************************************ ! !> Load settings to describe a projection method from a Lua table. subroutine ply_prj_header_load ( me , conf , parent ) ! -------------------------------------------------------------------- ! type ( ply_prj_header_type ), intent ( out ) :: me type ( flu_State ) :: conf !> A parent Lua table, in which the boundary conditions are to be found. integer , intent ( in ) :: parent ! -------------------------------------------------------------------- ! integer :: iError ! -------------------------------------------------------------------- ! if ( parent /= 0 ) then call aot_get_val ( L = conf , & & thandle = parent , & & key = 'kind' , & & val = me % kind , & & default = 'l2p' , & & ErrCode = iError ) me % kind = upper_to_lower ( me % kind ) select case ( trim ( me % kind )) case ( 'l2p' ) call ply_l2p_header_load ( me = me % l2p_header , & & conf = conf , & & thandle = parent ) call ply_l2p_header_display ( me = me % l2p_header ) case ( 'fxt' ) call ply_fxt_header_load ( me = me % fxt_header , & & conf = conf , & & thandle = parent ) call ply_fxt_header_display ( me = me % fxt_header ) case ( 'fpt' ) if ( fftw_available ) then call ply_fpt_header_load ( me = me % fpt_header , & & conf = conf , & & thandle = parent ) call ply_fpt_header_display ( me = me % fpt_header ) else write ( logUnit ( 1 ), * ) '' write ( logUnit ( 1 ), * ) & & '+===================================================+' write ( logUnit ( 1 ), * ) & & '!! FFTW NOT available but necessary for FPT!       !!' write ( logUnit ( 1 ), * ) & & '!! WARNING: Deactivating fast polynomial transform !!' write ( logUnit ( 1 ), * ) & & '!!          for this projection!                   !!' write ( logUnit ( 1 ), * ) & & '!!                                                 !!' write ( logUnit ( 1 ), * ) & & '!! Falling back to L2 Projection.                  !!' write ( logUnit ( 1 ), * ) & & '+===================================================+' write ( logUnit ( 1 ), * ) '' me % kind = 'l2p' call ply_l2p_header_load ( me = me % l2p_header , & & conf = conf , & & thandle = parent ) call ply_l2p_header_display ( me = me % l2p_header ) end if case default write ( logUnit ( 1 ), * ) 'ERROR while loading projection:' write ( logUnit ( 1 ), * ) '      Unknown projection method ' & & // trim ( me % kind ) // '!' write ( logUnit ( 1 ), * ) '      Available methods are:' write ( logUnit ( 1 ), * ) '      * l2p - L2 Projection' write ( logUnit ( 1 ), * ) '      * fxt - FXTPACK: Fast Multipole Method' if ( fftw_available ) then write ( logUnit ( 1 ), * ) '      * fpt - Fast Polynomial Transformation' end if call tem_abort () end select else write ( logUnit ( 1 ), * ) 'No projection provided, using defaults.' me % kind = 'l2p' call ply_l2p_header_load ( me = me % l2p_header , & & conf = conf , & & thandle = parent ) call ply_l2p_header_display ( me = me % l2p_header ) end if end subroutine ply_prj_header_load ! ************************************************************************ ! ! ************************************************************************ ! !> Load settings to describe a projection method from a Lua table. subroutine ply_prj_header_out ( me , conf ) ! -------------------------------------------------------------------- ! type ( ply_prj_header_type ), intent ( in ) :: me type ( aot_out_type ) :: conf ! -------------------------------------------------------------------- ! call aot_out_val ( put_conf = conf , & & vname = 'kind' , & & val = me % kind ) select case ( trim ( me % kind )) case ( 'l2p' ) call ply_l2p_header_out ( me = me % l2p_header , & & conf = conf ) case ( 'fpt' ) call ply_fpt_header_out ( me = me % fpt_header , & & conf = conf ) case ( 'fxt' ) call ply_fxt_header_out ( me = me % fxt_header , & & conf = conf ) end select end subroutine ply_prj_header_out ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides the test for equality of the header for two !! projections. !! !! The headers are considered to be equal, if their kind and the corresponding !! headers are equal. For unknown kinds, the headers are not taken into !! consideration. pure function isEqual ( left , right ) result ( equality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_prj_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_prj_header_type ), intent ( in ) :: right !> is equal?? logical :: equality ! -------------------------------------------------------------------- ! equality = ( left % kind == right % kind ) select case ( left % kind ) case ( 'fpt' ) equality = equality . and . ( left % fpt_header == right % fpt_header ) case ( 'l2p' ) equality = equality . and . ( left % l2p_header == right % l2p_header ) case ( 'fxt' ) equality = equality . and . ( left % fxt_header == right % fxt_header ) end select end function isEqual ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides the test for unequality of the header of two !! projections. !! !! Two projections are considered to be unequal, if their kind, their !! fpt-header or l2p_header are not equal. pure function isUnequal ( left , right ) result ( unequality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_prj_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_prj_header_type ), intent ( in ) :: right !> is unequal?? logical :: unequality ! -------------------------------------------------------------------- ! unequality = ( left % kind /= right % kind ) if (. not . unequality ) then select case ( left % kind ) case ( 'fpt' ) unequality = ( left % fpt_header /= right % fpt_header ) case ( 'l2p' ) unequality = ( left % l2p_header /= right % l2p_header ) case ( 'fxt' ) unequality = ( left % fxt_header /= right % fxt_header ) end select end if end function isUnequal ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a < comparison of the header of two projections. !! !! Sorting of projections is given by the kind, fpt_header and !! last by l2p_header. pure function isSmaller ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_prj_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_prj_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! small = . false . if ( left % kind < right % kind ) then small = . true . else if ( left % kind == right % kind ) then select case ( left % kind ) case ( 'fpt' ) small = ( left % fpt_header < right % fpt_header ) case ( 'l2p' ) small = ( left % l2p_header < right % l2p_header ) case ( 'fxt' ) small = ( left % fxt_header < right % fxt_header ) end select end if end if end function isSmaller ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a <= comparison of the header of two projections. !! !! Sorting of projections is given by kind, fpt_header and !! last by the l2p header. pure function isSmallerOrEqual ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_prj_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_prj_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! small = . false . if ( left % kind < right % kind ) then small = . true . else if ( left % kind == right % kind ) then select case ( left % kind ) case ( 'fpt' ) small = ( left % fpt_header <= right % fpt_header ) case ( 'l2p' ) small = ( left % l2p_header <= right % l2p_header ) case ( 'fxt' ) small = ( left % fxt_header <= right % fxt_header ) end select end if end if end function isSmallerOrEqual ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a > comparison of the header of two projections. !! !! Sorting of projections is given by kind, fpt_header and !! last by l2p_header. pure function isGreater ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_prj_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_prj_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! great = . false . if ( left % kind > right % kind ) then great = . true . else if ( left % kind == right % kind ) then select case ( left % kind ) case ( 'fpt' ) great = ( left % fpt_header > right % fpt_header ) case ( 'l2p' ) great = ( left % l2p_header > right % l2p_header ) case ( 'fxt' ) great = ( left % fxt_header > right % fxt_header ) end select end if end if end function isGreater ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a >= comparison of the header of two projections. !! !! Sorting of projections is given by kind, fpt_header and !! last by l2p_header. pure function isGreaterOrEqual ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_prj_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_prj_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! great = . false . if ( left % kind > right % kind ) then great = . true . else if ( left % kind == right % kind ) then select case ( left % kind ) case ( 'fpt' ) great = ( left % fpt_header >= right % fpt_header ) case ( 'l2p' ) great = ( left % l2p_header >= right % l2p_header ) case ( 'fxt' ) great = ( left % fxt_header >= right % fxt_header ) end select end if end if end function isGreaterOrEqual ! ************************************************************************ ! end module ply_prj_header_module","tags":"","url":"sourcefile/ply_prj_header_module.f90.html"},{"title":"sdr_timer_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_timer_module.f90~~AfferentGraph sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_timer_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2015 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015-2016, 2022 Harald Klimach <harald.klimach@dlr.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module sdr_timer_module use tem_timer_module , only : tem_addTimer , tem_getMaxTimerVal , & & tem_getTimerName use soi_revision_module , only : soi_solver_revision use tem_general_module , only : tem_general_type use env_module , only : rk , pathlen , newunit implicit none private integer , parameter :: nTimers = 8 !> Handles for timer objects to measure the time for some code parts integer , public :: timer_handle_loadconfig integer , public :: timer_handle_proto integer , public :: timer_handle_flooding integer , public :: timer_handle_inHeritDR integer , public :: timer_handle_refineLeaf integer , public :: timer_handle_smoothLeaf integer , public :: timer_handle_proto2treelm integer , public :: timer_handle_dumping_mesh integer :: first_timer public :: sdr_addTimers public :: sdr_dumptimers contains !> Setup timers to assess the runtime of various parts of Seeder subroutine sdr_addTimers () !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! Create seeder timers call tem_addTimer ( timerHandle = timer_handle_loadconfig , & & timerName = 'loadconfig' ) first_timer = timer_handle_loadconfig call tem_addTimer ( timerHandle = timer_handle_proto , & & timerName = 'proto' ) call tem_addTimer ( timerHandle = timer_handle_flooding , & & timerName = 'flooding' ) call tem_addTimer ( timerHandle = timer_handle_inHeritDR , & & timerName = 'inHeritDR' ) call tem_addTimer ( timerHandle = timer_handle_refineLeaf , & & timerName = 'refineLeaf' ) call tem_addTimer ( timerHandle = timer_handle_smoothLeaf , & & timerName = 'smoothLeaf' ) call tem_addTimer ( timerHandle = timer_handle_proto2treelm ,& & timerName = 'proto2treelm' ) call tem_addTimer ( timerHandle = timer_handle_dumping_mesh ,& & timerName = 'dump_mesh' ) end subroutine sdr_addTimers !> Performance results are written to a file for statistical review subroutine sdr_dumptimers ( general , nFluids , nBnds ) !-------------------------------------------------------------------------- !> Parameters of the current simulation type ( tem_general_type ), intent ( in ) :: general !> Number of fluid elements in dumped mesh integer , intent ( in ) :: nFluids !> Number of fluid elements which has boundary in dumped mesh integer , intent ( in ) :: nBnds !-------------------------------------------------------------------------- logical :: file_exists character ( len = pathLen ) :: filename integer :: fileunit , iTimer real ( kind = rk ), allocatable :: timerVal (:) character ( len = 40 ), allocatable :: timerLabel (:) character ( len = PathLen ) :: header character ( len = 2 ** 8 ) :: output integer :: thandle real ( kind = rk ) :: MFEPS real ( kind = rk ) :: totaltime !-------------------------------------------------------------------------- ! allocate the arrays for the timervalue and label allocate ( timerVal ( nTimers )) allocate ( timerLabel ( nTimers )) ! compute MFEPS (million fluids elements per second) totaltime = tem_getMaxtimerval ( timerhandle = 1 , & & comm = general % proc % comm ) MFEPS = nFluids / ( totaltime * 10 ** 6 ) ! writes the first part of the header write ( header , '(a1,1x,a12,1x,a20,1x,a12,1x,a12,1x,a8,1x,a8)' ) & & '#' , 'Revision' , & & 'Casename' , & & 'nFluids' , & & 'nBnds' , & & 'nProcs' , & ! The number of proc (i.e. MPI ranks) & 'MFEPS' ! million fluids elements per second ! run over all timers and get the value and the label of the timer do iTimer = 1 , nTimers thandle = first_timer + iTimer - 1 timerVal ( iTimer ) = tem_getMaxtimerval ( timerhandle = thandle , & & comm = general % proc % comm ) timerLabel ( iTimer ) = trim ( tem_getTimerName ( timerHandle = thandle )) write ( header , '(a,a12,a1)' ) trim ( header ), trim ( timerLabel ( iTimer )), '|' enddo ! writes the first part of the output write ( output , '(1x,a13,1x,a20,1x,i12,1x,i12,1x,i8,1x,EN12.3)' ) & & trim ( soi_solver_revision ), & & trim ( general % solver % simName ), & & nFluids , & & nBnds , & & general % proc % comm_size , & & MFEPS ! loop to write timer value in output do iTimer = 1 , nTimers write ( output , '(a,1x,EN12.3)' ) trim ( output ), timerVal ( iTimer ) enddo !> write file filename = trim ( general % timingFile ) inquire ( file = filename , exist = file_exists ) fileunit = newunit () open ( unit = fileunit , file = trim ( filename ), position = 'append' ) if (. not . file_exists ) then write ( fileunit , '(a)' ) trim ( header ) end if write ( fileunit , '(a)' ) trim ( output ) close ( fileunit ) end subroutine sdr_dumptimers end module sdr_timer_module","tags":"","url":"sourcefile/sdr_timer_module.f90.html"},{"title":"ply_nodes_header_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_nodes_header_module.f90~~AfferentGraph sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_nodes_module.f90 ply_nodes_module.f90 sourcefile~ply_nodes_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_fxt_module.f90 ply_fxt_module.f90 sourcefile~ply_fxt_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_module.f90 ply_l2p_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~ply_legfpt_module.f90 ply_legFpt_module.f90 sourcefile~ply_legfpt_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013-2014 Verena Krupp ! Copyright (c) 2013,2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2014 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2014 Harald Klimach <harald.klimach@uni-siegen.de> ! ! Parts of this file were written by Verena Krupp, Peter Vitt, Nikhil Anand ! and Harald Klimach for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! module ply_nodes_header_module use env_module , only : labelLen implicit none private type ply_nodes_header_type !> which kind of nodes are used. For l2p projection the nodes are !! legendre-gauss and chebyshev nodes for using fpt character ( len = labelLen ) :: nodes_kind !> Logical to indicate whether Chebyshev-Lobatto points or simple !! Chebyshev points are used logical :: lobattoPoints = . false . end type ply_nodes_header_type interface assignment ( = ) module procedure Copy_nodes_header end interface interface operator ( == ) module procedure isEqual end interface interface operator ( /= ) module procedure isUnequal end interface interface operator ( < ) module procedure isSmaller end interface interface operator ( <= ) module procedure isSmallerOrEqual end interface interface operator ( > ) module procedure isGreater end interface interface operator ( >= ) module procedure isGreaterOrEqual end interface public :: operator ( == ), operator ( /= ), operator ( < ), operator ( <= ) public :: operator ( > ), operator ( >= ) public :: assignment ( = ) public :: ply_nodes_header_type contains ! ************************************************************************ ! pure subroutine Copy_nodes_header ( left , right ) ! -------------------------------------------------------------------- ! !> fpt to copy to !type(ply_legFpt_2D_type), intent(out) :: left type ( ply_nodes_header_type ), intent ( out ) :: left !> fpt to copy from !type(ply_legFpt_2D_type), intent(in) :: right type ( ply_nodes_header_type ), intent ( in ) :: right ! -------------------------------------------------------------------- ! left % nodes_kind = right % nodes_kind left % lobattoPoints = right % lobattoPoints end subroutine Copy_nodes_header ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides the test for equality of two nodes descriptions. pure function isEqual ( left , right ) result ( equality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_nodes_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_nodes_header_type ), intent ( in ) :: right !> is equal?? logical :: equality ! -------------------------------------------------------------------- ! equality = ( left % nodes_kind == right % nodes_kind ) & & . and . ( left % lobattopoints . eqv . right % lobattopoints ) end function isEqual ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides the test for unequality of two nodes descriptions. pure function isUnequal ( left , right ) result ( unequality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_nodes_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_nodes_header_type ), intent ( in ) :: right !> is unequal?? logical :: unequality ! -------------------------------------------------------------------- ! unequality = ( left % nodes_kind /= right % nodes_kind ) & & . or . ( left % lobattopoints . neqv . right % lobattopoints ) end function isUnequal ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a < comparison of two nodes descriptions. pure function isSmaller ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_nodes_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_nodes_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! !> help variables integer :: left_log , right_log ! -------------------------------------------------------------------- ! small = . false . if ( left % lobattopoints ) then left_log = 1 else left_log = 0 end if if ( right % lobattopoints ) then right_log = 1 else right_log = 0 end if if ( left % nodes_kind < right % nodes_kind ) then small = . true . else if ( left % nodes_kind == right % nodes_kind ) then small = ( left_log < right_log ) end if end if end function isSmaller ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a <= comparison of two nodes descriptions. pure function isSmallerOrEqual ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_nodes_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_nodes_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! integer :: left_log , right_log ! -------------------------------------------------------------------- ! small = . false . if ( left % lobattopoints ) then left_log = 1 else left_log = 0 end if if ( right % lobattopoints ) then right_log = 1 else right_log = 0 end if if ( left % nodes_kind == right % nodes_kind ) then small = . true . else if ( left % nodes_kind == right % nodes_kind ) then small = ( left_log <= right_log ) end if end if end function isSmallerOrEqual ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a > comparison of nodes descriptions. pure function isGreater ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_nodes_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_nodes_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! !> help variables integer :: left_log , right_log ! -------------------------------------------------------------------- ! great = . false . if ( left % lobattopoints ) then left_log = 1 else left_log = 0 end if if ( right % lobattopoints ) then right_log = 1 else right_log = 0 end if if ( left % nodes_kind > right % nodes_kind ) then great = . true . else if ( left % nodes_kind == right % nodes_kind ) then great = ( left_log > right_log ) end if end if end function isGreater ! ************************************************************************ ! ! ************************************************************************ ! !> This function provides a >= comparison of two nodes descriptions. pure function isGreaterOrEqual ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_nodes_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_nodes_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! !> help variables integer :: left_log , right_log ! -------------------------------------------------------------------- ! great = . false . if ( left % lobattopoints ) then left_log = 1 else left_log = 0 end if if ( right % lobattopoints ) then right_log = 1 else right_log = 0 end if if ( left % nodes_kind == right % nodes_kind ) then great = . true . else if ( left % nodes_kind == right % nodes_kind ) then great = ( left_log >= right_log ) end if end if end function isGreaterOrEqual ! ************************************************************************ ! end module ply_nodes_header_module","tags":"","url":"sourcefile/ply_nodes_header_module.f90.html"},{"title":"sdr_refinePT_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_refinept_module.f90~~EfferentGraph sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_refinept_module.f90~~AfferentGraph sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015-2017, 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2015 Verena Krupp <verena.krupp@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2018 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! *************************************************************************** !> author: Kannan Masilamani !! This module contains routine to refine protoTree until the minlevel !! or level defined in the refinement object is reached !! module sdr_refinePT_module use env_module , only : long_k , rk , globalMaxLevels , my_status_int use tem_param_module , only : qQQQ , childCoord , qInvDir , qOffset use tem_dyn_array_module , only : PositionOfVal , SortedPosOfVal , append use tem_grow_array_module , only : destroy , append , truncate , init , & & grw_longArray_type , grw_intArray_type use tem_logging_module , only : logunit use tem_topology_module , only : tem_directChildren , tem_FirstIdAtLevel , & & tem_parentOf , tem_CoordOfId , tem_IdOfCoord use tem_timer_module , only : tem_startTimer , tem_stopTimer use tem_geometry_module , only : tem_eligibleChildren use tem_tools_module , only : tem_horizontalSpacer use tem_cube_module , only : tem_cube_type use tem_sphere_module , only : tem_sphere_type , tem_sphereCubeOverlap use sdr_spatialObj_module , only : sphere use sdr_prototree_module , only : sdr_protoTree_type , levelValues_type , & & sdr_neighbor_in_proto , sdr_node_neighbors use sdr_geometry_module , only : sdr_geometry_type , is_intersecting use sdr_node_module , only : intersectsBoundary_bit , hasBoundary_bit , & & isLeaf_bit , isTarget_bit , isFlooded_bit , & & isFluidifyable_bit , append , truncate , & & sdr_set_nodeProp_bit , & & sdr_clear_nodeProp_bit , sdr_nodeProp_btest , & & sdr_inHeritBnd_eligibleChildren , & & sdr_append_childIntersectedObject , & & sdr_intersectObjPos_type , & & grw_intersectObjPosArray_type use sdr_config_module , only : sdr_confHead_type use sdr_timer_module , only : timer_handle_refineLeaf , & & timer_handle_smoothLeaf , & & timer_handle_inHeritDR use sdr_attribute_module , only : sdr_object_kinds_max , & & sdr_Fluidifyable_Object implicit none private public :: sdr_inHerit_distanceRefineObject public :: sdr_refine_leaf public :: sdr_smooth_leaf contains ! *************************************************************************** !> This routines inherit distance refine sphere object from root node !! down to leaf node. !! Only the object with level greater than node level are inHerited subroutine sdr_inHerit_distanceRefineObject ( proto , geometry ) !--------------------------------------------------------------------------! !> The proto tree description with all the data to refine further type ( sdr_protoTree_type ), intent ( inout ) :: proto !> type which contains all geometry object infos type ( sdr_geometry_type ), intent ( in ) :: geometry !--------------------------------------------------------------------------! integer :: iLevel , iParent , iChild integer :: firstParent , lastParent integer ( kind = long_k ) :: parent_ID_offset integer ( kind = long_k ) :: parentID integer :: parentProps !intersected distance objPos of parent node type ( sdr_intersectObjPos_type ) :: distObjPos type ( levelValues_type ) :: leVal logical :: testAll integer :: child_nodePos ( 8 ) integer :: nDistRefine_objs integer :: memLeft !--------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_inHeritDR ) call tem_horizontalSpacer ( funit = logunit ( 1 )) write ( logUnit ( 5 ), * ) 'Inherit distance refine objects ...' write ( logUnit ( 5 ), * ) 'Nr. of distance refine spatial objects: ' , & & geometry % spatialObj % nVals - geometry % nUserObjs ! Set the length of the level cube length to the complete bounding cube ! length for level=0. ! Set some auxilary data describing the current level. leVal % dx = geometry % universe % extent leVal % ID_offset = tem_FirstIdAtLevel ( 0 ) ! first treeID on this level leVal % level = 0 ! level count testAll = . true . do iLevel = 1 , proto % nLevels write ( logunit ( 2 ), \"(A,I0)\" ) 'current Level: ' , iLevel ! Position of first and last parent in the sorted treeID list. firstParent = proto % levelNode_first ( iLevel - 1 ) lastParent = proto % levelNode_last ( iLevel - 1 ) parent_ID_offset = leVal % ID_offset ! First treeID on parent level ! (save from previous iteration) ! Set some auxilary data describing the current level. leVal % dx = 0.5_rk * leVal % dx ! length of cube nodes on this level leVal % ID_offset = tem_FirstIdAtLevel ( iLevel ) ! first treeID on this level leVal % level = iLevel ! level count ! Iterate over all elements on the previous level. do iParent = firstParent , lastParent ! KM: Since no new leaf nodes are created, treeID array is already ! sorted so no need to look for sorted position ! get property of current node parentProps = ibits ( proto % node % PropertyBits & & % val ( proto % node % propLength , iParent ), & & pos = proto % node % lastbyte_pos , len = 8 ) ! Inherit only if parent is flooded and not a leaf if ( btest ( parentProps , isFlooded_bit ) . and . & & . not . btest ( parentProps , isLeaf_bit ) ) then ! treeID of parent parentID = proto % node % treeID % val ( iParent ) if ( testAll ) then distObjPos % first = geometry % nUserObjs + 1 distObjPos % last = geometry % spatialObj % nVals else distObjPos % first = proto % node % distObjPos % val ( iParent )% first distObjPos % last = proto % node % distObjPos % val ( iParent )% last end if nDistRefine_objs = distObjPos % last - distObjPos % first + 1 ! Children node position in protoTree child_nodePos ( 1 ) = proto % node % linkPos ( 1 )% val ( iParent ) do iChild = 2 , 8 child_nodePos ( iChild ) = child_nodePos ( 1 ) + iChild - 1 end do ! Inherit interested distance refine object to children ! and set distance_first and distance_last for each child call inHerit_intersectedObject ( & & proto = proto , & & geometry = geometry , & & parent = iParent , & & parentID = parentID , & & testAll = testAll , & & intersected_object = proto % node % intersected_distance , & & grwObjPos = proto % node % distObjPos , & & parent_ObjPos = distObjPos , & & leVal = leVal , & & child_intersected_object = proto % child_intersected_object , & & child_nodePos = child_nodePos , & & memLeft = memLeft , & & isDistRefObj = . true . ) proto % node % memLeft_distObj = proto % node % memLeft_distObj + memLeft end if ! if not leaf end do !iNode testAll = . false . write ( logUnit ( 5 ), \"(A,I0)\" ) 'Number of intersected distance objects:' , & & proto % node % intersected_distance % nVals end do !iLevel write ( logUnit ( 5 ), \"(A,I0)\" ) 'Number of intersected distance objects:' , & & proto % node % intersected_distance % nVals write ( logunit ( 10 ), * ) 'Memory unused in parent intersected_distance: ' , & & proto % node % memLeft_distObj call tem_stopTimer ( timerHandle = timer_handle_inHeritDR ) end subroutine sdr_inHerit_distanceRefineObject ! *************************************************************************** ! *************************************************************************** !> This routine extends the protoTree with max of minlevel or level of !! refinement object. !! !! If it is a leaf, check for intersected objects, and keep !! on refining accordingly down to the maximum requested level. !! When the desired level is reached (no refinement object, !! or desired level of intersected refinement object reached, check all !! (26) direct neigbors. If there is a neighbor intersected by a boundary !! check its refinement level, if it is higher then the current one, !! do another refinement step. subroutine sdr_refine_leaf ( proto , geometry ) !--------------------------------------------------------------------------! !> The proto tree description with all the data to refine further type ( sdr_protoTree_type ), intent ( inout ) :: proto !> type which contains all geometry object infos type ( sdr_geometry_type ), intent ( in ) :: geometry !--------------------------------------------------------------------------! integer ( kind = long_k ) :: parent_ID_offset integer ( kind = long_k ) :: parentID integer :: objkind_count ( sdr_object_kinds_max ) integer :: maxLevel integer :: parentProps integer :: iObject , iDist integer :: nObjects integer :: obj_pos , attr_pos , dist_pos integer :: attr_kind integer :: parent_pos integer :: iLevel , iParent integer :: firstParent , lastParent integer :: nNodesOld , nNodes logical :: testAll type ( levelValues_type ) :: leVal type ( grw_longArray_type ) :: grwTreeID !intersected user objects objPos of parent node type ( sdr_intersectObjPos_type ) :: userObjPos !intersected distance objPos of parent node type ( sdr_intersectObjPos_type ) :: distObjPos integer :: child_nodePos ( 8 ) integer :: nDistRefine_objs integer :: memLeft logical :: noSub !integer :: VMHWM !--------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_refineLeaf ) call tem_horizontalSpacer ( funit = logunit ( 1 )) write ( logunit ( 1 ), * ) 'Refining preliminary tree ...' ! Set the length of the level cube length to the complete bounding cube ! length for level=0. ! Set some auxilary data describing the current level. leVal % dx = geometry % universe % extent leVal % ID_offset = tem_FirstIdAtLevel ( 0 ) ! first treeID on this level leVal % level = 0 ! level count ! test all spatial objects in the root node testAll = . true . ! loop over all levels and refine flooded non-intersected leaf node to ! max of minlevel or level of refinement object levelLoop : do iLevel = 1 , globalMaxlevels write ( logunit ( 2 ), \"(A,I0)\" ) 'current level: ' , iLevel ! Reset nNodes nNodes = 0 ! Position of first and last parent in the sorted treeID list. firstParent = proto % levelNode_first ( iLevel - 1 ) lastParent = proto % levelNode_last ( iLevel - 1 ) parent_ID_offset = leVal % ID_offset ! First treeID on parent level ! (save from previous iteration) ! Initialize temporary growing array of treeID for current level call init ( grwTreeID , length = lastParent - firstParent + 1 ) ! Set some auxilary data describing the current level. leVal % dx = 0.5_rk * leVal % dx ! length of cube nodes on this level leVal % ID_offset = tem_FirstIdAtLevel ( iLevel ) ! first treeID on this level leVal % level = iLevel ! level count ! Current number of nodes in current level nNodesOld = proto % levelNode_last ( iLevel ) & & - proto % levelNode_first ( iLevel ) + 1 ! Iterate over all elements on the previous level. parElemLoop : do iParent = firstParent , lastParent ! position of parent node in the sorted list parent_pos = proto % node % treeID % sorted ( iParent ) objkind_count = 0 ! get property of parent node parentProps = ibits ( proto % node % PropertyBits & & % val ( proto % node % propLength , parent_Pos ), & & pos = proto % node % lastbyte_pos , len = 8 ) ! if parent is leaf, flooded and non-intersected by boundary ! than check for maxLevel of the parent for further refinement if ( btest ( parentProps , isFlooded_bit ) . and . & & btest ( parentProps , isLeaf_bit ) ) then ! Only need to refine further if this node is not intersected by a ! boundary and not a target node or node with subelement resolution. ! As they always are fully resolved during the ! protoTree generation before. if ( proto % node % subelement_resolution > 0 ) then noSub = proto % node % subLevel % val ( parent_pos ) < 0 else noSub = . true . end if if ( . not . btest ( parentProps , intersectsBoundary_bit ) . and . & & ( noSub . or . btest ( parentProps , isTarget_bit )) ) then ! Initialize maxLevel maxLevel = proto % node % minLevel % val ( parent_pos ) ! treeID of parent parentID = proto % node % treeID % val ( parent_pos ) ! test sphere object for distance refinement and get max refine ! level if ( proto % node % distanceRefine ) then distObjPos % first = proto % node % distObjPos % val ( parent_pos )% first distObjPos % last = proto % node % distObjPos % val ( parent_pos )% last nDistRefine_objs = distObjPos % last - distObjPos % first + 1 do iDist = distObjPos % first , distObjPos % last dist_pos = proto % node % intersected_distance % val ( iDist ) attr_pos = geometry % spatialObj % val ( dist_pos )% attribute_position maxLevel = max ( maxLevel , & & geometry % attribute % dynArray % val ( attr_pos )% level ) end do else nDistRefine_objs = 0 end if ! Step1: Get max refine level among all intersected objects of the !        parent. if ( testAll ) then userObjPos % first = 1 userObjPos % last = geometry % nUserObjs else userObjPos % first = proto % node % userObjPos % val ( parent_pos )% first userObjPos % last = proto % node % userObjPos % val ( parent_pos )% last end if nObjects = userObjPos % last - userObjPos % first + 1 do iObject = userObjPos % first , userObjPos % last if ( testAll ) then obj_pos = iObject else obj_pos = proto % node % intersected_object % val ( iObject ) end if attr_pos = geometry % spatialObj % val ( obj_pos )% attribute_position attr_kind = geometry % attribute % dynArray % val ( attr_pos )% kind objkind_count ( attr_kind ) = objkind_count ( attr_kind ) + 1 maxLevel = max ( maxLevel , & & geometry % attribute % dynArray % val ( attr_pos )% level ) end do ! Maximum level is already reached, if there are fluidifyable objects ! then set isFluidifyable_bit if ( maxLevel < leVal % level . and . & & objkind_count ( sdr_Fluidifyable_object ) > 0 ) then call sdr_set_nodeProp_bit ( node = proto % node , & & iNode = parent_pos , & & bit = isFluidifyable_bit ) end if ! Step2: if smoothBounds are true, get level of neighbor ! which is intersected with boundary if ( geometry % smoothbounds . and . & & btest ( parentProps , hasBoundary_bit )) then call check_bndLevel ( proto = proto , & & parent = parent_pos , & & parent_ID_offset = parent_ID_offset , & & leVal = leVal , & & maxLevel = maxLevel ) end if ! Step3: If current node is not at its finest level or a neighbor ! node with intersected_boundary is on a finer level, refine the ! current node: ! Append 8 children in the protoTree notreachedmax : if ( maxLevel >= leVal % level ) then ! Create 8 childrens and inherit property bits from parent call create_children ( proto = proto , & & parent = parent_pos , & & child_nodePos = child_nodePos , & & grwTreeID = grwTreeID ) ! Inherit intersected objects from parent to child call inHerit_intersectedObject ( & & proto = proto , & & geometry = geometry , & & parent = parent_pos , & & parentID = parentID , & & testAll = testAll , & & intersected_object = proto % node % intersected_object , & & grwObjPos = proto % node % userObjPos , & & parent_objPos = userObjPos , & & leVal = leVal , & & child_intersected_object = proto % child_intersected_object , & & child_nodePos = child_nodePos , & & memLeft = memLeft , & & isDistRefObj = . false . ) proto % node % memLeft_userObj = proto % node % memLeft_userObj + memLeft ! Inherit intersected distance refine objects from parent to child if ( proto % node % distanceRefine ) then call inHerit_intersectedObject ( & & proto = proto , & & geometry = geometry , & & parent = parent_pos , & & parentID = parentID , & & testAll = . false ., & & intersected_object = proto % node % intersected_distance ,& & grwObjPos = proto % node % distObjPos , & & parent_ObjPos = distObjPos , & & leVal = leVal , & & child_intersected_object = proto % child_intersected_object , & & child_nodePos = child_nodePos , & & memLeft = memLeft , & & isDistRefObj = . true . ) proto % node % memLeft_distObj = proto % node % memLeft_distObj + memLeft end if ! update number of nodes created in this level nNodes = nNodes + 8 end if notreachedmax end if ! not intersected boundary end if ! flooded, leaf bit end do parElemLoop ! Copy treeID of new leaf nodes created in this level to dynamic array ! of treeIDs call append ( proto % node % treeID , grwTreeID % val (: nNodes )) ! destroy temporary growing array of treeID call destroy ( grwTreeID ) ! Set levelNode last for current level with number of nodes ! created in current level proto % levelNode_last ( iLevel ) = proto % levelNode_last ( iLevel ) + nNodes ! update levelNode first and last for next levels proto % levelNode_first ( iLevel + 1 :) = proto % levelNode_first ( iLevel + 1 :) & & + nNodes proto % levelNode_last ( iLevel + 1 :) = proto % levelNode_last ( iLevel + 1 :) & & + nNodes ! The number of elements on the current level write ( logUnit ( 5 ), \"(A,I0)\" ) '  *   new nodes on this level: ' , nNodes write ( logUnit ( 5 ), \"(A,I0)\" ) '  * Total nodes on this level: ' , nNodes + nNodesOld write ( logUnit ( 5 ), \"(A)\" ) '' !VMHWM =  my_status_int('VmHWM:') !write(logUnit(3),*) 'Memory usuage:', VMHWM ! Leave the loop, if no new nodes were created in this iteration. if ( proto % levelNode_first ( iLevel ) > proto % levelNode_last ( iLevel )) exit ! Update the number of levels in the tree, as the current level contains ! new elements and level higher than previous nLevels if ( proto % nLevels < iLevel ) proto % nLevels = iLevel ! after root node deactivate testAll testAll = . false . end do levelLoop ! destroy temporary intersected object call destroy ( proto % child_intersected_object ) ! Clean up memory and free those entries that are not actually needed. call truncate ( proto % node ) call tem_stopTimer ( timerHandle = timer_handle_refineLeaf ) write ( logunit ( 10 ), * ) 'Memory unused in parent intersected_object: ' , & & proto % node % memLeft_userObj write ( logunit ( 10 ), * ) 'Memory unused in parent intersected_distance: ' , & & proto % node % memLeft_distObj end subroutine sdr_refine_leaf ! *************************************************************************** ! *************************************************************************** !> This routine inherit the intersected boundary objects from parent to !! childrens !! !! Update the intersected_first and last for children subroutine inHerit_intersectedObject ( proto , geometry , parent , parentID , & & testAll , intersected_object , & & grwObjPos , parent_objPos , & & leVal , child_intersected_object , & & child_nodePos , memLeft , isDistRefObj ) !--------------------------------------------------------------------------! !> The proto tree description with all the data to refine further type ( sdr_protoTree_type ), intent ( inout ) :: proto !> type which contains all geometry object infos type ( sdr_geometry_type ), intent ( in ) :: geometry !> Position of parent node in protoTree integer , intent ( in ) :: parent !> TreeID of parent integer ( kind = long_k ), intent ( in ) :: parentID !> To test all intersected objects logical , intent ( in ) :: testAll !> Growing array of intersected objects. !! Could be user defined  or distance refine spatial objects type ( grw_intArray_type ), intent ( inout ) :: intersected_object !> First and last position of intersected object of all nodes in !! intersected_object list type ( grw_intersectObjPosArray_type ), intent ( inout ) :: grwObjPos !> Position of first ans last intersected object of parent node !! in intersected_object list type ( sdr_intersectObjPos_type ), intent ( in ) :: parent_objPos !> contains information on current level on which children are created type ( levelValues_type ), intent ( in ) :: leVal !> Temporary array of intersected objects for 8 children type ( grw_intArray_type ), intent ( inout ) :: child_intersected_object !> 8 children node position in protoTree integer , intent ( in ) :: child_nodePos ( 8 ) !> memory of parent intersected object unused by children integer , intent ( out ) :: memLeft !> Is this distance refine objects logical , intent ( in ) :: isDistRefObj !--------------------------------------------------------------------------! integer ( kind = long_k ) :: firstchild_ID integer :: node_coord ( 4 ) integer :: firstchild_coord ( 4 ) integer :: iChild , iObject , obj_pos integer :: child_nObjects ( 8 ) integer :: objLevel integer :: attr_pos integer :: minLevel integer :: prim_pos integer :: prim_kind type ( sdr_intersectObjPos_type ) :: child_objPos ( 8 ) type ( tem_cube_type ) :: node_cube type ( tem_sphere_type ) :: hol_sphere ! hollow sphere !--------------------------------------------------------------------------! ! Get first treeID of parent firstchild_ID = parentID * 8_long_k + 1_long_k ! Get the length of children cube. all children cubes have same length. node_cube % extent = leVal % dx node_cube % halfwidth = 0.5_rk * leVal % dx ! Coordinate of childs can be computed with an offset from ! first child using childCoord parameter firstchild_coord = tem_coordOfId ( treeID = firstchild_ID , & & offset = leVal % ID_offset ) ! Initialize counter for child_intersected_first and last child_objPos (:)% first = 1 child_objPos (:)% last = 0 child_intersected_object % nVals = 0 ! Step5: create children and inherit the intersected object information childLoop : do iChild = 1 , 8 ! minimum level of node minLevel = proto % node % minLevel % val ( parent ) ! Define the children cube to intersect with. node_coord ( 1 : 3 ) = firstchild_coord ( 1 : 3 ) + childCoord ( iChild ,:) node_cube % origin = leVal % dx * node_coord ( 1 : 3 ) + geometry % universe % origin node_cube % endPnt = leVal % dx * ( node_coord ( 1 : 3 ) + 1 ) & & + geometry % universe % origin node_cube % center = node_cube % origin + node_cube % halfwidth ! the first intersected object of this child has to be one after ! all the previous childs intersected objects child_objPos ( iChild :)% first = child_intersected_object % nVals + 1 ! Loop over the objects which intersected with parent to ! determine objects intersected with child do iObject = parent_objPos % first , parent_objPos % last if ( testAll ) then obj_pos = iObject else obj_pos = intersected_object % val ( iObject ) end if attr_pos = geometry % spatialObj % val ( obj_pos )% attribute_position objLevel = geometry % attribute % dynArray % val ( attr_pos )% level ! Test for intersection of geometric object and node cube. if ( is_intersecting ( node_cube , geometry , obj_pos )) then ! Inherit objects only if objLevel >= current level and minLevel if ( objLevel > max ( minLevel , leVal % level )) then ! For sphere objects check if node is inside sphere ! of intersected with sphere surface. ! This can be determined by checking intersection with ! hollow sphere prim_pos = geometry % spatialObj % val ( obj_pos )% primitive_position prim_kind = geometry % spatialObj % val ( obj_pos )% geometry_primitive if ( prim_kind == sphere . and . isDistRefObj ) then hol_sphere = geometry % sphere % val ( prim_pos ) hol_sphere % only_surface = . true . ! if hollow sphere intersect with node then append ! this object to intersected object list if ( tem_sphereCubeOverlap ( hol_sphere , node_cube )) then call append ( child_intersected_object , obj_pos ) else ! node is inside sphere ! ! maximum level amoung intersected objects minLevel = max ( minLevel , objLevel ) end if else ! If geometry is not a sphere then add the object to the ! intersected_object list of the child. call append ( child_intersected_object , obj_pos ) end if !if object is sphere end if ! objLevel>mylevel end if !intersected end do !iObject ! Set minLevel to which this node to be refined proto % node % minLevel % val ( child_nodePos ( iChild )) = minLevel ! Set child intersected object first and last in child_intersected_object child_objPos ( iChild :)% last = proto % child_intersected_object % nVals child_nObjects ( iChild ) = child_objPos ( iChild )% last & & - child_objPos ( iChild )% first + 1 end do childLoop ! Now copy temporary growing array of intersected objects of child ! to actual array of intersected_objects call sdr_append_childIntersectedObject ( & & geometry = geometry , & & node = proto % node , & & parent = parent , & & testAll = testAll , & & intersected_object = intersected_object , & & grwObjPos = grwObjPos , & & child_nodePos = child_nodePos , & & child_intersected_object = child_intersected_object , & & child_objPos = child_objPos , & & memLeft = memLeft ) end subroutine inHerit_intersectedObject ! *************************************************************************** ! *************************************************************************** !> This routine checks if neighbor node with intersected boundary is level !! higher than current node level. !! !! If neighbor node is intersected boundary bit but no a leaf or target or !! node with qVal than refine current node. subroutine check_bndLevel ( proto , parent , parent_ID_offset , leVal , maxLevel ) !--------------------------------------------------------------------------! !> preliminary tree on which childern are created type ( sdr_protoTree_type ), intent ( inout ) :: proto !> Position of parent node on the dynamic array of node%treeID and node_data !! in preliminary tree integer , intent ( in ) :: parent !> first treeID of the parent integer ( kind = long_k ), intent ( in ) :: parent_ID_offset !> contains information on current level on which children are created type ( levelValues_type ), intent ( in ) :: leVal !> Maximum level to refine current node integer , intent ( inout ) :: maxLevel !--------------------------------------------------------------------------! integer :: iDir integer :: coord ( 4 ) integer :: neighbor_level integer :: neighbor_pos logical :: refine_for_neighbor !--------------------------------------------------------------------------! ! Get coordinate of current element coord = tem_CoordOfId ( treeID = proto % node % treeID % val ( parent ), & & offset = parent_ID_offset ) ! loop over all 26 directions do iDir = 1 , qQQQ ! get position of neighbor in the protoTree which might me ! from different level neighbor_pos = sdr_neighbor_in_proto ( proto , coord , iDir , & & neighbor_level ) if ( sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = intersectsBoundary_bit ) ) then ! Neighbor is intersected by a boundary, now we check if we need to ! refine further down. ! If neighbor_pos is not a leaf or target node, refine the fluid ! element to bnd_level if smoothbounds are active. refine_for_neighbor & & = . not . ( sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = isLeaf_bit ) & & . or . sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = isTarget_bit ) ) if ( refine_for_neighbor ) then ! Only refine, if smoothbounds are requested, or the neighbor is ! the actual boundary. This might happen, if the boundary is ! covering a complete element on a coarser level, then it is ! refined to and the flooded neighbor is not refined down to that ! level yet. ! This affects all parent levels and therefore might influence a ! large part of the mesh, which might not be desired, thus it can ! be deactivated by the smoothbounds setting. maxLevel = max ( maxLevel , leVal % level ) end if end if end do end subroutine check_bndLevel ! *************************************************************************** ! *************************************************************************** !> This routine smoothens fluid domain with maximum level jumps of 1. !! !! This is done by running over all leaf, flooded, non-intersected node !! at each level and check for neighbor in all 26 directions. !! If neighbor exist in protoTree and is not a leaf then get eligible !! children of neighbor in the inverse direction of iDir and check !! if any of eligible children is not a leaf then refine myself. !! !! Algorithm: !! Iterate over minLevel, maxLevel-2 !! - Iterate over all nodes in iLevel !!   + if iNode is leaf, flooded and non intersected boundary !!     * Iterate over 26 directions !!       ++ if neighbor in iDir exist in protoTree and not a leaf !!          ** get eligible children of neighbor in inverse iDir !!            -- if any of eligible children in protoTree is not a leaf !!               +++ refine iNode subroutine sdr_smooth_leaf ( proto , header , maxLevel ) !--------------------------------------------------------------------------! !> preliminary tree on which childern are created type ( sdr_protoTree_type ), intent ( inout ) :: proto !> some global information on solver name and version type ( sdr_confHead_type ), intent ( inout ) :: header !> Maximum level in the fluid domain integer , intent ( in ) :: maxLevel !--------------------------------------------------------------------------! integer :: iLevel , iWave , iParent , iDir , iChild integer :: parent_pos , neighbor_pos integer :: parentProps integer :: nNodes_total , nNodes_level , nNodesOld integer :: firstParent , lastParent integer :: coord ( 4 ) integer :: offset ( 4 ), neighbor_coord ( 4 ) integer ( kind = long_k ) :: neighbor_tID integer ( kind = long_k ) :: parent_ID_offset integer , allocatable :: eligible_childs (:) integer :: eligible_childPos logical :: isChildLeaf ( 8 ) logical :: isChildTarget ( 8 ) type ( grw_longArray_type ) :: grwTreeID integer :: child_nodePos ( 8 ) logical :: noSub logical :: neigh_noLeaf , neigh_noTarget , neigh_noSub !--------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_smoothLeaf ) call tem_horizontalSpacer ( funit = logunit ( 1 )) write ( logunit ( 1 ), * ) 'Smooth levels ...' iWave = 0 ! Leave loop when no new nodes are created waves : do ! Wave count iWave = iWave + 1 write ( logunit ( 2 ), \"(A,I0)\" ) ' current wave ' , iWave ! number of nodes in protoTree nNodes_total = proto % node % nNodes ! Start from 2nd coarsest level to 2nd finest level. ! In every wave, we could reduce loop to -2 level since ! all neccessary nodes are already created in that level. ! In this loop, we create new nodes of the iLevel ! so we run over nodes in iLevel-1 to create children in iLevel do iLevel = header % minLevel + 1 , maxLevel - iWave write ( logunit ( 2 ), \"(A,I0)\" ) 'current level ' , iLevel ! Position of first and last treeID in current level in sorted treeID list firstParent = proto % levelNode_first ( iLevel - 1 ) lastParent = proto % levelNode_last ( iLevel - 1 ) ! first treeID on parent level parent_ID_offset = tem_FirstIdAtLevel ( iLevel - 1 ) ! Initialize temporary growing array of treeID for current level call init ( grwTreeID , length = lastParent - firstParent + 1 ) ! Count number of new nodes created in this level nNodes_level = 0 ! Current number of nodes in current level nNodesOld = proto % levelNode_last ( iLevel ) & & - proto % levelNode_first ( iLevel ) + 1 ! Iterate over all nodes in previous level to create nodes ! in current level do iParent = firstParent , lastParent ! position of parent node in the sorted list parent_pos = proto % node % treeID % sorted ( iParent ) ! get property of parent node parentProps = ibits ( proto % node % PropertyBits & & % val ( proto % node % propLength , parent_pos ), & & pos = proto % node % lastbyte_pos , len = 8 ) ! if parent node is leaf, flooded  and non-intersected ! by boundary than check for neighbor level if ( btest ( parentProps , isFlooded_bit ) . and . & & btest ( parentProps , isLeaf_bit ) ) then ! Only need to refine further if this node is not intersected by a ! boundary and not a target node or node with subelement resolution. ! As they always are fully resolved during the ! protoTree generation before. if ( proto % node % subelement_resolution > 0 ) then noSub = proto % node % subLevel % val ( parent_pos ) < 0 else noSub = . true . end if if ( . not . btest ( parentProps , intersectsBoundary_bit ) . and . & & ( noSub . or . btest ( parentProps , isTarget_bit )) ) then ! Get coordinate of current element coord = tem_CoordOfId ( & & treeID = proto % node % treeID % val ( parent_pos ), & & offset = parent_ID_offset ) offset = 0 neighbor_coord = 0 ! loop over all 26 directions and get position of neighbor in ! protoTree dirLoop : do iDir = 1 , qQQQ offset ( 1 : 3 ) = qOffset ( iDir ,:) neighbor_coord = coord + offset neighbor_tID = tem_IdOfCoord ( coord = neighbor_coord ) neighbor_pos = PositionOfVal ( & & me = proto % node % treeID , & & val = neighbor_tID , & & lower = proto % levelNode_first ( iLevel - 1 ), & & upper = proto % levelNode_last ( iLevel - 1 ) ) ! neighbor tID exist in protoTree on the iLevel if ( neighbor_pos > 0 ) then ! create children when neighbor is not a leaf and ! neither target bit or subelement neigh_noLeaf = . not . sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos , & & bit = isLeaf_bit ) neigh_noTarget = . not . sdr_nodeProp_btest ( node = proto % node , & & iNode = neighbor_pos ,& & bit = isTarget_bit ) if ( proto % node % subelement_resolution > 0 ) then neigh_noSub = proto % node % subLevel % val ( neighbor_pos ) < 0 else neigh_noSub = . true . end if ! if neighbor is virtual node if ( neigh_noLeaf . and . ( neigh_noSub . or . neigh_noTarget )) then ! treeIDs of children ! childID(1:8) = tem_directChildren(neighbor_tID) ! get eligible children in inverse of iDir call tem_eligibleChildren ( eligible_childs , qInvDir ( iDir )) ! set default all child to leaf isChildLeaf = . true . isChildTarget = . true . do iChild = 1 , size ( eligible_childs ) ! position of eligible childrens in protoTree ! since they are continous in memory we could find ! it with an offset given by eligible_childs ! and linkPos(1) of parent eligible_childPos = proto % node % linkPos ( 1 )% val ( neighbor_pos ) & & + eligible_childs ( iChild ) - 1 isChildLeaf (( eligible_childs ( iChild ))) = & & sdr_nodeProp_btest ( node = proto % node , & & iNode = eligible_childPos , & & bit = isLeaf_bit ) isChildTarget (( eligible_childs ( iChild ))) = & & sdr_nodeProp_btest ( node = proto % node , & & iNode = eligible_childPos , & & bit = isTarget_bit ) end do deallocate ( eligible_childs ) ! if any child is not a leaf or target refine my self if ( . not . all ( isChildLeaf . or . isChildTarget ) ) then !write(*,*) 'isChildLeaf ', isChildLeaf ! For this childrens, we inherit only property from ! parent. Interected objects are not inherited since ! parent it already refined at maximum level of its ! refinement object. call create_children ( proto = proto , & & parent = parent_pos , & & child_nodePos = child_nodePos , & & grwTreeID = grwTreeID ) nNodes_level = nNodes_level + 8 ! exit dirLoop and go to next node in level exit dirLoop end if ! atleast one child is not leaf end if !neighbor is not a leaf end if !neighbor exist in protoTree end do dirLoop end if ! not intersected boundary end if ! flooded leaf node end do ! iNode ! Copy treeID of new leaf nodes created in this level to dynamic array ! of treeIDs call append ( proto % node % treeID , grwTreeID % val (: nNodes_level )) ! destroy temporary growing array of treeID call destroy ( grwTreeID ) ! Set levelNode last for next level with number of nodes ! created in next level proto % levelNode_last ( iLevel ) = proto % levelNode_last ( iLevel ) & & + nNodes_level ! update levelNode first and last for next levels proto % levelNode_first ( iLevel + 1 :) = proto % levelNode_first ( iLevel + 1 :) & & + nNodes_level proto % levelNode_last ( iLevel + 1 :) = proto % levelNode_last ( iLevel + 1 :) & & + nNodes_level ! The number of elements on the current level write ( logUnit ( 3 ), \"(A,I0)\" ) '  *   new nodes on this level: ' , nNodes_level write ( logUnit ( 3 ), \"(A,I0)\" ) '  * Total nodes on this level: ' , & & nNodes_level + nNodesOld write ( logunit ( 3 ), * ) '' end do ! ilevel ! exit loop when no new nodes are created if ( nNodes_total == proto % node % nNodes ) exit waves end do waves write ( logUnit ( 1 ), \"(A,I0)\" ) ' done in nWaves ' , iWave call tem_stopTimer ( timerHandle = timer_handle_smoothLeaf ) end subroutine sdr_smooth_leaf ! *************************************************************************** ! *************************************************************************** !> This routine append 8 children to protoTree and inherit property bits from !! parent. leaf bit is removed from parent. subroutine create_children ( proto , parent , child_nodePos , grwTreeID ) !--------------------------------------------------------------------------! !> preliminary tree on which childern are created type ( sdr_protoTree_type ), intent ( inout ) :: proto !> Position of parent node on the dynamic array of node%treeID and node_data !! in preliminary tree integer , intent ( in ) :: parent !> 8 children node position in protoTree integer , intent ( out ) :: child_nodePos ( 8 ) !> Temporary growing array of TreeID contains new leaf nodes in current level type ( grw_longArray_type ), intent ( inout ) :: grwTreeID !--------------------------------------------------------------------------! integer :: iChild integer ( kind = long_k ) :: treeID ( 1 : 8 ) integer :: child_sublevel integer :: propbits ( proto % node % propLength ) logical :: child_hasBnd ( 8 ) integer :: minLevel !--------------------------------------------------------------------------! ! If parent has hasBoundary_bit then inherit this property to its ! eligible children child_hasBnd = sdr_inHeritBnd_eligibleChildren ( proto % node , parent ) ! Get treeID of eight children treeID ( 1 : 8 ) = tem_directChildren ( proto % node % treeID % val ( parent )) ! Inherit the property bits to children propBits = proto % node % PropertyBits % val (:, parent ) ! remove leaf bit from parent node call sdr_clear_nodeProp_bit ( node = proto % node , & & iNode = parent , & & bit = isLeaf_bit ) ! set position of first child at linkPos(1) of parent node proto % node % linkPos ( 1 )% val ( parent ) = proto % node % nNodes + 1 ! Increase the counter for proto%nLeafNodes and proto%nFloodedLeaves ! Since we create 8 new children in place of 1 parent we just ! increase this counter by 7 proto % nLeafNodes = proto % nLeafNodes + 7 proto % nFloodedLeaves = proto % nFloodedLeaves + 7 if ( proto % node % subelement_resolution > 0 ) then child_sublevel = proto % node % sublevel % val ( parent ) - 1 else ! If there is no subelement resolution the sublevels are not available. ! However, we store a negative value here in child_sublevel to avoid ! further checks for subelement_resolution further down. child_sublevel = - 1 end if minLevel = proto % node % minLevel % val ( parent ) ! create children and inherit the intersected object information childLoop : do iChild = 1 , 8 ! append this child to tree and inherit minLevel of parent to child ! since for distance refine objects if node is inside this ! distance than refine this node to minLevel call append ( me = proto % node , & & treeID = treeID ( iChild ), & & grwTreeID = grwTreeID , & & PropertyBits = propBits , & & sublevel = child_sublevel , & & minLevel = minLevel , & & pos = child_nodePos ( iChild ) ) ! if this child hasBnd, set the hasBoundary_bit ! and copy the directions which has boundary from parent. ! if parent has boundary in certain direction, its child should have ! the save since hasBoundary is set by the leaf of intersected ! boundary node if ( child_hasBnd ( iChild )) then call sdr_set_nodeProp_bit ( node = proto % node , & & iNode = child_nodePos ( iChild ), & & bit = hasBoundary_bit ) proto % node % hasBndBits % val ( child_nodePos ( iChild )) = & & proto % node % hasBndBits % val ( parent ) end if end do childLoop end subroutine create_children ! *************************************************************************** end module sdr_refinePT_module ! ***************************************************************************","tags":"","url":"sourcefile/sdr_refinept_module.f90.html"},{"title":"sdr_subres_fills_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_subres_fills_module.f90~~AfferentGraph sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2014 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module sdr_subres_fills_module use env_module , only : rk , labelLen use flu_binding , only : flu_State use aotus_module , only : aot_get_val , flu_State , & & aoterr_Fatal use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_tools_module , only : upper_to_lower use tem_dyn_array_module , only : dyn_labelArray_type , init , append use tem_grow_array_module , only : grw_realArray_type , init , append implicit none !> Definition of values to use for colors in polynomial representations. type sdr_subres_fills_type !> Name of the color, to which the color values apply. type ( dyn_labelArray_type ) :: label !> Actual value to use, where the color is present, defaults to 1. !!@todo HK: replace by spatial function type ( grw_realArray_type ) :: fill !> Actual value to use, where the color is not present, defaults to 0. type ( grw_realArray_type ) :: void end type sdr_subres_fills_type public :: sdr_subres_fills_type public :: sdr_subres_fills_load public :: sdr_subres_fills_add contains ! ****************************************************************************! !> Add a value definition for a color to the list of fillings. subroutine sdr_subres_fills_add ( fills , colorname , fill_value , void_value , & & pos , wasAdded ) ! --------------------------------------------------------------------------! !> Table of color values to add a color definition to. type ( sdr_subres_fills_type ), intent ( inout ) :: fills !> Name of the color to define values for. character ( len =* ), intent ( in ) :: colorname !> Value to use, where the domain is flooded by color. real ( kind = rk ), intent ( in ) :: fill_value !> Value to use, where the domain is NOT flooded by color. real ( kind = rk ), intent ( in ) :: void_value !> Position of this color in the list of color values. integer , intent ( out ) :: pos !> Indicator, if this value definition was added to the list. logical , intent ( out ) :: wasAdded ! --------------------------------------------------------------------------! ! --------------------------------------------------------------------------! call append ( fills % label , upper_to_lower ( trim ( colorname )), & & pos = pos , wasAdded = wasAdded ) if ( wasAdded ) then call append ( fills % fill , fill_value ) call append ( fills % void , void_value ) end if end subroutine sdr_subres_fills_add ! ****************************************************************************! ! ****************************************************************************! !> Load the filling definition for subresolved colors. !! !! A filling is defined by a value for the area where the domain is flooded !! by the color specified in the label and a value for the remaining part !! of the domain without flooding. !! !! The filling information has to be provided as a list of tables in the !! following form within the subresolution definition: !! \\code{.lua} !! values = { !!            { label = 'colA', fill = 1.0, void = 0.0 }, !!            { label = 'colB', fill = 9.0, void = 0.1 } !!          } !! \\endcode !! Defaults are: fill=1.0, void=0.0. subroutine sdr_subres_fills_load ( fills , conf , parent ) ! --------------------------------------------------------------------------! !> Value definitions for individual colors. type ( sdr_subres_fills_type ), intent ( out ) :: fills !> Handle for the Lua script. type ( flu_State ) :: conf !> Parent table, within which to open the fills table. integer , intent ( in ) :: parent ! --------------------------------------------------------------------------! integer :: thandle integer :: nValues integer :: iValue ! --------------------------------------------------------------------------! call aot_table_open ( L = conf , parent = parent , thandle = thandle , & & key = 'values' ) if ( thandle > 0 ) then nValues = aot_table_length ( L = conf , thandle = thandle ) call init ( fills % label , length = nValues ) call init ( fills % fill , length = nValues ) call init ( fills % void , length = nValues ) do iValue = 1 , nValues call load_single_fill ( fills = fills , & & conf = conf , & & parent = thandle , & & pos = iValue ) end do end if end subroutine sdr_subres_fills_load ! ****************************************************************************! ! ****************************************************************************! !> Load the value fill definition for a single color. !! !! !! The filling information has to be provided as a table with the label of !! the color, the fill value to use, where the color is present and the void !! value for the rest of the domain: !! \\code{.lua} !!            { label = 'colA', fill = 1.0, void = 0.0 }, !! \\endcode !! !! Defaults are: fill=1.0, void=0.0. !! Note that the keys can be left out, and assignment by position is possible. subroutine load_single_fill ( fills , conf , parent , pos ) ! --------------------------------------------------------------------------! !> Value definitions for individual colors. type ( sdr_subres_fills_type ), intent ( inout ) :: fills !> Handle for the Lua script. type ( flu_State ) :: conf !> Parent table, within which to open the fills table. integer , intent ( in ) :: parent !> Position in the table of fills to load. integer , intent ( in ) :: pos ! --------------------------------------------------------------------------! integer :: thandle character ( len = labelLen ) :: cLabel real ( kind = rk ) :: fill_value real ( kind = rk ) :: void_value integer :: iError integer :: colpos logical :: wasAdded ! --------------------------------------------------------------------------! call aot_table_open ( L = conf , parent = parent , thandle = thandle , & & pos = pos ) ! The label of the color for which we set the value is either in position 1 ! or in the key label. call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'label' , & & pos = 1 , & & val = clabel , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logunit ( 0 ), * ) & & 'FATAL Error occured while retrieving a filling color name!' call tem_abort () end if ! The filling value is either found with the key fill, or as second ! argument. call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'fill' , & & pos = 2 , & & val = fill_value , & & default = 1.0_rk , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logunit ( 0 ), * ) & & 'FATAL Error occured while retrieving a filling value for color ' & & // trim ( clabel ) call tem_abort () end if ! The void value is either found with the key void, or as third argument. call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'void' , & & pos = 3 , & & val = void_value , & & default = 0.0_rk , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logunit ( 0 ), * ) & & 'FATAL Error occured while retrieving a void value for color ' & & // trim ( clabel ) call tem_abort () end if call aot_table_close ( L = conf , thandle = thandle ) ! Now add the color values to the list. call sdr_subres_fills_add ( fills = fills , & & colorname = cLabel , & & fill_value = fill_value , & & void_value = void_value , & & pos = colpos , & & wasAdded = wasAdded ) if (. not . wasAdded ) then write ( logunit ( 1 ), * ) 'WARNING: subresolution values for color ' , cLabel write ( logunit ( 1 ), * ) 'already in the list!' write ( logunit ( 1 ), * ) 'Keep in mind that color names are case' & & // ' insensitive.' end if end subroutine load_single_fill ! ****************************************************************************! end module sdr_subres_fills_module","tags":"","url":"sourcefile/sdr_subres_fills_module.f90.html"},{"title":"ply_sampled_tracking_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_sampled_tracking_module.f90~~AfferentGraph sourcefile~ply_sampled_tracking_module.f90 ply_sampled_tracking_module.f90 sourcefile~sdr_harvesting.f90 sdr_harvesting.f90 sourcefile~sdr_harvesting.f90->sourcefile~ply_sampled_tracking_module.f90 sourcefile~sdr_hvs_config_module.f90 sdr_hvs_config_module.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_config_module.f90 sourcefile~sdr_hvs_config_module.f90->sourcefile~ply_sampled_tracking_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016,2018,2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2016-2017 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2018 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! Copyright (c) 2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Kannan Masilamani, ! Daniel Fleischer, Peter Vitt, Jiaxing Qi and Nikhil Anand for University of ! Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Tracking offers the possibility to extract data from a simulation for given !! subsections of the mesh and specific points in time. !! !! When the data is given in form of polynomials, it usually is required to !! perform some kind of sampling to obtain a visualization. !! The `ply_sampled_tracking` implements this functionality. !! See [[ply_sampling_module]] for details on the configuration of the sampling !! strategy and [[tem_tracking_module]] for details on the general configuration !! of trackings (description of mesh subsections to extract data for). !! !! An important special case is the tracking of a single point. !! In this case no sampling has to be done, instead the polynomial representing !! the state in the element that contains the requested point needs to be !! evaluated at this point. This can be configured by setting !! `use_get_point=true` in the output subtable of the tracking object. !! !! A complete example looks like this: !! !!```lua !!tracking = { !!  label = 'track_shearhat2D', !!  folder = './', !!  variable = {'momentum','density','energy'}, !!  shape = { !!    kind = 'canoND', !!    object= { !!      origin ={0.01*dx, 0., 0.} !!    } !!  }, !!  time_control = { !!    min = 0, !!    max = sim_control.time_control.max, !!    interval = {iter = 10} !!  }, !!  output = { !!    format = 'ascii', !!    use_get_point = true !!  } !!} !!``` !! !! This tracks the state variables (momentum, density and energy) in a single !! point `(0.01*dx, 0, 0)` and writes them every ten iteration to an ASCII file. !! Each point in time gets written on a new line in the same file. !! If you do not use the `use_get_point` option (its `false` by default), and no !! sampling is active, all degrees of freedom of the field in the element, that !! contains the point, will be written. !! You can limit the number of degrees of freedom by setting `ndofs` to some !! value. The first mode of the Legendre series is the integral mean, so this is !! usually the value you want to get. Thus, setting `ndofs=1` gives you the !! averaged value of the element the point is found in. !! The according output table would then look as follows: !! !!```lua !!  output = { !!    format = 'ascii', !!    ndofs = 1 !!  } !!``` !! !! Of course, more complex shapes may be tracked, in that case it usually is !! not sensible to use `ascii` output anymore. Instead you are than likely to !! want to view data later on and accordingly write it in VTK format. !! For this, a sampling table (see [[ply_sampling_module]]) should be !! considered. module ply_sampled_tracking_module use aotus_module , only : flu_State use hvs_output_module , only : hvs_output_init , & & hvs_output_open , & & hvs_output_write , & & hvs_output_close use env_module , only : pathLen use treelmesh_module , only : treelmesh_type , & & free_treelmesh use tem_aux_module , only : tem_abort use tem_bc_prop_module , only : tem_bc_prop_type use tem_comm_env_module , only : tem_comm_env_type use tem_logging_module , only : logunit use tem_reduction_spatial_module , only : tem_reduction_spatial_init use tem_simControl_module , only : tem_simControl_type use tem_solveHead_module , only : tem_solveHead_type use tem_stencil_module , only : tem_stencilHeader_type use tem_time_module , only : tem_time_type , & & tem_time_reset use tem_tracking_module , only : tem_tracking_type , & & tem_tracker , & & tem_init_tracker , & & tem_tracking_has_triggered , & & tem_init_tracker_subtree , & & tem_load_tracking use tem_varMap_module , only : tem_create_varMap use tem_varSys_module , only : tem_varsys_type , & & tem_empty_varSys use ply_sampling_module , only : ply_sampling_type , & & ply_sampling_load , & & ply_sampling_free_methodData , & & ply_sample_data implicit none private type ply_sampled_tracking_type !> Contains all tracking headers, control and tracking entities !! active on local process type ( tem_tracking_type ) :: tracking !> Subsampled mesh for each tracking. !! !!@todo Actually make use of these, instead of regenerating the mesh !!      every time the tracking is written. type ( treelmesh_type ), allocatable :: mesh (:) !> Variable system description after subsampling. !! !!@todo Actuall make use of these, instead of recreating the variable !!      system each time a tracking is written. type ( tem_varSys_type ), allocatable :: varsys (:) !> Configuration of the subsampling (applied to all trackings). type ( ply_sampling_type ) :: sampling !> Dimensionality of the data to sample. integer :: ndims end type ply_sampled_tracking_type public :: ply_sampled_tracking_type public :: ply_sampled_tracking_load public :: ply_sampled_track_init public :: ply_sampled_track_output contains ! ------------------------------------------------------------------------ ! !> Load the configuration of sampled tracking objects. subroutine ply_sampled_tracking_load ( me , conf ) ! -------------------------------------------------------------------- ! !> Sampled tracking data to load from the config type ( ply_sampled_tracking_type ), intent ( out ) :: me !> Lua config to load the tracking from type ( flu_State ) :: conf ! -------------------------------------------------------------------- ! call ply_sampling_load ( me = me % sampling , & & conf = conf ) call tem_load_tracking ( me = me % tracking , & & conf = conf ) end subroutine ply_sampled_tracking_load ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Initialize the sampled tracking entities. !! !! This is necessary to properly setup the tem_tracking data. !! It includes building the subtree and the varmap. subroutine ply_sampled_track_init ( me , mesh , solver , varSys , bc , & & stencil , proc , ndofs , ndims ) ! -------------------------------------------------------------------- ! !> Sampled tracking variable to initialize. It has to be configured by !! [[ply_sampled_tracking_load]] beforehand. type ( ply_sampled_tracking_type ), intent ( inout ) :: me !> The global mesh. type ( treelmesh_type ), intent ( in ) :: mesh !> Information about the solver (used to construct file name strings). type ( tem_solveHead_type ), intent ( in ) :: solver !> Global variable system with description of the data to get the !! tracking variables from. type ( tem_varSys_type ), intent ( in ) :: varSys !> Boundary condition properties, used to identify elements close to !! the boundary. type ( tem_bc_prop_type ), intent ( in ) :: bc !> Description of the stencil in the numerical scheme. !! !! This is needed to describe elements adjacent to specific boundary !! labels. type ( tem_stencilHeader_type ), optional , intent ( in ) :: stencil !> General communication environment type ( tem_comm_env_type ), intent ( in ) :: proc !> Number of degrees of freedom to use in the output. integer , intent ( in ) :: nDofs !> Number of dimensions in the polynomial representations. integer , intent ( in ) :: nDims ! -------------------------------------------------------------------- ! integer :: iTrack , iConfig integer :: iVar integer :: nVars character ( len = pathLen ) :: basename ! -------------------------------------------------------------------- ! ! Initialize tracker subTree and remove empty trackers. call tem_init_tracker_subTree ( me = me % tracking , & & tree = mesh , & & solver = solver , & & bc_prop = bc , & & stencil = stencil ) me % nDims = nDims if ( me % sampling % max_nlevels == 0 ) then ! No subsampling to be done, call the general initialization and ! exit the routine. call tem_init_tracker ( me = me % tracking , & & tree = mesh , & & solver = solver , & & varSys = varSys , & & nDofs = nDofs , & & globProc = proc ) RETURN end if do iTrack = 1 , me % tracking % control % nActive iConfig = me % tracking % instance ( iTrack )% pntConfig ! map variables ! create tracking variable position in the global varSys call tem_create_varMap ( varname = me % tracking % config ( iConfig )% varname , & & varSys = varSys , & & varMap = me % tracking % instance ( iTrack )% varMap ) nVars = me % tracking % instance ( iTrack )% varMap % varPos % nVals ! Abort if none of the variables defined in current ! tracking object are found in varSys if ( nVars == 0 ) then write ( logUnit ( 1 ), * ) 'Error: Requested variables: ' do iVar = 1 , size ( me % tracking % config ( iConfig )% varName ) write ( logUnit ( 1 ), * ) iVar , & & trim ( me % tracking % config ( iConfig )% varName ( iVar )) end do write ( logUnit ( 1 ), * ) 'not found in varSys.' write ( logUnit ( 1 ), * ) 'Check tracking object: ' // & & trim ( me % tracking % config ( iConfig )% label ) call tem_abort () end if ! Init spatial reduction me % tracking % instance ( iTrack )% output_file % ascii % isReduce & & = me % tracking % config ( iConfig )% redSpatial_config % active if ( me % tracking % config ( iConfig )% redSpatial_config % active ) then call tem_reduction_spatial_init ( & & me = me % tracking % instance ( iTrack )% output_file & & % ascii % redSpatial , & & redSpatial_config = me % tracking % config ( iConfig )% redSpatial_config , & & varSys = varSys , & & varPos = me % tracking % instance ( iTrack )% varMap % varPos & & % val (: nVars ) ) end if if ( me % tracking % config ( iConfig )% output_config % useGetPoint ) then ! For point trackings do the initialization here, as no subsampling is ! required for them. basename = trim ( me % tracking % config ( iConfig )% prefix ) & & // trim ( me % tracking % config ( iConfig )% label ) if ( me % tracking % instance ( iTrack )% subTree % useGlobalMesh ) then call hvs_output_init ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & out_config = me % tracking % config ( iConfig )% output_config , & & tree = mesh , & & varSys = varsys , & & varPos = me % tracking % instance ( iTrack )% varMap % varPos & & % val (: nVars ), & & geometry = me % tracking % config ( iConfig )% geometry , & & basename = trim ( basename ), & & globProc = proc , & & solver = solver ) else call hvs_output_init ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & out_config = me % tracking % config ( iConfig )% output_config , & & tree = mesh , & & subtree = me % tracking % instance ( iTrack )% subtree , & & varSys = varsys , & & varPos = me % tracking % instance ( iTrack )% varMap % varPos & & % val (: nVars ), & & geometry = me % tracking % config ( iConfig )% geometry , & & basename = trim ( basename ), & & globProc = proc , & & solver = solver ) end if end if end do if ( me % tracking % control % nActive > 0 ) then allocate ( me % mesh ( me % tracking % control % nActive )) allocate ( me % varsys ( me % tracking % control % nActive )) end if end subroutine ply_sampled_track_init ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Output sampled tracking data. !! !! Iterates over all tracking instances in the given me variable, checks !! whether it should be written at the current point in time (if simControl !! is provided), subsamples the data and performs the hvs_output for the !! subsampled data. !! !!@todo Instead of recreating the sampled varsys and mesh everytime the !!      tracking is written, store them in the [[ply_sampled_tracking_type]]. subroutine ply_sampled_track_output ( me , mesh , bc , solver , proc , varSys , & & var_degree , lvl_degree , var_space , & & simControl , time ) ! -------------------------------------------------------------------- ! !> Sampled tracking instances. type ( ply_sampled_tracking_type ), intent ( inout ) :: me !> Global mesh, required for the sampling. type ( treelmesh_type ), intent ( in ) :: mesh !> Boundary properties, needed to inherit boundary information to refined !! meshes and allow the extraction of boundary shape geometries. type ( tem_bc_prop_type ), intent ( in ) :: bc !> Information about the solver, needed for the output file name. type ( tem_solveHead_type ), intent ( in ) :: solver !> General communication environment type ( tem_comm_env_type ), intent ( in ) :: proc !> Original variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> Maximal polynomial degree for each variable !! !! Needs to match the size of the variable system. integer , intent ( in ) :: var_degree (:) !> Maximal polynomial degree for each level integer , intent ( in ) :: lvl_degree (:) !> Maximal polynomial space for each variable !! !! Needs to match the size of the variable system. integer , intent ( in ) :: var_space (:) !> Simulation control to determine, whether trackings should be written !! !! If not provided, all trackings will be written unconditionally. type ( tem_simControl_type ), intent ( in ), optional :: simControl !> Provide a time for the current data set to write in tracking. !! !! This only is respected if no simControl is provided. If simControl !! is present the time information from it will be used instead. type ( tem_time_type ), intent ( in ), optional :: time ! -------------------------------------------------------------------- ! character ( len = pathLen ) :: basename type ( tem_time_type ) :: loctime type ( tem_varsys_type ) :: sampled_vars type ( treelmesh_type ) :: sampled_mesh type ( tem_comm_env_type ) :: sampled_proc integer :: iTrack , iConfig integer :: iVar ! -------------------------------------------------------------------- ! call tem_time_reset ( loctime ) if ( present ( simControl )) then loctime = simControl % now else loctime = time end if if ( me % sampling % max_nlevels == 0 ) then if ( present ( simControl )) then ! No subsampling to be done, call the regular tracker, and leave ! the routine. call tem_tracker ( track = me % tracking , & & simControl = simControl , & & varSys = varsys , & & tree = mesh ) else do iTrack = 1 , me % tracking % control % nActive iConfig = me % tracking % instance ( iTrack )% pntConfig if ( me % tracking % instance ( iTrack )% subTree % useGlobalMesh ) then call hvs_output_open ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & use_iter = me % tracking % config ( iConfig )% output_config & & % vtk & & % iter_filename , & & mesh = mesh , & & varsys = varsys , & & time = time ) call hvs_output_write ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varsys = varsys , & & mesh = mesh ) call hvs_output_close ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varSys = varsys , & & mesh = mesh ) else ! use subtree call hvs_output_open ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & use_iter = me % tracking % config ( iConfig )% output_config & & % vtk & & % iter_filename , & & mesh = mesh , & & varsys = varsys , & & subTree = me % tracking % instance ( iTrack )% subTree , & & time = time ) call hvs_output_write ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varsys = varsys , & & subTree = me % tracking % instance ( iTrack )% subTree , & & mesh = mesh ) call hvs_output_close ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varSys = varsys , & & subTree = me % tracking % instance ( iTrack )% subTree , & & mesh = mesh ) end if ! useGlobalMesh end do ! iTrack=1,me%tracking%control%nActive end if RETURN end if do iTrack = 1 , me % tracking % control % nActive iConfig = me % tracking % instance ( iTrack )% pntConfig if ( present ( simControl )) then ! If a simControl is provided, check each tracking on whether it is to ! be written. Without a simControl, we will write all trackings ! unconditionally. if ( . not . tem_tracking_has_triggered ( & & timeControl = me % tracking % config ( iConfig )% timeControl , & & proc = me % tracking % instance ( iTrack )% output_file % proc , & & simControl = simControl ) & & ) CYCLE end if if (. not . me % tracking % config ( iConfig )% output_config % useGetPoint ) then ! Only perform subsampling if not using get_point anyway. call ply_sample_data ( me = me % sampling , & & orig_mesh = mesh , & & orig_bcs = bc , & & varsys = varsys , & & var_degree = var_degree , & & lvl_degree = lvl_degree , & & var_space = var_space , & & ndims = me % ndims , & & trackInst = me % tracking % instance ( iTrack ), & & trackConfig = me % tracking % config ( iConfig ), & & time = loctime , & & new_mesh = sampled_mesh , & & resvars = sampled_vars ) !> Get the communicator description for the subsampled mesh. sampled_proc % root = 0 sampled_proc % comm_size = sampled_mesh % global % nParts sampled_proc % rank = sampled_mesh % global % myPart sampled_proc % comm = sampled_mesh % global % comm sampled_proc % nThreads = proc % nThreads sampled_proc % isRoot = ( sampled_mesh % global % myPart == sampled_proc % root ) ! initialize output basename = trim ( me % tracking % config ( iConfig )% prefix ) & & // trim ( me % tracking % config ( iConfig )% label ) call hvs_output_init ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & out_config = me % tracking % config ( iConfig )% output_config , & & tree = sampled_mesh , & & varSys = sampled_vars , & & geometry = me % tracking % config ( iConfig )% geometry , & & basename = trim ( basename ), & & globProc = sampled_proc , & & solver = solver ) call hvs_output_open ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & use_iter = me % tracking % config ( iConfig )% output_config & & % vtk & & % iter_filename , & & mesh = sampled_mesh , & & varsys = sampled_vars , & & time = loctime ) ! Fill output files with data. call hvs_output_write ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varsys = sampled_vars , & & mesh = sampled_mesh ) call hvs_output_close ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varSys = sampled_vars , & & mesh = sampled_mesh ) do ivar = 1 , sampled_vars % method % nVals call ply_sampling_free_methodData ( sampled_vars % method % val ( iVar )) end do call tem_empty_varSys ( sampled_vars ) call free_treelmesh ( sampled_mesh ) else if ( me % tracking % instance ( iTrack )% subTree % useGlobalMesh ) then call hvs_output_open ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & use_iter = me % tracking % config ( iConfig )% output_config & & % vtk & & % iter_filename , & & mesh = mesh , & & varsys = varSys , & & time = loctime ) ! Fill output files with data. call hvs_output_write ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varsys = varSys , & & mesh = mesh ) call hvs_output_close ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varSys = varSys , & & mesh = mesh ) else call hvs_output_open ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & use_iter = me % tracking % config ( iConfig )% output_config & & % vtk & & % iter_filename , & & mesh = mesh , & & subtree = me % tracking % instance ( iTrack )% subtree , & & varsys = varSys , & & time = loctime ) ! Fill output files with data. call hvs_output_write ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varsys = varSys , & & subtree = me % tracking % instance ( iTrack )% subtree , & & mesh = mesh ) call hvs_output_close ( & & out_file = me % tracking % instance ( iTrack )% output_file , & & varSys = varSys , & & mesh = mesh , & & subtree = me % tracking % instance ( iTrack )% subtree ) end if end if end do end subroutine ply_sampled_track_output ! ------------------------------------------------------------------------ ! end module ply_sampled_tracking_module","tags":"","url":"sourcefile/ply_sampled_tracking_module.f90.html"},{"title":"ply_poly_transformation_module.f90 – Seeder","text":"This module is used for the projection of QLegendre polynomials from parent\nto child elements. Source Code ! Copyright (c) 2017 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2017 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! Copyright (c) 2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Daniel Fleischer and ! Peter Vitt for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !! This module is used for the projection of QLegendre polynomials from parent !! to child elements. module ply_poly_transformation_module use env_module , only : rk use treelmesh_module , only : treelmesh_type implicit none private ! ************************************************************************ ! type ply_subsample_type !> Is subsampling active logical :: isActive = . false . !> The current sampling lvl. integer :: sampling_lvl !> Maximal Level down to which subsampling should be done. integer :: caplevel = 20 !> Minimal subsampling depth: integer :: minsub = 0 !> Maximal subsampling depth: integer :: maxsub = 0 !> Maximum allowed oscillation of the solution. !! For adaptive subsampling only. real ( kind = rk ) :: eps_osci !> Factor for the reduction of the degrees of freedom in one subsampling !! step (per spatial direction). real ( kind = rk ) :: dofReducFactor !> Indicator for limitation of total memory consumption logical :: adaptiveDofReduction !> Absolute upper bound level to refine to. integer :: AbsUpperBoundLevel end type ply_subsample_type ! ************************************************************************ ! ! ************************************************************************ ! type ply_array_type real ( kind = rk ), allocatable :: dat (:) end type ply_array_type ! ************************************************************************ ! public :: ply_Poly_Transformation public :: ply_subsample_type public :: ply_array_type contains ! ************************************************************************ ! !> Projection of polynomial data from parent elements to child elements. !! The projection is done by a direct transformation of the modal !! coeffiecients to another coordinate system with z=ax+b. subroutine ply_Poly_Transformation ( subsamp , dofReduction , mesh , meshData , & & varDofs , varComps , ndims , refine_tree , & & new_refine_tree , newMeshData , newVarDofs ) ! -------------------------------------------------------------------- ! !> Parameters for the subsampling type ( ply_subsample_type ), intent ( in ) :: subsamp !> Factor for reduction of degrees of freedom. real ( kind = rk ), intent ( in ) :: dofReduction (:) !> The mesh related to meshData. type ( treelmesh_type ), intent ( in ) :: mesh !> The data for subsampling. type ( ply_array_type ), intent ( in ) :: meshData (:) !> The number of degrees of freedom for every variable. integer , intent ( in ) :: varDofs (:) !> The number of components for every variable. integer , intent ( in ) :: varComps (:) !> Number of dimensions in the polynomial representation. integer , intent ( in ) :: ndims !> Logical array that marks elements for refinement !! of the previous sampling level. logical , intent ( in ) :: refine_tree (:) !> Logical array that marks elements for refinement. logical , intent ( in ) :: new_refine_tree (:) !> The subsampled data for new_refine_tree. type ( ply_array_type ), allocatable , intent ( out ) :: newMeshData (:) !> The number of dofs for the subsampled data. integer , allocatable , intent ( out ) :: newVarDofs (:) ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: workData (:) real ( kind = rk ), allocatable :: newWorkData (:) integer :: nVars , nDofs , nComponents , nChildDofs integer :: iVar ! -------------------------------------------------------------------- ! nVars = size ( varDofs ) allocate ( newVarDofs ( nVars )) allocate ( newMeshData ( nVars )) varLoop : do iVar = 1 , nVars nComponents = varComps ( iVar ) nDofs = vardofs ( iVar ) allocate ( workData ( size ( meshData ( iVar )% dat ))) workData = meshData ( iVar )% dat if ( subsamp % sampling_lvl . eq . subsamp % maxsub ) then nChildDofs = 1 else nChildDofs = ( ceiling ( nint ( nDofs ** ( 1.0_rk / real ( ndims , kind = rk ))) & & * dofReduction ( iVar ))) ** ndims if ( nChildDofs > nDofs ) then nChildDofs = nDofs elseif ( nChildDofs < 1 ) then nChildDofs = 1 end if end if call ply_subsampleData ( mesh = mesh , & & meshData = workData , & & nDofs = nDofs , & & nChildDofs = nChildDofs , & & nComponents = nComponents , & & refine_tree = refine_tree , & & new_refine_tree = new_refine_tree , & & ndims = ndims , & & subsamp = subsamp , & & newMeshData = newWorkData ) allocate ( newMeshData ( iVar )% dat ( size ( newWorkData ))) newMeshData ( iVar )% dat = newWorkData newVarDofs ( iVar ) = nChildDofs deallocate ( workData ) end do varLoop end subroutine ply_Poly_Transformation ! ************************************************************************ ! ! ************************************************************************ ! subroutine ply_subsampleData ( mesh , meshData , nDofs , nChildDofs , & & nComponents , refine_tree , new_refine_tree , & & nDims , subsamp , newMeshData ) ! -------------------------------------------------------------------- ! !> The mesh for the data. type ( treelmesh_type ), intent ( in ) :: mesh !> The data to subsample real ( kind = rk ), intent ( in ) :: meshData (:) !> The number of degrees of freedom. integer , intent ( in ) :: nDofs !> The number of degrees of freedom for the child elements. integer , intent ( in ) :: nChildDofs !> Number of Components. integer , intent ( in ) :: nComponents !> Logical array that marks all elements for refinement for the previous !! sampling level. logical , intent ( in ) :: refine_tree (:) !> Logical array that marks all elements for refinement for the current !! sampling level. logical , intent ( in ) :: new_refine_tree (:) !> The number of dimensions in the polynomial representation. integer , intent ( in ) :: nDims !> Parameters for subsampling. type ( ply_subsample_type ), intent ( in ) :: subsamp !> The subsampled Data. real ( kind = rk ), allocatable , intent ( out ) :: newMeshData (:) ! -------------------------------------------------------------------- ! integer :: nChilds , nElems , nElemsToRefine , nElemsNotToRefine integer :: nParentElems , childPos , lowElemIndex , upElemIndex integer :: iParentElem , iChild , iElem , upChildIndex , lowChildIndex integer :: oneDof , noChilds , max_modes real ( kind = rk ), allocatable :: transform_matrix (:,:) real ( kind = rk ), allocatable :: childData (:) ! -------------------------------------------------------------------- ! nChilds = 2 ** nDims max_modes = nint ( real ( nDofs , kind = rk ) ** ( 1.0_rk / real ( nDims , kind = rk ))) ! Get the transformation matrix for the maximal polynomial degree. allocate ( transform_matrix ( max_modes , max_modes )) call ply_transform_matrix ( max_modes = max_modes , & & v = transform_matrix ) nElems = mesh % nElems nElemsToRefine = count ( new_refine_tree ) nElemsNotToRefine = nElems - nElemsToRefine nParentElems = size ( refine_tree ) ! Now, we set the correct data for the newMeshData. allocate ( newMeshData (( nElemsToRefine * nChilds * nChildDofs & & + nElemsNotToRefine ) * nComponents )) newMeshData = 0.0_rk upChildIndex = 0 upElemIndex = 0 childPos = 0 if ( subsamp % sampling_lvl > 1 ) then elementLoop : do iParentElem = 1 , nParentElems ! Check if the parent cell was already refined... if ( refine_tree ( iParentElem )) then ! Parent cell was already refined so it contains data with nDofs childLoop : do iChild = 1 , nChilds childPos = childPos + 1 ! Check if the child elems will be refined... if ( new_refine_tree ( childPos )) then ! Child cell will be refined. ! ! Need to project current elem data to new childs ! with reduced dofs. ! Create lower and upper indices for all data of ! iElem in meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Project these dofs from the coarse element to the ! finer elements. call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = nDofs , & & nChildDofs = nChildDofs , & & nComponents = nComponents , & & nDimensions = nDims , & & nChilds = nChilds , & & transform_matrix = transform_matrix , & & childData = childData ) ! Set the data correctly in newMeshData. lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + & & nChilds * nChildDofs * nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) else ! Child cell won't be refined. ! ! Need projecton from current dofs to 1 dof. ! Create lower and upper indices for all data of ! iElem in meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Projection from nDofs to oneDof (integral mean valuea). oneDof = 1 noChilds = 1 call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = oneDof , & & nChildDofs = oneDof , & & nComponents = nComponents , & & nDimensions = nDims , & & nChilds = noChilds , & & transform_matrix = transform_matrix , & & childData = childData ) ! Iterate over all childDofs and set the data corectly ! in newMeshData. lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) end if end do childLoop else ! Parent cell wasn't refined so it contains data with only one dof. ! Simple copying. allocate ( childData ( nComponents )) lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nComponents childData = meshData ( lowElemIndex : upElemIndex ) lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData childpos = childpos + 1 deallocate ( childData ) end if end do elementLoop else elemLoop : do iElem = 1 , nElems if ( new_refine_tree ( iElem )) then ! Create lower and upper indices for all data of iElem in meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Project these dofs from the coarse element to the ! finer elements. call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = nDofs , & & nChildDofs = nChildDofs , & & nComponents = nComponents , & & nDimensions = nDims , & & nChilds = nChilds , & & transform_matrix = transform_matrix , & & childData = childData ) ! Iterate over all childDofs and set the data corectly in newMeshData lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nChilds * nChildDofs * nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) else ! Create lower and upper indices for all data of iElem in meshData. lowElemIndex = upElemIndex + 1 upElemIndex = ( lowElemIndex - 1 ) + nDofs * nComponents ! Projection from nDofs to oneDof (integral mean value). oneDof = 1 noChilds = 1 call ply_projDataToChild ( & & parentData = meshData ( lowElemIndex : upElemIndex ), & & nParentDofs = oneDof , & & nChildDofs = oneDof , & & nComponents = nComponents , & & nDimensions = nDims , & & nChilds = noChilds , & & transform_matrix = transform_matrix , & & childData = childData ) ! Iterate over all childDofs and set the data corectly in newMeshData lowChildIndex = upChildIndex + 1 upChildIndex = ( lowChildIndex - 1 ) + nComponents newMeshData ( lowChildIndex : upChildIndex ) = childData deallocate ( childData ) end if end do elemLoop end if deallocate ( transform_matrix ) end subroutine ply_subsampleData ! ************************************************************************ ! ! ************************************************************************ ! !> Subroutine to project element data from a parent cell to its children. subroutine ply_projDataToChild ( parentData , nParentDofs , nChildDofs , & & nComponents , nDimensions , nChilds , & & transform_matrix , childData ) ! -------------------------------------------------------------------- ! !> The polynomial data for a single parent element. real ( kind = rk ), intent ( in ) :: parentData (:) !> The number of dofs of the parent element. integer , intent ( in ) :: nParentDofs !> The total number of dofs for the child cells. integer , intent ( in ) :: nChildDofs !> The number of componentns for the given variable. integer , intent ( in ) :: nComponents !> The number of dimensions. integer , intent ( in ) :: nDimensions !> The number of child elements. integer , intent ( in ) :: nChilds !> The transformation matrix for the linear coordinate transformation. real ( kind = rk ), intent ( in ) :: transform_matrix (:,:) !> The new data representation for all child cell of the parent cell. real ( kind = rk ), allocatable , intent ( out ) :: childData (:) ! -------------------------------------------------------------------- ! integer :: iDimension , iIndep , iComponent , iMode , jMode integer :: nSubElems , nIndeps , lMode , kMode , iChildElem_prev integer :: nChildElems_prev , nChildElems_cur integer :: child_dofPos , childElem integer :: parent_modes , child_modes integer :: lower_bound , upper_bound , stride real ( kind = rk ), allocatable :: temp_data (:) real ( kind = rk ), allocatable :: childData_prev (:) ! -------------------------------------------------------------------- ! parent_modes = nint ( real ( nParentDofs , kind = rk ) & & ** ( 1 / real ( nDimensions , kind = rk ))) child_modes = nint ( real ( nChildDofs , kind = rk ) & & ** ( 1 / real ( nDimensions , kind = rk ))) allocate ( temp_Data ( parent_modes )) do iDimension = 1 , nDimensions if ( nChilds > 1 ) then nSubElems = 2 nChildElems_cur = 2 ** ( iDimension ) nChildElems_prev = 2 ** ( iDimension - 1 ) else nChildElems_cur = nChilds nChildElems_prev = nChilds nSubElems = nChilds end if stride = child_modes ** ( iDimension - 1 ) * nComponents if ( iDimension . eq . 1 ) then nIndeps = parent_modes ** ( nDimensions - 1 ) ! Allocate memory for two childs in x-direction if ( iDimension . eq . nDimensions ) then allocate ( childData ( nChildElems_cur * child_modes ** nDimensions & & * nComponents )) else allocate ( childData ( nChildElems_cur & & * parent_modes ** ( nDimensions - 1 ) & & * child_modes ** ( nDimensions - 2 ) & & * nComponents )) end if childData = 0.0_rk call splitx () elseif ( iDimension . eq . 2 ) then allocate ( childData_prev ( size ( childData ))) childData_prev = childData deallocate ( childData ) ! Allocate memory for the four childs in y-direction if ( iDimension . eq . nDimensions ) then allocate ( childData ( nChildElems_cur * child_modes ** nDimensions & & * nComponents ) ) else allocate ( childData ( nChildElems_cur & & * parent_modes ** ( nDimensions - 2 ) & & * child_modes ** ( nDimensions - 1 ) * nComponents )) end if childData = 0.0_rk call splity () else deallocate ( childData_prev ) allocate ( childData_prev ( size ( childData ))) childData_prev = childData deallocate ( childData ) ! Allocate memory for the eight childs in z-direction allocate ( childData ( nChildElems_cur * child_modes ** 3 & & * nComponents )) childData = 0.0_rk call splitz () end if end do deallocate ( childData_prev ) deallocate ( temp_Data ) contains ! NOTE: these internal subroutines were introduced to help the compiler !       and avoid internal compiler errors when compiling for AVX !       instructions. ! Perform the projection in x direction onto two child elements subroutine splitx () ! iSubElem = 1 do iComponent = 1 , nComponents do iIndep = 1 , nIndeps lower_bound = iComponent + ( iIndep - 1 ) * parent_modes * nComponents upper_bound = iIndep * parent_modes * nComponents temp_data = parentData ( lower_bound : upper_bound : stride ) do iMode = 1 , child_modes child_dofPos = iComponent & & + ( iMode - 1 ) * nComponents & & + ( iIndep - 1 ) * child_modes * nComponents do jMode = iMode , parent_modes childData ( child_dofpos ) = childData ( child_dofpos ) & & + temp_Data ( jMode ) & & * transform_matrix ( jMode , iMode ) end do end do end do end do if ( nSubElems > 1 ) then ! iSubElem = 2 do iComponent = 1 , nComponents do iIndep = 1 , nIndeps lower_bound = iComponent & & + ( iIndep - 1 ) * parent_modes * nComponents upper_bound = iIndep * parent_modes * nComponents temp_data = parentData ( lower_bound : upper_bound : stride ) do iMode = 1 , child_modes child_dofPos = iComponent & & + ( iMode - 1 ) * nComponents & & + ( iIndep - 1 ) * child_modes * nComponents & & + nComponents & & * child_modes ** ( nDimensions - 2 ) & & * parent_modes ** ( nDimensions - 1 ) do jMode = iMode , parent_modes childData ( child_dofpos ) = childData ( child_dofpos ) & & + temp_Data ( jMode ) & & * transform_matrix ( iMode , jMode ) end do end do end do end do end if end subroutine splitx ! Perform the projection in y direction onto the two child elements ! for each of the  two parents ! (the projected elements split in x direction) subroutine splity () do iChildElem_prev = 1 , nChildElems_prev ! iSubElem = 1 childElem = iChildElem_prev do iComponent = 1 , nComponents do kMode = 1 , parent_modes do lMode = 1 , child_modes lower_bound = iComponent & & + ( lMode - 1 ) * nComponents & & + ( kMode - 1 ) * child_modes * parent_modes * nComponents & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 2 ) & & * parent_modes ** ( nDimensions - 1 ) upper_bound = kMode * parent_modes * child_modes * nComponents & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 2 ) & & * parent_modes ** ( nDimensions - 1 ) temp_data = childData_prev ( lower_bound : upper_bound : stride ) do iMode = 1 , child_modes child_dofPos = iComponent & & + ( iMode - 1 ) * child_modes * nComponents & & + ( lMode - 1 ) * nComponents & & + ( kMode - 1 ) * nComponents & & * child_modes ** 2 & & + ( childElem - 1 ) * nComponents & & * child_modes ** ( nDimensions - 1 ) & & * parent_modes ** ( nDimensions - 2 ) do jMode = iMode , parent_modes childData ( child_dofpos ) = childData ( child_dofpos ) & & + temp_Data ( jMode ) * transform_matrix ( jMode , iMode ) end do end do end do end do end do if ( nSubElems > 1 ) then ! iSubElem = 2 childElem = iChildElem_prev + 2 do iComponent = 1 , nComponents do kMode = 1 , parent_modes do lMode = 1 , child_modes lower_bound = iComponent & & + ( lMode - 1 ) * nComponents & & + ( kMode - 1 ) * child_modes * parent_modes * nComponents & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 2 ) & & * parent_modes ** ( nDimensions - 1 ) upper_bound = kMode * parent_modes * child_modes & & * nComponents & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 2 ) & & * parent_modes ** ( nDimensions - 1 ) temp_data = childData_prev ( lower_bound : upper_bound : stride ) do iMode = 1 , child_modes child_dofPos = iComponent & & + ( iMode - 1 ) * child_modes * nComponents & & + ( lMode - 1 ) * nComponents & & + ( kMode - 1 ) * nComponents * child_modes ** 2 & & + ( childElem - 1 ) * nComponents & & * child_modes ** ( nDimensions - 1 ) & & * parent_modes ** ( nDimensions - 2 ) do jMode = iMode , parent_modes childData ( child_dofpos ) = childData ( child_dofpos ) & & + temp_Data ( jMode ) * transform_matrix ( iMode , jMode ) end do end do end do end do end do end if end do end subroutine splity ! Perform the projection in z direction onto the two child elements ! for each of the four parents ! (the projected elements split in x and y direction) subroutine splitz () do iChildElem_prev = 1 , nChildElems_prev ! iSubElem = 1 childElem = iChildElem_prev do iComponent = 1 , nComponents iIndep = 0 do kMode = 1 , child_modes do lMode = 1 , child_modes iIndep = iIndep + 1 lower_bound = iComponent & & + ( iIndep - 1 ) * nComponents & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 1 ) & & * parent_modes ** ( nDimensions - 2 ) upper_bound = parent_modes * child_modes ** ( nDimensions - 1 ) & & * nComponents & & - ( nComponents - iComponent ) & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 1 ) & & * parent_modes ** ( nDimensions - 2 ) temp_data (:) = childData_prev & & ( lower_bound : upper_bound : stride ) do iMode = 1 , child_modes child_dofPos = iComponent & & + ( iMode - 1 ) * child_modes ** 2 * nComponents & & + ( lMode - 1 ) * nComponents & & + ( kMode - 1 ) * child_modes * nComponents & & + ( childElem - 1 ) * nComponents & & * child_modes ** nDimensions do jMode = iMode , parent_modes childData ( child_dofpos ) = childData ( child_dofpos ) & & + temp_Data ( jMode ) * transform_matrix ( jMode , iMode ) end do end do end do end do end do if ( nSubElems > 1 ) then ! iSubElem = 2 childElem = iChildElem_prev + 4 do iComponent = 1 , nComponents iIndep = 0 do kMode = 1 , child_modes do lMode = 1 , child_modes iIndep = iIndep + 1 lower_bound = iComponent & & + ( iIndep - 1 ) * nComponents & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 1 ) & & * parent_modes ** ( nDimensions - 2 ) upper_bound = parent_modes * child_modes ** ( nDimensions - 1 ) & & * nComponents & & - ( nComponents - iComponent ) & & + ( iChildElem_prev - 1 ) * nComponents & & * child_modes ** ( nDimensions - 1 ) & & * parent_modes ** ( nDimensions - 2 ) temp_data (:) = childData_prev ( lower_bound : upper_bound : stride ) do iMode = 1 , child_modes child_dofPos = iComponent & & + ( iMode - 1 ) * child_modes ** 2 * nComponents & & + ( lMode - 1 ) * nComponents & & + ( kMode - 1 ) * child_modes * nComponents & & + ( childElem - 1 ) * nComponents & & * child_modes ** nDimensions do jMode = iMode , parent_modes childData ( child_dofpos ) = childData ( child_dofpos ) & & + temp_Data ( jMode ) * transform_matrix ( iMode , jMode ) end do end do end do end do end do end if end do end subroutine splitz end subroutine ply_projDataToChild ! ************************************************************************ ! ! ************************************************************************ ! !> Compute the transformation matrix for a projection to the left and right !! half-interval of Legendre polynomials for the given maximal number of !! modes. !! !! Note: The transformation matrices to each subinterval are triangular, and !!       the diagonal entries are the same. To save memory both matrices are !!       stored in a single 2 dimensional array of size !!       (max_modes, max_modes). !! !! This matrix only needs to be computed once for a sufficiently high order, !! as submatices out of it can by used to perform the transformation for !! any lower polynomial degree. subroutine ply_transform_matrix ( max_modes , v ) ! -------------------------------------------------------------------- ! !> The maximal number of modes to compute the transformation for. !! !! The resulting matrix v will be max_modes x max_modes large and can !! be used for the transformation of all polynomials with up to this !! many modes. integer , intent ( in ) :: max_modes !> The transformation matrix. !! !! Upper triangular matrix is created for shifting and lower triangular !! for (-1) * shifting. !! For the right interval we interpret the first index as row index !! and the second as column. For the left interval this is reverted and !! we interpret the first index as columns of the matrix. real ( kind = rk ), allocatable , intent ( out ) :: v (:,:) ! -------------------------------------------------------------------- ! integer :: m , orig real ( kind = rk ) :: shifting , scaling ! -------------------------------------------------------------------- ! ! transformation matrix looks like this: ! [1.0  --  --     shift=0.5   ] ! | |  0.5  --                 | ! | |   |  0.25             ...| ! |             0.125          | ! | shift=-0.5        0.0625   | ! [    :                    ...] allocate ( v ( max_modes , max_modes )) v = 0.0_rk scaling = 0.5_rk shifting = 0.5_rk ! Set the first two entries of v manually. v ( 1 , 1 ) = 1.0_rk if ( max_modes > 1 ) then v ( 1 , 2 ) = shifting v ( 2 , 2 ) = scaling if ( max_modes > 2 ) then do orig = 3 , max_modes v ( 1 , orig ) = ply_beta ( orig - 1 ) * v ( 1 , orig - 2 ) & & + ply_alpha ( orig - 1 ) * shifting * v ( 1 , orig - 1 ) & & - scaling * ply_alpha_beta ( 2 , orig - 1 ) * v ( 2 , orig - 1 ) do m = 2 , orig if ( m < max_modes ) then v ( m , orig ) = ply_beta ( orig - 1 ) * v ( m , orig - 2 ) & & + ply_alpha ( orig - 1 ) * shifting * v ( m , orig - 1 ) & & - scaling * ply_alpha_beta ( m + 1 , orig - 1 ) & & * v ( m + 1 , orig - 1 ) & & + scaling * ply_alpha_frac ( m - 1 , orig - 1 ) * v ( m - 1 , orig - 1 ) else ! Need to skip one summand for v(max_modes,max_modes). v ( m , orig ) = scaling * ply_alpha_frac ( m - 1 , orig - 1 ) * v ( m - 1 , orig - 1 ) end if end do end do end if ! Due to the symmetry of the problem (the left subinterval has just ! the shifting with a changed sign), we can fill the other half of ! the matrix by copying the already computed values accordingly with ! a change in sign, as needed (alternatingly). do m = 1 , max_modes do orig = 1 , m - 1 if ( mod (( m + orig ), 2 ) /= 0 ) then v ( m , orig ) = - v ( orig , m ) else v ( m , orig ) = v ( orig , m ) end if end do end do end if end subroutine ply_transform_matrix ! ************************************************************************ ! ! ************************************************************************ ! !> Coefficients from the recursive formulation of legendre polynomials. !! L_n = alpha * x * L_n-1 + beta * L_n-2 function ply_alpha ( mode ) result ( alpha ) ! -------------------------------------------------------------------- ! !> The current mode in the polynomial representation. integer , intent ( in ) :: mode !> Alpha coefficient from the recursive formulation of legendre !! polynomials. real ( kind = rk ) :: alpha ! -------------------------------------------------------------------- ! if ( mode > 0 ) then alpha = real (( 2 * mode - 1 ), kind = rk ) / real ( mode , kind = rk ) else alpha = 0.0 end if end function ply_alpha ! ************************************************************************ ! ! ************************************************************************ ! !> Coefficients from the recursive formulation of legendre polynomials. !! L_n = alpha * x * L_n-1 + beta * L_n-2 !! function ply_beta ( mode ) result ( beta ) ! -------------------------------------------------------------------- ! !> The current mode in the polynomial representation. integer , intent ( in ) :: mode !> Beta coefficient from the recursive formulation of legendre !! polynomials. real ( kind = rk ) :: beta ! -------------------------------------------------------------------- ! if ( mode > 0 ) then beta = real (( 1 - mode ), kind = rk ) / real ( mode , kind = rk ) else beta = 0.0 end if end function ply_beta ! ************************************************************************ ! ! ************************************************************************ ! !> Quotient of two alpha values. function ply_alpha_frac ( denominator , numerator ) result ( alpha_frac ) ! -------------------------------------------------------------------- ! !> Numerator integer , intent ( in ) :: numerator !> Denominator integer , intent ( in ) :: denominator !> The quotient of two alpha values. real ( kind = rk ) :: alpha_frac ! -------------------------------------------------------------------- ! if ( denominator > 0 . and . numerator > 0 ) then if ( denominator == numerator ) then alpha_frac = 1.0_rk else alpha_frac = real (( 2 * numerator - 1 ) * denominator , kind = rk ) & & / real (( 2 * denominator - 1 ) * numerator , kind = rk ) end if else alpha_frac = 0.0_rk end if end function ply_alpha_frac ! ************************************************************************ ! ! ************************************************************************ ! !> Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) function ply_alpha_beta ( denominator , numerator ) result ( alpha_beta ) ! -------------------------------------------------------------------- ! !> Numerator integer , intent ( in ) :: numerator !> Denominator integer , intent ( in ) :: denominator !> The product of alpha(n) * beta(d) / alpha(d) real ( kind = rk ) :: alpha_beta ! -------------------------------------------------------------------- ! if ( numerator > 0 ) then if ( denominator == numerator ) then alpha_beta = real (( 1 - denominator ), kind = rk ) / real ( denominator , kind = rk ) else alpha_beta = real (( 2 * numerator - 1 ) * ( 1 - denominator ), kind = rk ) & & / real ( numerator * ( 2 * denominator - 1 ), kind = rk ) end if else alpha_beta = 0.0_rk end if end function ply_alpha_beta ! ************************************************************************ ! end module ply_poly_transformation_module","tags":"","url":"sourcefile/ply_poly_transformation_module.f90.html"},{"title":"sdr_harvesting.f90 – Seeder","text":"* * * * * * * * * * * ! This file depends on sourcefile~~sdr_harvesting.f90~~EfferentGraph sourcefile~sdr_harvesting.f90 sdr_harvesting.f90 sourcefile~ply_sampled_tracking_module.f90 ply_sampled_tracking_module.f90 sourcefile~sdr_harvesting.f90->sourcefile~ply_sampled_tracking_module.f90 sourcefile~sdr_hvs_config_module.f90 sdr_hvs_config_module.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_config_module.f90 sourcefile~sdr_hvs_props_module.f90 sdr_hvs_props_module.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_props_module.f90 sourcefile~sdr_hvs_config_module.f90->sourcefile~ply_sampled_tracking_module.f90 sourcefile~sdr_hvs_config_module.f90->sourcefile~sdr_hvs_props_module.f90 sourcefile~ply_subresolution_module.f90 ply_subresolution_module.f90 sourcefile~sdr_hvs_props_module.f90->sourcefile~ply_subresolution_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016, 2019, 2022 Harald Klimach <harald.klimach@dlr.de> ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2015 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Neda Ebrahimi Pour <neda.epour@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !******************************************************************************! !> Seeder Harvesting Tool !! Visualization of meshes, generated by seeder. !! (c) 2015 University of Siegen !! !! For a documentation, run ./waf gendoxy and find the documentation at !! ./Documentation/html/index.html program sdr_harvesting use iso_c_binding , only : c_loc ! treelm modules use env_module , only : pathLen use treelmesh_module , only : treelmesh_type use tem_bc_prop_module , only : tem_bc_prop_type use tem_color_prop_module , only : tem_color_prop_type use tem_general_module , only : tem_general_type , tem_start , tem_finalize use tem_logging_module , only : logunit use tem_meshInfo_module , only : tem_varSys_append_meshInfoVar use tem_stencil_module , only : tem_stencilHeader_type , tem_create_stencil use tem_time_module , only : tem_time_type , tem_time_reset use tem_tracking_module , only : tem_tracking_getData , & & tem_init_tracker_subTree use tem_varsys_module , only : tem_varsys_type , tem_varSys_init , & & tem_varSys_proc_element use tem_varMap_module , only : tem_varMap_type , tem_create_varMap use tem_restart_module , only : tem_restart_type , tem_load_restart , & & tem_init_restart use ply_dof_module , only : q_space use ply_sampled_tracking_module , only : ply_sampled_track_init , & & ply_sampled_track_output ! libharvesting use hvs_output_module , only : hvs_output_file_type , hvs_output_open , & & hvs_output_close , hvs_output_write , & & hvs_output_init , hvs_output_finalize ! sdr_harvesting use sdr_hvs_config_module , only : sdr_hvs_config_type , sdr_hvs_config_load use sdr_hvs_props_module , only : sdr_hvs_props_type , & & sdr_hvs_props_import_dofs ! seeder use sdr_protoData_module , only : sdr_append_protoVar , access_state , & sdr_readRestart , sdr_protoData_type implicit none !----------------------------------------------------------------------------- type ( tem_restart_type ) :: restart type ( sdr_protoData_type ), target :: protoData type ( tem_general_type ) :: general type ( treelmesh_type ) :: mesh type ( sdr_hvs_config_type ) :: config type ( sdr_hvs_props_type ) :: property type ( hvs_output_file_type ) :: out_file type ( tem_varsys_type ) :: varsys type ( tem_varMap_type ) :: varMap type ( tem_stencilHeader_type ) :: stencil type ( tem_time_type ) :: time procedure ( tem_varSys_proc_element ), pointer :: get_element integer :: iTrack integer :: nDofs integer :: nSimpleVars integer , allocatable :: var_degree (:) integer , allocatable :: lvl_degree (:) integer , allocatable :: var_space (:) ! basename for output if tracking table is not defined ! trim(config%prefix)//trim(general%solver%simName)//trim(varSys%systemName) character ( len = pathLen ) :: basename !----------------------------------------------------------------------------- ! Initialize environment. call tem_start ( codeName = 'sdr_harvesting' , & & version = '0.1' , & & general = general ) ! Definition of the mesh variables. call tem_varSys_init ( me = varsys , & & systemName = 'seeder_vars' , & & length = 8 ) ! Is there a mesh, else use the restart files call tem_varSys_append_meshInfoVar ( varsys ) nSimpleVars = varsys % varname % nVals ! load config file call sdr_hvs_config_load ( me = config , & & mesh = mesh , & & property = property , & & varsys = varsys , & & general = general , & & restart = restart , & & time = time ) if ( restart % controller % readRestart ) then get_element => access_state call sdr_append_protoVar ( protoVar = restart % header % varSys % varname & & % val ( 1 : restart % header & & % varSys % varname % nVals ), & & varSys = varSys , & & method_data = c_loc ( protoData ), & & get_element = get_element ) ! create varMap with protoData variables ! VarMap is required to create MPI_type to read restart file call tem_create_varMap ( varName = restart % header % varSys % varname & & % val ( 1 : restart % header & & % varSys % varname % nVals ), & & varSys = varSys , & & varMap = varMap ) ! This routine creates mpi data_type to load data from restart file ! using MPI I/O. So, this must be initilized before readRestart call tem_init_restart ( me = restart , & & solver = general % solver , & & varMap = varMap , & & tree = mesh ) ! read restart and fill protoData call sdr_readRestart ( restart , mesh , protoData ) end if allocate ( var_degree ( varsys % varname % nVals )) allocate ( lvl_degree ( mesh % global % maxlevel )) allocate ( var_space ( varsys % varname % nVals )) var_degree = 0 var_space = q_space if ( config % do_subsampling ) then call sdr_hvs_props_import_dofs ( me = property , & & mesh = mesh , & & proc = general % proc , & & maxdegree = property % subres % polydegree , & & ndims = 3 ) var_degree ( nSimpleVars + 1 : varsys % varname % nVals ) = property % subres % polydegree else ! No subsampling: load only integral mean values from the subresolution. write ( logunit ( 2 ), * ) 'Importing integral means from subresolution data' call sdr_hvs_props_import_dofs ( me = property , & & mesh = mesh , & & proc = general % proc , & & maxdegree = 0 , & & ndims = 3 ) end if lvl_degree = maxval ( var_degree ) if ( config % ply_sample_track % tracking % control % active ) then ! The stencil is needed for the identification of shapes, that are based ! on the boundary conditions. ! HK: For now we just use all 26 directions, that are available in the !     mesh right now. Probably, this should be configurable. call tem_create_stencil ( stencil , 'd3q27' ) ! Mesh infos currently have just one degree of freedom per element. nDofs = 1 ! No time associated with the mesh. call tem_time_reset ( time ) ! Initialize tracker subTree and remote empty trackers. ! It also adds solver%simName and varSys%systemName as prefix to ! tracking label call ply_sampled_track_init ( me = config % ply_sample_track , & & mesh = mesh , & & solver = general % solver , & & varSys = varSys , & & bc = property % bc , & & stencil = stencil , & & proc = general % proc , & & ndofs = 1 , & & ndims = 3 ) call ply_sampled_track_output ( me = config % ply_sample_track , & & mesh = mesh , & & bc = property % bc , & & solver = general % solver , & & proc = general % proc , & & varSys = varSys , & & lvl_degree = lvl_degree , & & var_degree = var_degree , & & var_space = var_space , & & time = time ) do iTrack = 1 , config % ply_sample_track % tracking % control % nActive ! Finialize output call hvs_output_finalize ( out_file = config % ply_sample_track & & % tracking % instance ( iTrack ) & & % output_file ) end do else ! No tracking defined, just dump the plain original mesh. ! Open the output files, this also generates the vertices for the mesh, ! and writes the mesh data to disk. !!@todo HK: no subsampling if we dump all data (no tracking)? !!          Probably should do subsampling also here? ! filename for output basename = trim ( config % prefix ) // trim ( general % solver % simName ) ! Deactivate spatial reduction out_file % ascii % isReduce = . false . if ( restart % controller % readRestart ) then call hvs_output_init ( out_file = out_file , & & out_config = config % output , & & tree = mesh , & & varSys = varSys , & & varPos = restart % varMap % varPos & & % val (: varMap % varPos % nVals ), & & basename = trim ( basename ), & & globProc = general % proc , & & solver = general % solver ) else call hvs_output_init ( out_file = out_file , & & out_config = config % output , & & tree = mesh , & & varSys = varSys , & & basename = trim ( basename ), & & globProc = general % proc , & & solver = general % solver ) end if ! Open output file handle call hvs_output_open ( out_file = out_file , & & use_iter = . false ., & & mesh = mesh , & & varsys = varsys ) ! Fill output files with data. call hvs_output_write ( out_file = out_file , & & varsys = varsys , & & mesh = mesh ) ! Close output files again. call hvs_output_close ( out_file = out_file , & & varsys = varsys , & & mesh = mesh ) ! Finialize output call hvs_output_finalize ( out_file = out_file ) end if ! Finalize environment. call tem_finalize ( general ) end program sdr_harvesting","tags":"","url":"sourcefile/sdr_harvesting.f90.html"},{"title":"ply_sampling_varsys_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_sampling_varsys_module.f90~~AfferentGraph sourcefile~ply_sampling_varsys_module.f90 ply_sampling_varsys_module.f90 sourcefile~ply_sampling_adaptive_module.f90 ply_sampling_adaptive_module.f90 sourcefile~ply_sampling_adaptive_module.f90->sourcefile~ply_sampling_varsys_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2017-2018 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2018 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! ! Parts of this file were written by Harald Klimach and Daniel Fleischer for ! University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Managing the variable system description for sampled data. module ply_sampling_varsys_module use env_module , only : rk use treelmesh_module , only : treelmesh_type use tem_time_module , only : tem_time_type use tem_tracking_module , only : tem_tracking_instance_type use tem_varsys_module , only : tem_varsys_type , tem_varSys_init use tem_topology_module , only : tem_levelof implicit none private public :: ply_sampling_var_type public :: ply_sampling_varsys_for_track public :: ply_sampling_var_allocate public :: ply_sampling_var_move public :: ply_sampling_var_compute_elemdev !> Small helping type to allow arrays of arrays for the variable data. type ply_sampling_var_type integer :: nDeviating integer , allocatable :: degree (:) integer , allocatable :: first (:) real ( kind = rk ), pointer :: dat (:) logical , allocatable :: deviates (:) end type ply_sampling_var_type contains ! ------------------------------------------------------------------------ ! !> Create a variable system for the given tracking instance. subroutine ply_sampling_varsys_for_track ( varsys , trackInst , mesh , nDims , & & lvl_degree , & & sample_varsys , var , time ) ! -------------------------------------------------------------------- ! !> Variable system describing the access to the original data to sample. type ( tem_varsys_type ), intent ( in ) :: varsys !> The tracking object that should be sampled. type ( tem_tracking_instance_type ), intent ( in ) :: trackInst !> Original mesh describing the spatial organisation of the data to !! sample. type ( treelmesh_type ), intent ( in ) :: mesh !> Dimensionality of the data to sample. integer , intent ( in ) :: nDims !> Maximal polynomial degree for each level. integer , intent ( in ) :: lvl_degree (:) !> Variable system for the sampled data. type ( tem_varsys_type ), intent ( out ) :: sample_varsys !> Extracted data for all the variables requested in the given tracking !! instance. type ( ply_sampling_var_type ), pointer :: var (:) !> Point in time to get the data for. type ( tem_time_type ), intent ( in ) :: time ! -------------------------------------------------------------------- ! integer :: nVars integer :: nElems integer :: nScalars integer :: varpos integer :: nComponents integer :: nDofs integer :: i integer :: iElem integer :: iVar integer :: iComponent integer :: iScalar integer :: iTotComp integer :: iLevel integer :: total_dofs integer :: lower_bound , upper_bound integer , allocatable :: elempos (:) real ( kind = rk ), allocatable :: elemdat (:) ! -------------------------------------------------------------------- ! nVars = trackInst % varmap % varPos % nVals nullify ( var ) nScalars = sum ( varsys % method % val ( trackInst % varmap % varPos % val (: nVars )) & & % nComponents ) call tem_varSys_init ( me = sample_varsys , & & systemName = 'sampledVars' , & & length = nVars ) if ( trackInst % subtree % useGlobalMesh ) then nElems = mesh % nElems allocate ( elempos ( nElems ) ) elempos = [ ( i , i = 1 , nElems ) ] else nElems = trackInst % subtree % nElems allocate ( elempos ( nElems ) ) elempos = trackInst % subtree % map2global end if allocate ( var ( nScalars )) ! Get the total number of dofs with respect to the actual ! polynomial degree of every single element. total_dofs = 0 do iElem = 1 , nElems iLevel = tem_LevelOf ( mesh % treeID ( iElem )) nDofs = ( lvl_degree ( iLevel ) + 1 ) ** nDims total_dofs = total_dofs + nDofs end do iScalar = 1 variables : do iVar = 1 , nVars varpos = trackInst % varmap % varPos % val ( iVar ) nComponents = varsys % method % val ( varpos )% nComponents do iComponent = 1 , nComponents iTotComp = iScalar + iComponent - 1 call ply_sampling_var_allocate ( var = var ( iTotComp ), & & nElems = nElems , & & datalen = total_dofs ) var ( iTotComp )% first ( 1 ) = 1 end do ! Varying polynomial degree for elements is possible. ! Need to copy data element by element. lower_bound = 1 do iElem = 1 , nElems iLevel = tem_LevelOf ( mesh % treeID ( iElem )) nDofs = ( lvl_degree ( iLevel ) + 1 ) ** nDims upper_bound = lower_bound - 1 + nDofs allocate ( elemDat ( nComponents * nDofs )) call varSys % method % val ( varpos )% get_element ( & & varSys = varSys , & & elempos = elempos ( iElem : iElem ), & & time = time , & & tree = mesh , & & nElems = 1 , & & nDofs = nDofs , & & res = elemdat ) do iComponent = 1 , nComponents iTotComp = iScalar + iComponent - 1 var ( iTotComp )% dat ( lower_bound : upper_bound ) & & = elemdat ( iComponent :: nComponents ) var ( iTotComp )% first ( iElem + 1 ) = upper_bound + 1 var ( iTotComp )% degree ( iElem ) = lvl_degree ( iLevel ) end do lower_bound = upper_bound + 1 deallocate ( elemDat ) end do iScalar = iScalar + nComponents end do variables end subroutine ply_sampling_varsys_for_track ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Allocate memory for a sampled variable. subroutine ply_sampling_var_allocate ( var , nElems , datalen ) ! -------------------------------------------------------------------- ! !> The variable to allocate the space for. type ( ply_sampling_var_type ), intent ( inout ) :: var !> Number of elements the data lives in. integer , intent ( in ) :: nElems !> Size of the container to use for representation of the polynomial !! data across all elements. integer , intent ( in ) :: datalen ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! allocate ( var % degree ( nelems )) allocate ( var % deviates ( nelems )) allocate ( var % first ( nelems + 1 )) allocate ( var % dat ( datalen )) end subroutine ply_sampling_var_allocate ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Move the variable data from source to destination. !! !! If there is data in destination, it will be discarded. !! The data in source becomes accessible via destination and source !! itself gets nullified. subroutine ply_sampling_var_move ( source , destination ) ! -------------------------------------------------------------------- ! !> Variable data to move (and make accessible via destination). !! !! Source itself will be null after moving. type ( ply_sampling_var_type ), pointer :: source (:) !> Pointer to refer to the data in source. If destination already !! contains data, this data will be discarded. type ( ply_sampling_var_type ), pointer :: destination (:) ! -------------------------------------------------------------------- ! integer :: nScalars integer :: iScalar ! -------------------------------------------------------------------- ! if ( associated ( destination )) then nScalars = size ( destination ) do iScalar = 1 , nScalars if ( allocated ( destination ( iScalar )% degree )) & & deallocate ( destination ( iScalar )% degree ) if ( allocated ( destination ( iScalar )% first )) & & deallocate ( destination ( iScalar )% first ) if ( associated ( destination ( iScalar )% dat )) & & deallocate ( destination ( iScalar )% dat ) if ( allocated ( destination ( iScalar )% deviates )) & & deallocate ( destination ( iScalar )% deviates ) end do end if destination => source nullify ( source ) end subroutine ply_sampling_var_move ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine computes for each element whether the solution in it is !! considered to be deviating from the mean above the given threshold or !! not. The logical result is stored in `var%deviates` for each element. !! !! The total number of deviating elements is stored in `var%nDeviating`. !! !! The variation is computed by the sum of the absolute values of all higher !! modes divided by the first mode. !! As we are using series of Legendre polynomials this also is a !! bounding estimation for the maximal (relative) deviation from the mean in !! this element. !! !! A variation of 0.01 for example would imply that the state in the element !! is guaranteed to nowhere deviate from the mean by more than 1 percent. !! However, this is a very rough estimation and the actual maximal deviation !! from the mean is probably much lower (at least for sufficiently high !! polynomial degrees). !! !! If the mean is too close to 0, we use epsilon for the normalization !! instead of the actual mean. !! !! The computation is done for the current data found in `var%dat`, any !! previous computations of these flags will be discarded by this routine. subroutine ply_sampling_var_compute_elemdev ( var , threshold , min_mean ) ! -------------------------------------------------------------------- ! !> Variable data to compute the deviation for. type ( ply_sampling_var_type ), intent ( inout ) :: var !> Relative threshold to use as decision whether an element has a high !! deviation or not. !! !! If the absolute value of higher modes sums to a larger value than !! threshold times the first mode (integral mean), the element is marked !! as deviating. real ( kind = rk ), intent ( in ) :: threshold !> A minimal mean value to use as comparison (to cut off changes that are !! too close to 0). !! !! This should be small but has to be larger than 0. real ( kind = rk ), intent ( in ) :: min_mean ! -------------------------------------------------------------------- ! real ( kind = rk ) :: variation real ( kind = rk ) :: absmean integer :: iElem integer :: nElems integer :: ndofs ! -------------------------------------------------------------------- ! if ( allocated ( var % deviates )) deallocate ( var % deviates ) var % nDeviating = 0 if ( allocated ( var % first )) then nElems = size ( var % first ) - 1 allocate ( var % deviates ( nElems )) do iElem = 1 , nElems ndofs = var % first ( iElem + 1 ) - var % first ( iElem ) - 1 absmean = max ( abs ( var % dat ( var % first ( iElem ))), min_mean ) variation = sum ( abs ( var % dat ( var % first ( iElem ) + 1 : var % first ( iElem + 1 ) - 1 )) ) var % deviates ( iElem ) = ( variation > threshold * absmean ) if ( var % deviates ( iElem )) var % nDeviating = var % nDeviating + 1 end do end if end subroutine ply_sampling_var_compute_elemdev ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! end module ply_sampling_varsys_module","tags":"","url":"sourcefile/ply_sampling_varsys_module.f90.html"},{"title":"ply_subresolution_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_subresolution_module.f90~~AfferentGraph sourcefile~ply_subresolution_module.f90 ply_subresolution_module.f90 sourcefile~sdr_hvs_props_module.f90 sdr_hvs_props_module.f90 sourcefile~sdr_hvs_props_module.f90->sourcefile~ply_subresolution_module.f90 sourcefile~sdr_harvesting.f90 sdr_harvesting.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_props_module.f90 sourcefile~sdr_hvs_config_module.f90 sdr_hvs_config_module.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_config_module.f90 sourcefile~sdr_hvs_config_module.f90->sourcefile~sdr_hvs_props_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016, 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016-2017, 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2017 Daniel Petró <daniel.petro@student.uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Peter Vitt, Tobias ! Girresser and Daniel Petró for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! module ply_subresolution_module use , intrinsic :: iso_c_binding , only : c_f_pointer use env_module , only : pathLen , & & rk , & & isLittleEndian , & & long_k , & & newunit use aotus_module , only : flu_State , & & aot_get_val , & & aoterr_Fatal , & & close_config use treelmesh_module , only : treelmesh_type use tem_aux_module , only : tem_open_distconf , & & tem_abort use tem_color_prop_module , only : tem_color_prop_type , & & colors_per_char use tem_comm_env_module , only : tem_comm_env_type use tem_logging_module , only : logunit use tem_subres_prop_module , only : tem_subres_prop_type , & & tem_subres_prop_load use tem_tools_module , only : upper_to_lower use tem_time_module , only : tem_time_type use tem_varSys_module , only : tem_varSys_type , & & tem_varSys_op_type use ply_dof_module , only : P_Space , & & Q_space use ply_transfer_module , only : ply_transfer_P_dim , & & ply_transfer_dofs implicit none private type ply_subresolution_type integer :: polydegree = 0 integer :: basisType type ( tem_subres_prop_type ) :: subres_prop end type ply_subresolution_type !> Self contained description of color data to be used for method data. type ply_subres_colvar_type !> Pointer to the overall color property description. type ( tem_color_prop_type ), pointer :: color => NULL () !> Pointer to the overall subresolution property description. type ( ply_subresolution_type ), pointer :: subres => NULL () !> Degrees of freedom for subresolved elements. real ( kind = rk ), allocatable :: subresdat (:,:) !> Number of degrees of freedom of the subresolution data. integer :: nsubdofs !> Position of this color in the list of colors, needed to make use of the !! pointers above. integer :: colpos end type ply_subres_colvar_type public :: ply_subresolution_type public :: ply_subresolution_load public :: ply_subres_import_color public :: ply_subres_get_elemcolor public :: ply_subres_colvar_type contains ! ************************************************************************ ! !> Subroutine to load subresolution information for a given tree. subroutine ply_subresolution_load ( me , tree , proc , coloring ) ! --------------------------------------------------------------------- ! type ( ply_subresolution_type ), intent ( out ) :: me type ( treelmesh_type ), intent ( in ) :: tree type ( tem_comm_env_type ), intent ( in ) :: proc type ( tem_color_prop_type ), intent ( in ) :: coloring ! --------------------------------------------------------------------- ! character ( len = pathLen ) :: configfile character :: polyspace type ( flu_State ) :: conf integer :: iError ! --------------------------------------------------------------------- ! configfile = trim ( tree % global % dirname ) // 'subresolution.lua' call tem_subres_prop_load ( me = me % subres_prop , & & tree = tree , & & coloring = coloring ) ! Set the polydegree initially to 0 to ensure a proper setting even if ! no subresolution property is present. me % polydegree = 0 ! Only need to do anything, if there is actually a subresolution property. ! Checking this via the association status of the property header. if ( associated ( me % subres_prop % header )) then call tem_open_distconf ( L = conf , & & filename = trim ( configfile ), & & proc = proc ) call aot_get_val ( L = conf , & & key = 'polydegree' , & & val = me % polydegree , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then call tem_abort ( & & 'FATAL Error occured, while retrieving subresolution polydegree' ) end if call aot_get_val ( L = conf , & & key = 'polyspace' , & & val = polyspace , & & default = 'q' , & & ErrCode = iError ) select case ( upper_to_lower ( trim ( polyspace ))) case ( 'q' ) me % basisType = Q_space case ( 'p' ) me % basisType = P_space case default write ( logunit ( 1 ), * ) 'ERROR in subresolution loading!' write ( logunit ( 1 ), * ) 'Unknown polyspace ' , trim ( polyspace ) write ( logUnit ( 1 ), * ) 'Supported are:' write ( logUnit ( 1 ), * ) '* Q (quadratic with i,j,k <= maxDegree)' write ( logUnit ( 1 ), * ) '* P (with i+j+k <= maxDegree)' call tem_abort () end select call close_config ( conf ) end if end subroutine ply_subresolution_load ! ************************************************************************ ! ! ************************************************************************ ! !> Get the subresolution data for all elements for a given color and in the !! requested format. subroutine ply_subres_import_color ( me , tree , coloring , iColor , & & target_degree , target_space , target_dim , & & subresdat ) ! --------------------------------------------------------------------- ! type ( ply_subresolution_type ), intent ( in ) :: me type ( treelmesh_type ), intent ( in ) :: tree type ( tem_color_prop_type ), intent ( in ) :: coloring integer , intent ( in ) :: iColor integer , intent ( in ) :: target_degree integer , intent ( in ) :: target_space integer , intent ( in ) :: target_dim real ( kind = rk ), allocatable , intent ( out ) :: subresdat (:,:) ! --------------------------------------------------------------------- ! character ( len = pathLen ) :: datfile integer :: target_Dofs integer :: in_dofs integer :: read_dofs integer :: pre_dofs integer :: pdim real ( kind = rk ), allocatable :: indat (:) real ( kind = rk ), allocatable :: predat (:) character ( len = 4 ) :: datext integer :: rl integer :: fUnit integer :: nElems integer ( kind = long_k ) :: offset integer :: iElem integer :: minOrd integer :: in_dim integer :: recs_per_elem ! --------------------------------------------------------------------- ! ! Seeder always writes three-dimensional data. ! Assume an input dimension of 3: in_dim = 3 ! Only need to do anything, if there is actually a subresolution property. ! Checking this via the association status of the property header. if ( associated ( me % subres_prop % header )) then if ( isLittleEndian ) then datext = '.lsb' else datext = '.msb' end if nElems = me % subres_prop % nElems ( iColor ) offset = me % subres_prop % offset ( iColor ) ! Figure out the target polynomial representation. ! ! We moved this allocation in front of the loop to silence a compiler ! warning about a potentially uninitialized variable. target_dofs = target_degree + 1 select case ( target_space ) case ( Q_Space ) target_dofs = target_dofs ** target_dim case ( P_Space ) do pdim = 2 , target_dim target_dofs = ( target_dofs * ( target_degree + pdim ) ) / pdim end do case default call tem_abort ( 'Wrong target_space! Select Q_Space or P_Space.' ) end select ! We read the complete data per element in most cases. recs_per_elem = 1 ! Figure out input polynomial representation. select case ( me % basistype ) case ( Q_Space ) in_dofs = ( me % polydegree + 1 ) ** 3 if ( target_dim < in_dim ) then read_dofs = ( me % polydegree + 1 ) ** target_dim recs_per_elem = ( me % polydegree + 1 ) ** ( in_dim - target_dim ) else read_dofs = in_dofs end if case ( P_Space ) in_dofs = me % polydegree + 1 do pdim = 2 , in_dim in_dofs = ( in_dofs * ( me % polydegree + pdim ) ) / pdim end do read_dofs = in_dofs case default call tem_abort ( 'Wrong basistype! Select Q_Space or P_Space.' ) end select ! Allocate arrays accordingly. allocate ( indat ( read_dofs )) allocate ( subresdat ( target_dofs , nElems )) inquire ( iolength = rl ) indat datfile = trim ( tree % global % dirname ) // 'subresdata_' & & // trim ( coloring % color_label ( iColor )) // datext fUnit = newunit () open ( unit = fUnit , & & file = datfile , & & action = 'read' , & & access = 'direct' , & & form = 'unformatted' , & & recl = rl , & & status = 'old' ) minord = min ( target_degree + 1 , me % polydegree + 1 ) subresdat = 0.0_rk if ( ( me % basistype == P_Space ) . and . ( target_dim < in_dim ) ) then pre_dofs = me % polydegree + 1 do pdim = 2 , target_dim pre_dofs = ( pre_dofs * ( me % polydegree + pdim ) ) / pdim end do allocate ( predat ( pre_dofs )) do iElem = 1 , nElems read ( fUnit , rec = offset + iElem ) indat call ply_transfer_P_dim ( indat = indat , & & indim = in_dim , & & outdat = predat , & & outdim = target_dim , & & degree = me % polydegree ) call ply_transfer_dofs ( indat = predat , & & inspace = me % basistype , & & indegree = me % polydegree , & & outdat = subresdat (:, iElem ), & & outspace = target_space , & & outdegree = target_degree , & & ndims = target_dim ) end do else do iElem = 1 , nElems read ( fUnit , rec = ( offset + iElem - 1 ) * recs_per_elem + 1 ) indat call ply_transfer_dofs ( indat = indat , & & inspace = me % basistype , & & indegree = me % polydegree , & & outdat = subresdat (:, iElem ), & & outspace = target_space , & & outdegree = target_degree , & & ndims = target_dim ) end do end if close ( fUnit ) else ! No subresolution data at all, allocate the array with size 0. allocate ( subresdat ( 0 , 0 )) end if end subroutine ply_subres_import_color ! ************************************************************************ ! ! ************************************************************************ ! !> Get the color of an element. !! !! This routine provides the get_element for the variable definition. !! It returns the coloring value for the elements in elempos with the given !! number of degrees of freedom. !! !! The header of this subroutine must be same as tem_varSys_proc_element subroutine ply_subres_get_elemcolor ( fun , varSys , elempos , time , tree , & & nElems , nDofs , res ) ! --------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> TreeID of the element to get the variable for. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of elements to obtain for this variable (vectorized access). integer , intent ( in ) :: nElems !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (nComponents of resulting variable) x (nDegrees of freedom) x (nElems) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! --------------------------------------------------------------------- ! type ( ply_subres_colvar_type ), pointer :: p integer :: ipos , iElem integer :: icol_pos integer :: icol_elem integer :: isub_pos integer :: isub_elem integer :: colchar , colbit integer :: cpos integer :: first integer :: minsubdofs logical :: has_subres real ( kind = rk ) :: void , fill ! --------------------------------------------------------------------- ! !! Dummy code to touch unused arguments type ( tem_time_type ) :: now if ( varSys % nStateVars > 0 ) then if ( tree % nElems == nElems ) then now = time end if end if !! end dummy code to touch unused arguments call c_f_pointer ( fun % method_data , p ) cpos = p % colpos icol_pos = 1 icol_elem = p % color % property % elemID ( icol_pos ) has_subres = ( size ( p % subresdat ) > 0 ) ! Byte and bit to probe for this color colchar = 1 + ( cpos - 1 ) / colors_per_char colbit = mod (( cpos - 1 ), colors_per_char ) ! Initialize all degrees of freedom with 0. res = 0.0_rk void = p % color % color_void ( cpos ) fill = p % color % color_fill ( cpos ) do iPos = 1 , nElems iElem = elempos ( ipos ) ! iElem is smaller than the first colored element's ID icol_elem and thus ! can't be colored. if ( iElem < icol_elem ) then ! Not colored element, set first degree of freedom to the void value. res ( nDofs * ( iPos - 1 ) + 1 ) = void else ! The current element is larger or equal than the current colored one. ! Keep on increasing the colored counter, until we reach the current ! element or the end of the list of colored elements !>\\todo HK: we could do a binary search on the colpos, to find the next !!          colored element equal or greater to the current element. do if ( ( iElem <= icol_elem ) & & . or . ( icol_pos == p % color % property % nElems ) ) EXIT icol_pos = icol_pos + 1 icol_elem = p % color % property % elemID ( icol_pos ) end do ! Now the current colored element is either the same as the current ! element, further ahead or the last element in the colored elements. if ( iElem == icol_elem ) then ! For the bit checking, we need to convert the character into an ! integer via ichar. if ( btest ( ichar ( p % color % colored_bit ( colchar , icol_pos )), & & colbit ) ) then res ( nDofs * ( iPos - 1 ) + 1 ) = fill ! If there is subresolution data: Check wether this element is ! subresolved for this color. if ( has_subres ) then isub_pos = 1 isub_elem = p % subres % subres_prop % elem ( cpos )% ID ( isub_pos ) minsubdofs = min ( nDofs , p % nSubdofs ) do if ( ( iElem <= isub_elem ) & & . or . ( isub_pos == p % subres % subres_prop % nElems ( cpos )) ) EXIT isub_pos = isub_pos + 1 isub_elem = p % subres % subres_prop % elem ( cpos )% ID ( isub_pos ) end do if ( iElem == isub_elem ) then if ( btest ( ichar ( p % subres & & % subres_prop & & % subresolved_colors ( colchar , isub_pos )), & & colbit ) ) then ! This element has subresolution information for this color. ! Set it from the subresdat accordingly. first = nDofs * ( iPos - 1 ) res ( first + 1 : first + minsubdofs ) & & = p % subresdat (: minsubdofs , isub_pos ) end if isub_pos = min ( isub_pos + 1 , p % subres % subres_prop % nElems ( cpos )) isub_elem = p % subres % subres_prop % elem ( cpos )% ID ( isub_pos ) end if end if else res ( nDofs * ( iPos - 1 ) + 1 ) = void end if ! We can push the position of the colored element one further, as ! we found the matching element already. icol_pos = min ( icol_pos + 1 , p % color % property % nElems ) icol_elem = p % color % property % elemID ( icol_pos ) else res ( nDofs * ( iPos - 1 ) + 1 ) = void end if end if end do end subroutine ply_subres_get_elemcolor ! ************************************************************************ ! end module ply_subresolution_module","tags":"","url":"sourcefile/ply_subresolution_module.f90.html"},{"title":"sdr_transformation_module.f90 – Seeder","text":"Source Code ! Copyright (c) 2012-2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013-2014, 2017 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! *****************************************************************************! !> This module provide datatype and routine for transformation of !! geometrical objects i.e translation and deformation module sdr_transformation_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_tools_module , only : upper_to_lower use tem_logging_module , only : logunit use tem_canonicalND_module , only : tem_canonicalND_type use flu_binding , only : flu_State use aotus_module , only : aot_get_val , flu_State , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length , aot_table_top , & & aot_table_first implicit none private public :: sdr_transformation_type public :: sdr_translation_type public :: sdr_deformation_type public :: sdr_transformCanoND public :: sdr_load_transformation !> Data type defines geometry translation type sdr_translation_type !>Is translation defined logical :: active !> vector defining translation in x,y,z direction real ( kind = rk ) :: vec ( 3 ) end type sdr_translation_type !> Data type defines geometry scale and rotation type sdr_deformation_type !> Is deformation defined logical :: active !> matrix defining the deformation real ( kind = rk ) :: matrix ( 3 , 3 ) end type sdr_deformation_type !> Data type defines geometry transformation type sdr_transformation_type !> is transformation active logical :: active !> translation of geometry type ( sdr_translation_type ) :: translate !> deformation of geometry type ( sdr_deformation_type ) :: deform end type sdr_transformation_type !> This routine apply transformations to canonical objects interface sdr_transformcanoND module procedure transformcanoND module procedure transformcanoND_single end interface sdr_transformcanoND contains ! ************************************************************************** ! !> This routine loads the transformation table for each spatial object table !! in config file !! !! If single spatial object contains multiple geometry then the transformation !! is applied to all geometries defined in that spatial object subroutine sdr_load_transformation ( transform , conf , thandle ) ! ---------------------------------------------------------------------- ! !inferface variables !> transformation for spatial object type ( sdr_transformation_type ), intent ( out ) :: transform !> lua state type ( flu_state ) :: conf !> spatial object parent handle integer , intent ( in ) :: thandle ! ---------------------------------------------------------------------- ! integer :: transform_handle ! ---------------------------------------------------------------------- ! !set default to false transform % active = . false . call aot_table_open ( L = conf , parent = thandle , & & thandle = transform_handle , & & key = 'transformation' ) if ( transform_handle > 0 ) then write ( logunit ( 1 ), * ) 'Loading transformation ' transform % active = . true . !load translation table call sdr_load_translation ( translate = transform % translate , & & conf = conf , & & thandle = transform_handle ) !load deformation table call sdr_load_deformation ( deform = transform % deform , & & conf = conf , & & thandle = transform_handle ) endif call aot_table_close ( L = conf , thandle = transform_Handle ) end subroutine sdr_load_transformation ! ************************************************************************** ! ! ************************************************************************** ! !> This routine loads the translation table from transformation table subroutine sdr_load_translation ( translate , conf , thandle ) ! ---------------------------------------------------------------------- ! !inferface variables !> translate for spatial object type ( sdr_translation_type ), intent ( out ) :: translate !> lua state type ( flu_state ) :: conf !> spatial object parent handle integer , intent ( in ) :: thandle ! ---------------------------------------------------------------------- ! integer :: translate_handle integer :: vError ( 3 ), errFatal ( 3 ) ! ---------------------------------------------------------------------- ! errFatal = aoterr_fatal translate % active = . false . translate % vec = 0.0_rk call aot_table_open ( L = conf , parent = thandle , & & thandle = translate_handle , & & key = 'translation' ) if ( translate_handle > 0 ) then translate % active = . true . call aot_get_val ( L = conf , thandle = thandle , key = 'translation' , & & val = translate % vec , ErrCode = vError ) if ( any ( btest ( vError , errFatal ))) then write ( logunit ( 0 ), * ) 'Error in configuration: translate table in' write ( logunit ( 0 ), * ) '    transformation table' call tem_abort () end if endif call aot_table_close ( L = conf , thandle = translate_Handle ) if ( translate % active ) then write ( logunit ( 1 ), * ) ' Translation = ' , translate % vec endif end subroutine sdr_load_translation ! ************************************************************************** ! ! ************************************************************************** ! !> This routine loads the deformation table from transformation table subroutine sdr_load_deformation ( deform , conf , thandle ) ! ---------------------------------------------------------------------- ! !inferface variables !> deform for spatial object type ( sdr_deformation_type ), intent ( out ) :: deform !> lua state type ( flu_state ) :: conf !> spatial object parent handle integer , intent ( in ) :: thandle ! ---------------------------------------------------------------------- ! integer :: deform_handle , deform_subhandle integer :: iError , iPos integer :: vError ( 3 ), errFatal ( 3 ) real ( kind = rk ) :: const , vec ( 3 ) ! ---------------------------------------------------------------------- ! errFatal = aoterr_fatal deform % active = . false . deform % matrix = 0.0_rk !First check if deformation is defined as a constant call aot_get_val ( L = conf , thandle = thandle , key = 'deformation' , & & val = const , ErrCode = iError ) if ( btest ( iError , aoterr_fatal )) then call aot_table_open ( L = conf , parent = thandle , & & thandle = deform_handle , & & key = 'deformation' ) if ( deform_handle > 0 ) then deform % active = . true . !deformation is defined as a table call aot_table_open ( L = conf , parent = deform_handle , & & thandle = deform_subhandle , & & pos = 1 ) if ( deform_subhandle > 0 ) then call aot_table_close ( L = conf , thandle = deform_subHandle ) !sub table exist load it as matrix do iPos = 1 , 3 call aot_get_val ( L = conf , thandle = deform_handle , & & pos = iPos , val = vec , ErrCode = vError ) if ( any ( btest ( vError , errFatal ))) then write ( logunit ( 0 ), * ) 'Error in configuration: ' write ( logunit ( 0 ), * ) '     Deformation table at pos' , iPos call tem_abort () end if deform % matrix ( iPos ,:) = vec end do else call aot_table_close ( L = conf , thandle = deform_Handle ) !if single table then it is vec call aot_get_val ( L = conf , thandle = thandle , & & key = 'deformation' , val = vec , ErrCode = vError ) if ( any ( btest ( vError , errFatal ))) then write ( logunit ( 0 ), * ) 'Error in configuration: ' write ( logunit ( 0 ), * ) '   Loading deformation table as vector' call tem_abort () end if deform % matrix ( 1 , 1 ) = vec ( 1 ) deform % matrix ( 2 , 2 ) = vec ( 2 ) deform % matrix ( 3 , 3 ) = vec ( 3 ) endif else !deformation table not defined !close the table call aot_table_close ( L = conf , thandle = deform_Handle ) endif else !it is a constant scaling factor deform % active = . true . deform % matrix ( 1 , 1 ) = const deform % matrix ( 2 , 2 ) = const deform % matrix ( 3 , 3 ) = const endif if ( deform % active ) then write ( logunit ( 1 ), \"(A,3E12.5)\" ) ' Deformation = ' , deform % matrix ( 1 ,:) write ( logunit ( 1 ), \"(A,3E12.5)\" ) '               ' , deform % matrix ( 2 ,:) write ( logunit ( 1 ), \"(A,3E12.5)\" ) '               ' , deform % matrix ( 3 ,:) endif end subroutine sdr_load_deformation ! ************************************************************************** ! ! ************************************************************************** ! !> This routine apply transformation to canonical objects. subroutine transformCanoND ( canoND , transform ) ! ---------------------------------------------------------------------- ! !> canonical geometry object type type ( tem_canonicalND_type ), intent ( inout ) :: canoND (:) !> transformation for spatial object type ( sdr_transformation_type ), intent ( in ) :: transform ! ---------------------------------------------------------------------- ! integer :: iCano ! ---------------------------------------------------------------------- ! do iCano = 1 , size ( canoND ) call transformCanoND_single ( canoND = canoND ( iCano ), & & transform = transform ) end do end subroutine transformCanoND ! ************************************************************************** ! ! ************************************************************************** ! !> This routine apply transformation to canonical objects. subroutine transformCanoND_single ( canoND , transform ) ! ---------------------------------------------------------------------- ! !> canonical geometry object type type ( tem_canonicalND_type ), intent ( inout ) :: canoND !> transformation for spatial object type ( sdr_transformation_type ), intent ( in ) :: transform ! ---------------------------------------------------------------------- ! integer :: iVec ! ---------------------------------------------------------------------- ! if ( transform % active ) then if ( transform % deform % active ) then canoND % origin = matmul ( transform % deform % matrix , & & canoND % origin ) do iVec = 1 , canoND % nDim canoND % vec (:, iVec ) = matmul ( transform % deform % matrix , & & canoND % vec (:, iVec ) ) enddo endif if ( transform % translate % active ) then canoND % origin = transform % translate % vec + canoND % origin endif endif end subroutine transformCanoND_single ! ************************************************************************** ! end module sdr_transformation_module !> \\page transformation Transformation !! Transformation is used to scale, translate, rotate and reflect !! the geometrical objects. Trasformation table is defined in the spatial !! object table in the lua config file. If the geometry in the spatial !! object contains multiple geometries then the transformation defined in that !! spatial object is applied to all the geometries.\\n !! If both translation and deformation are defined for the geometry object !! then the deformation is applied first and then the deformed geometry !! is then translated.\\n !! !! \\li Translation !! Translation is a table with three entries defining x,y,z coordinate values !! to translate the geometrical object. !! Gometry is translated just by adding the position of the geometry with !! given translation vector.\\n !! Example: !! \\verbatim !! spatial_object={ !!   ...<attribute>... !!   ...<geometry>... !!   transformation={ !!     translation={0.0,2.0,0.0} -- translating the object along y-axis by 2.0 !!   } !! } !! \\endverbatim !! \\n !! \\li Deformation !! Deformation table can be used to scale, rotate and reflect the geometry. !! Deformation cane be defined as const, vector and matrix. In the code, !! it is converted to matrix with 3x3. Matrix is multiplied with a geometry !! vector to scale, rotate or reflect depends on the given matrix. !! !! * Scaling !! If deformation is const, then geometry is scaled in all three directions !! with const and it is vector with three entries, then geometry is scaled in !! x,y,z directions with different factor.\\n !! Example: !! ** Constant scaling in three direction !!\\verbatim !! spatial_object={ !!   ...<attribute>... !!   ...<geometry>... !!   transformation={ !!     deformation = 2.0, -- scaled in all direction by 2.0 !!   } !!} !!\\endverbatim !! ** Different scaling in three direction !!\\verbatim !! spatial_object={ !!   ...<attribute>... !!   ...<geometry>... !!   transformation={ !!     deformation = {0.5,2.0,1.5} !!   } !!} !!\\endverbatim !! * Reflection !! Below example reflect the geometry object in y-axis !!\\verbatim !! spatial_object={ !!   ...<attribute>... !!   ...<geometry>... !!   transformation={ !!     deformation = {1.0,-1.0,1.0} !!   } !!} !!\\endverbatim !! *Rotation !! Rotation is defined by the deformation table with 3x3 entries. !! Below example rotate the geometry object in z-axis in anti-clockwise !! direction by 45 degrees. !!\\verbatim !! spatial_object={ !!   ...<attribute>... !!   ...<geometry>... !!   transformation={ !!     deformation = { !!                    { 0.5*math.cos(45*math.pi/180), !!                      -0.5*math.sin(45*math.pi/180), !!                      0.0 }, !!                    { 0.5*math.sin(45*math.pi/180), !!                      0.5*math.cos(45*math.pi/180), !!                      0.0 }, !!                    { 0.0, 0.0, 0.5 } !!     } !!   } !!} !!\\endverbatim !! More information on rotatation matrix can be found in !! http://en.wikipedia.org/wiki/Rotation_(mathematics) !! \\n !! It is also possible to combine scaling, reflection and rotation in the !! deformation matrix. !! Example lua file is available at \\link testsuite/transform/seeder.lua !! \\example testsuite/transform/seeder.lua","tags":"","url":"sourcefile/sdr_transformation_module.f90.html"},{"title":"sdr_flooding_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_flooding_module.f90~~EfferentGraph sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_timer_module.f90 sdr_timer_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_timer_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_flooding_module.f90~~AfferentGraph sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2014, 2016 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2015 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012, 2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012, 2014 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2015 Samuel Ziegenberg ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2018 Daniel Fleischer <daniel.fleischer@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ***************************************************************************** !> This module provides the functionality to find the part of the universe !! cube, which is actually building up the computational domain. module sdr_flooding_module use env_module , only : rk , long_k , eps use tem_param_module , only : qQQQ , qOffset use treelmesh_module , only : treelmesh_type use tem_geometry_module , only : tem_eligibleChildren , tem_ElemSize , & & tem_baryOfID use tem_topology_module , only : tem_directChildren , tem_LevelOf , & & tem_parentOf , tem_CoordOfID , tem_IdOfCoord use tem_tools_module , only : tem_positionInSorted use tem_logging_module , only : tem_log , tem_toStr use tem_debug_module , only : main_debug use sdr_protoTree_module , only : sdr_protoTree_type , sdr_neighbor_in_proto , & & sdr_write_proto_as_restart use sdr_geometry_module , only : sdr_geometry_type use sdr_node_module , only : isFlooded_bit , IntersectsBoundary_bit , & & sdr_wetNeighborsFace , sdr_mark_floodNode , & & isLeaf_bit use sdr_config_module , only : sdr_confHead_type use sdr_boundary_module , only : needCalcQValByBCID , sdr_qValByNode , & & needFldDglByBCID , sdr_qVal_no_intersection use sdr_timer_module , only : timer_handle_flooding use tem_timer_module , only : tem_startTimer , tem_stopTimer implicit none private public :: sdr_flood_tree contains ! ***************************************************************************** !> This routine identifies the nodes, which are supposed to be part of the !! computational domain, as defined by the seed objects. !! subroutine sdr_flood_tree ( proto , geometry , header , meshUniverse ) ! --------------------------------------------------------------------------! !> The proto tree description with all the data enabling the flooding. type ( sdr_protoTree_type ), intent ( inout ) :: proto !> Description of geometric objects. Propably not needed here, remove again !! if this is the case. type ( sdr_geometry_type ), intent ( in ) :: geometry !> some global information on solver name and version type ( sdr_confHead_type ), intent ( inout ) :: header !> treelmesh contains bounding cube info type ( treelmesh_type ), intent ( in ) :: meshUniverse ! --------------------------------------------------------------------------! ! --------------------------------------------------------------------------! call tem_startTimer ( timerHandle = timer_handle_flooding ) call tem_log ( 1 , 'Flooding tree ... ' ) call floodwaves_tree ( proto = proto , & & header = header , & & geometry = geometry ) call tem_log ( 2 , 'Number of Flooded leaves: ' & & // trim ( tem_toStr ( proto % nFloodedLeaves )) ) ! JQ: if qVal is required, flood some additional nodes. only do it once. if ( any ( geometry % attribute % dynArray % val ( : )% calc_dist ) ) then call flood_periphery ( proto , geometry , meshUniverse ) end if !! Mark all virtual nodes, which contain a flooded child as flooded !! starting from the second finest level moving up to the root. !! This allows to easily avoid non-flooded domains later on. call flood_parents ( proto , geometry % attribute % color_inverted ) call tem_stopTimer ( timerHandle = timer_handle_flooding ) end subroutine sdr_flood_tree ! ***************************************************************************** ! ***************************************************************************** !> This routine loop over all nodes are flood non-interesting leaf node with !! wet face and inherit the wetness of the virtual node to the eligble !! childrens !! !! The algorithm works by flooding the domain, starting from the seed points !! up to boundary elements. This approach is quite robust to broken STL !! definitions, as any cracks below the resolution are automatically healed !! and there is no dependece on the orientation of the surfaces. !! To avoid unintended leaking, the flooding takes only the 6 side neighbors !! into account, that is the computational domain will always be connected !! by faces, there will be no parts of the domain which are only connected !! by edges or corners. !! !! Seeds are already marked as flooded during the previous leaf !! identification, also the neighboring sides have already been marked as wet. !! Note, that seeds in nodes with boundaries are ignored and not flooded. !! !! Several iterations are done, referred to as waves and within each the !! following algorithm is used: !! !! Iterate over all nodes. !! - If node is a leaf !!   + If not intersecting boundaries: !!     * Check if any side is wet, and if so, flood yourself. !!       If flooded, mark all neighboring sides as wet. !!   + If intersecting boundaries: nothing to do! !! !! - For virtual nodes: (if not leaf) !!   + Inherit wet sides down to the direct children on this side !!     (eligible children). !! !! The procedure is finished, if no property changed during a wave. !! (Flooded status and wet faces are encoded in the PropertyBits field. !! subroutine floodwaves_tree ( proto , header , geometry ) ! --------------------------------------------------------------------------! !> The proto tree description with all the data enabling the flooding. type ( sdr_protoTree_type ), intent ( inout ) :: proto !> some global information on solver name and version type ( sdr_confHead_type ), optional , intent ( in ) :: header type ( sdr_geometry_type ), intent ( in ) :: geometry ! --------------------------------------------------------------------------! integer :: iNode , faceBitCheck , iDir , iSide integer ( kind = long_k ) :: childIds ( 8 ) integer ( kind = long_k ) :: virtualId integer , allocatable :: eligible_childs (:) integer :: childPos , wetFace integer :: wetFaceBit_pos integer :: iChild integer , allocatable :: old_prop (:,:) integer :: iWave integer :: iColor integer :: col_int integer :: col_bit integer :: myColor integer :: nodeprops integer :: propLength ! --------------------------------------------------------------------------! propLength = proto % node % propLength allocate ( old_prop ( propLength , proto % node % nNodes )) ! The layout of each color is: ! intersection with boundaries is set in bit 0 ! volume flooded is indicated by bit 1 ! faces are indicated by bits 2-7 ! Thus, if any face is wet, the color is >= 4 faceBitCheck = 4 ! Iterations to flood (waves) ! (limit by number of nodes, we should not need to do more than number !  of nodes iterations, though this limit is somewhat arbitrary) ! Leave loop, when no property was changed during the wave. ! This should typically happen much faster. waves : do iWave = 1 , proto % node % nNodes ! First save the current properties for later comparison: old_prop = proto % node % PropertyBits % val ! Iterate over all nodes. ! Nodes are sorted level-wise with the coarser levels coming first. ! The nodeloop thus iterates over the elements in a top down fashion, ! wet faceness of coarser nodes is therefore automatically propagated down ! within a single wave. nodeLoop : do iNode = 1 , proto % node % nNodes nodeprops = ibits ( proto % node % PropertyBits % val ( propLength , iNode ), & & pos = proto % node % lastbyte_pos , len = 8 ) ! Depending on the type of node take some action isleaf : if ( btest ( nodeprops , isLeaf_Bit ) ) then ! For leaves: col_loop1 : do iColor = 1 , proto % node % nColors col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 myColor = ibits ( proto % node % PropertyBits % val ( col_int , iNode ), & & pos = col_bit , len = 8 ) ! myColor bit 0 encodes the intersecting status of the node ! myColor bit 1 encodes its flooding, both have to be not true, ! otherwise we have nothing to do. Thus, the following check ! ensures, they are both 0: if ( mod ( myColor , 4 ) == 0 ) then ! NOT intersecting (relevant) boundaries, and not flooded yet. ! Check if any of my sides are wet, and if so, flood myself and ! wet my neighbors sides accordingly. if ( myColor >= faceBitCheck ) then ! I got a wet side and am a leaf node, flood myself now and ! increase the flooded leaf counter accordingly. call sdr_mark_floodNode ( proto % node , & & iNode , & & proto % nFloodedLeaves , & & color = iColor ) ! Now mark all neighboring sides with the color set above. call sdr_wetNeighborsFace ( proto % node , iNode , col_int , col_bit ) end if ! at least one of my faces is wet end if end do col_loop1 else isleaf ! For virtual nodes: ! Inherit wet sides down to the direct children on this side ! (eligible children). ! Only need to take action, if any of the faces is wet. col_loop2 : do iColor = 1 , proto % node % nColors col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 myColor = ibits ( proto % node % PropertyBits % val ( col_int , iNode ), & & pos = col_bit , len = 8 ) wetside : if ( myColor >= faceBitCheck ) then ! Find direct childern of the virtual node and then check for ! specific wet face and find the eligible children in the ! direction of the wet face and mark the corresponding faces in ! the neighbor in that direction as wet. ! Some auxilary variables virtualId = proto % node % TreeID % val ( iNode ) childIds = tem_directChildren ( virtualId ) ! Iterate over all 6 sides of the node do iDir = 1 , 3 do iSide = 1 , 2 wetFace = ( ( iDir - 1 ) * 2 + iSide ) + 1 wetFaceBit_pos = col_bit + wetFace ! Check if this face is wet if ( btest ( myColor , wetFace )) then ! Encountered a wet side, select the 4 elegible children ! adjacent to this side. ! (Have to use the treelm numbering of sides, given by the !  iDir + 3*(iSide-1) formula). call tem_eligibleChildren ( eligible_childs , & & iDir + 3 * ( iSide - 1 ) ) ! Iterate over all children and mark their faces in the ! current direction as wet. do iChild = 1 , size ( eligible_childs ) ! The first child is given by linkpos(1), and all others ! follow consecutively. childpos = proto % node % linkpos ( 1 )% val ( iNode ) & & + eligible_childs ( iChild ) - 1 ! Wet this childs face in the current direction. proto % node % PropertyBits % val ( col_int , childPos ) & & = ibset ( proto % node % PropertyBits & & % val ( col_int , childPos ), & & wetFaceBit_pos ) end do end if end do ! side loop end do ! dirloop end if wetside end do col_loop2 end if isleaf end do nodeLoop ! output debug information as restart files if ( ( trim ( main_debug % debugMesh ) . ne . '' ) . and . & & ( main_debug % debugFiles ) ) then !debug output call sdr_write_proto_as_restart ( proto , geometry , & & iwave , header , 'flood' ) end if ! Compare the new properties to the old ones, if nothing changed leave the ! loop! if ( all ( ieor ( old_prop , proto % node % PropertyBits % val ) == 0 )) EXIT waves end do waves deallocate ( old_prop ) call tem_log ( 1 , '               ... done with nWaves = ' & & // trim ( tem_toStr ( iWave )) ) end subroutine floodwaves_tree ! ***************************************************************************** ! ***************************************************************************** !> This routine loops over all intersected with geoemtry nodes and fluidify !! some node according to the following rule:\\n !! 1. one of its link does noe intersect with any geometry that requires qVal !! 2. it has fluid neighbor on that direction. !!    i.e. it is wet in that side. !! Jiaxing Qi !! !!@todo HK: works for single color only right now! !!          (qvalues are only computed for first color, need to think about !!           what to do for multiple colors.) subroutine flood_periphery ( proto , geometry , meshUniverse ) ! --------------------------------------------------------------------------! !> The proto tree description with all the data enabling the flooding. type ( sdr_protoTree_type ), intent ( inout ) :: proto !> Description of geometric objects. type ( sdr_geometry_type ), intent ( in ) :: geometry !> treelmesh contains bounding cube info type ( treelmesh_type ), intent ( in ) :: meshUniverse ! --------------------------------------------------------------------------! integer :: iNode , iDir , iSide , iLink , wetFace integer :: wetFaceBit_pos integer ( kind = long_k ) :: treeID !> qVal for 6 faces real ( kind = rk ) :: qVal ( 1 : qQQQ ) real ( kind = rk ) :: bary ( 3 ) real ( kind = rk ) :: dx integer :: oldFlood integer :: myColor integer :: col_int , col_bit integer :: iColor integer :: nodeprops integer :: proplength ! --------------------------------------------------------------------------! proplength = proto % node % propLength oldFlood = proto % nFloodedLeaves call tem_log ( 1 , 'Flooding periphery (calc_dist active) ... ' ) ! loop over all nodes do iNode = 1 , proto % node % nNodes nodeprops = ibits ( proto % node % PropertyBits % val ( propLength , iNode ), & & pos = proto % node % lastbyte_pos , len = 8 ) ! Only proceed if this is a leaf. isLeaf : if ( btest ( nodeprops , isLeaf_Bit ) ) then ! Act on qValues only in the first color! do iColor = 1 , 1 !proto%node%nColors col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 myColor = ibits ( proto % node % PropertyBits % val ( col_int , iNode ), & & pos = col_bit , len = 8 ) ! If the node is not flooded yet (bit 1) and intersects a boundary ! relevant to this color (bit 0) nonfloodbc : if ( mod ( myColor , 4 ) == 1 ) then ! Now check the intersected boundaries for the need to find the ! q-values. needq : if ( needCalcQValByBCID ( geometry % attribute , & & proto % node % minBCID % val ( iNode )) ) then treeID = proto % node % treeID % val ( iNode ) Bary = tem_BaryOfID ( meshUniverse , treeID ) dx = tem_ElemSize ( meshUniverse , treeID ) qVal = sdr_qVal_no_intersection ! loop over all 26 directions as per order in tem_param_module ! compute all qVal once and use it for axis normal and ! diagonal axis do iDir = 1 , qQQQ ! calculate qVal from myself (boundarz node) call sdr_qValByNode ( proto , geometry , dx , iDir , & & Bary , iNode , qVal ( iDir ) ) end do ! Only proceed if no boundary runs through the bary center ! (qval == 0) qValEpsCheck : if ( minval ( qVal , mask = qVal >= 0 ) > eps ) then ilinkLoop : do iDir = 1 , 3 do iSide = 1 , 2 ! loop over 6 flooding links: -x, +x, -y, +y, -z, +z iLink = iDir + 3 * ( iSide - 1 ) wetFace = iSide + ( iDir - 1 ) * 2 wetFaceBit_pos = wetface + col_bit + 1 ! When there is no intersection in this direction, we need ! to check if flooding of the current node is necessary. if ( qVal ( iLink ) < 0.0_rk ) then ! If the neighbor in this direction is a fluid, it has ! wetted my side. As it is reachable without any obstacle ! in between, the current node needs to be flooded, too. if ( btest ( proto % node % PropertyBits % val ( col_int , iNode ), & & wetfaceBit_pos ) ) then call sdr_mark_floodNode ( proto % node , & & iNode , & & proto % nFloodedLeaves , & & color = iColor ) exit iLinkLoop end if end if end do end do ilinkLoop ! Check qval for diagonal directions for flooding if ( needFldDglByBCID ( geometry % attribute , & & proto % node % minBCID % val ( iNode )) ) then call flood_periphery_diagonal ( proto , iNode , treeID , & & qVal , iColor ) end if end if qValEpsCheck end if needq end if nonfloodbc end do end if isLeaf end do ! iNode call tem_log ( 1 , ' ... Done flooding the periphery!' ) call tem_log ( 2 , 'Number of Flooded leaves in periphery: ' & & // trim ( tem_toStr ( proto % nFloodedLeaves - oldFlood )) ) call tem_log ( 1 , 'Final number of Flooded leaves: ' & & // trim ( tem_toStr ( proto % nFloodedLeaves )) ) end subroutine flood_periphery ! ***************************************************************************** ! ***************************************************************************** !> This routine checks for qVal of the periphery and floods if qVal < 0 and !! the node in that direction is fluid and not intersected by boundary subroutine flood_periphery_diagonal ( proto , node_pos , treeID , qVal , iColor ) ! --------------------------------------------------------------------------! !> The proto tree description with all the data enabling the flooding. type ( sdr_protoTree_type ), intent ( inout ) :: proto !> node position in protoTree integer , intent ( in ) :: node_pos !> treeID of current node integer ( kind = long_k ), intent ( in ) :: treeID !> qVal for all 26 neighbor directions, should be calculated already real ( kind = rk ) :: qVal ( : ) !> Color to do the flooding in integer , intent ( in ) :: iColor ! --------------------------------------------------------------------------! integer :: coord ( 4 ), neighbor_pos , neighbor_level , iDir integer :: col_int , col_bit , myColor integer :: neighColor ! --------------------------------------------------------------------------! col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 myColor = ibits ( proto % node % PropertyBits % val ( col_int , node_pos ), & & pos = col_bit , len = 8 ) coord = tem_coordOfId ( treeID = treeID ) off_dirLoop : do iDir = 7 , qQQQ ! fluidify this node, if not intersected with boundary i.e. qVal = -1.0 ! and has a fluid in that direction if ( qVal ( iDir ) < 0 ) then ! get neighbor position in protoTree neighbor_pos = sdr_neighbor_in_proto ( proto , coord , iDir , & & neighbor_level ) neighColor = ibits ( proto % node % PropertyBits % val ( col_int , neighbor_pos ), & & pos = col_bit , len = 8 ) ! check if neighbor in this direction is flooded (bit 1) and ! not intersected by any geometry (bit 0) if ( mod ( neighColor , 4 ) == 2 ) then ! mark it as isFlooded ! these nodes are flooded then, but also intersect boundaries ! Found a new flooded leaf, increase the counter accordingly. call sdr_mark_floodNode ( node = proto % node , & & iNode = node_pos , & & nFloodedLeaves = proto % nFloodedLeaves , & & color = iColor ) return end if end if end do off_dirLoop end subroutine flood_periphery_diagonal ! ***************************************************************************** ! ***************************************************************************** !> Mark all virtual nodes, which contain a flooded child as flooded !! starting from the second finest level moving up to the root. !! This allows to easily avoid non-flooded domains later on. subroutine flood_parents ( proto , color_inverted ) ! --------------------------------------------------------------------------! !> The proto tree description with all the data enabling the flooding. type ( sdr_protoTree_type ), intent ( inout ) :: proto !> List of flags for each color to indicate, wether the color should be !! inverted after flooding. logical , intent ( in ) :: color_inverted (:) ! --------------------------------------------------------------------------! integer :: iNode , iLevel , firstchild integer :: childprops ( 8 ) integer :: nodeflooded_bit integer :: propLength integer :: nodeprops integer :: col_int , col_bit integer :: iColor integer :: nInverted integer :: iInv integer , allocatable :: invColor (:) ! --------------------------------------------------------------------------! propLength = proto % node % propLength nodeflooded_bit = proto % node % lastbyte_pos + isFlooded_bit nInverted = count ( color_inverted ) allocate ( invColor ( nInverted )) ! If any color needs to be inverted, run through the finest level also, and ! invert color floodings as needed. if ( nInverted > 0 ) then iInv = 0 do iColor = 1 , proto % node % nColors if ( color_inverted ( iColor )) then iInv = iInv + 1 invColor ( iInv ) = iColor end if end do iLevel = proto % nLevels ! All nodes on the finest level have to be leaves. do iNode = proto % levelNode_first ( iLevel ), proto % levelNode_last ( iLevel ) nodeprops = ibits ( proto % node % PropertyBits % val ( propLength , iNode ), & & pos = proto % node % lastbyte_pos , len = 8 ) ! Only consider elements, that are flooded by any color (especially the ! none color). If an element is not belonging to the domain identified ! positively by the none color, we will not invert its color floodings. if ( btest ( nodeprops , isFlooded_bit ) ) then do iInv = 1 , nInverted col_int = ( invColor ( iInv ) - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( invColor ( iInv ) - 1 , proto % node % bytes_per_int ) * 8 if ( btest ( proto % node % PropertyBits % val ( col_int , iNode ), & & col_bit + 1 ) ) then proto % node % PropertyBits % val ( col_int , iNode ) & & = ibclr ( proto % node % PropertyBits % val ( col_int , iNode ), & & col_bit + 1 ) else proto % node % PropertyBits % val ( col_int , iNode ) & & = ibset ( proto % node % PropertyBits % val ( col_int , iNode ), & & col_bit + 1 ) end if end do end if end do end if do iLevel = proto % nLevels - 1 , 0 , - 1 do iNode = proto % levelNode_first ( iLevel ), proto % levelNode_last ( iLevel ) nodeprops = ibits ( proto % node % PropertyBits % val ( propLength , iNode ), & & pos = proto % node % lastbyte_pos , len = 8 ) if ( btest ( nodeprops , isLeaf_bit ) ) then ! Check leaves for inversion of flooding status. if ( btest ( nodeprops , isFlooded_bit ) ) then do iInv = 1 , nInverted col_int = ( invColor ( iInv ) - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( invColor ( iInv ) - 1 , proto % node % bytes_per_int ) * 8 if ( btest ( proto % node % PropertyBits % val ( col_int , iNode ), & & col_bit + 1 ) ) then proto % node % PropertyBits % val ( col_int , iNode ) & & = ibclr ( proto % node % PropertyBits % val ( col_int , iNode ), & & col_bit + 1 ) else proto % node % PropertyBits % val ( col_int , iNode ) & & = ibset ( proto % node % PropertyBits % val ( col_int , iNode ), & & col_bit + 1 ) end if end do end if else ! If any of the node children are flooded, the node has to be ! considered in the final mesh. Thus, mark it accordingly in this ! case. Only non-leaves need to be considered here. firstChild = proto % node % linkPos ( 1 )% val ( iNode ) childprops = ibits ( proto % node % PropertyBits & & % val ( propLength , firstChild & & : firstChild + 7 ), & & pos = proto % node % lastbyte_pos , len = 8 ) if ( any ( btest ( childprops , isFlooded_bit )) ) then proto % node % PropertyBits % val ( propLength , iNode ) & & = ibset ( proto % node % PropertyBits % val ( propLength , iNode ), & & nodeflooded_bit ) end if do iColor = 1 , proto % node % nColors col_int = ( iColor - 1 ) / proto % node % bytes_per_int + 1 col_bit = mod ( iColor - 1 , proto % node % bytes_per_int ) * 8 childprops = ibits ( proto % node % PropertyBits % val ( col_int , & & firstChild & & : firstChild + 7 ), & & pos = col_bit , len = 8 ) if ( any ( btest ( childprops , 1 )) ) then proto % node % PropertyBits % val ( col_int , iNode ) & & = ibset ( proto % node % PropertyBits % val ( col_int , iNode ), & & col_bit + 1 ) end if end do end if end do end do end subroutine flood_parents ! ***************************************************************************** end module sdr_flooding_module","tags":"","url":"sourcefile/sdr_flooding_module.f90.html"},{"title":"sdr_cylinder_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_cylinder_module.f90~~AfferentGraph sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2014, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2014, 2022 Harald Klimach <harald.klimach@dlr.de> ! Copyright (c) 2012 Sathish Krishnan P S <s.krishnan@grs-sim.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** !> author: Kannan Masilamani !! This module contain adapter routine to load cylinder objects and add them to !! list of spatial objects module sdr_cylinder_module use env_module , only : rk use tem_param_module , only : PI use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_transformation_module , only : tem_transformation_type use tem_cylinder_module , only : tem_cylinder_type , tem_load_cylinder , & & grw_cylinderArray_type , append use aotus_module , only : flu_State , aot_get_val , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use sdr_spatialObj_module , only : grw_spatialObjArray_type , & & sdr_spatialObj_type , append , & & cylinder implicit none private public :: sdr_load_cylinder public :: append_cylinder2SpaObj contains ! **************************************************************************** !> \\brief Loading cylinder information from config file \\n subroutine sdr_load_cylinder ( cylArray , spaObjArray , attr_pos , transform , & & conf , thandle ) ! --------------------------------------------------------------------------! !inferface variables !> growing array of cylinders type ( grw_cylinderArray_type ), intent ( inout ) :: cylArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> Position of the attribute to connect this object to. integer , intent ( in ) :: attr_pos !> transformation for spatial object type ( tem_transformation_type ), intent ( in ) :: transform !> lua state type ( flu_state ) :: conf integer , intent ( in ) :: thandle !< handle for canonical objects ! --------------------------------------------------------------------------! ! local varaibles integer :: iObj type ( tem_cylinder_type ), allocatable :: loc_cylinder (:) ! --------------------------------------------------------------------------! ! load cylinder call tem_load_cylinder ( loc_cylinder , transform , conf , thandle ) !append cylinder do iObj = 1 , size ( loc_cylinder ) call append_cylinder2SpaObj ( cylArray , spaObjArray , attr_pos , & & loc_cylinder ( iObj ) ) end do end subroutine sdr_load_cylinder ! ***************************************************************************** ! ***************************************************************************** !> This routine single cylinder from object table subroutine append_cylinder2SpaObj ( cylArray , spaObjArray , attr_pos , & & loc_cylinder ) ! --------------------------------------------------------------------------! !inferface variables !> growing array of cylinders type ( grw_cylinderArray_type ), intent ( inout ) :: cylArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> Position of the attribute to connect this object to. integer , intent ( in ) :: attr_pos type ( tem_cylinder_type ), intent ( in ) :: loc_cylinder ! --------------------------------------------------------------------------! type ( sdr_spatialObj_type ) :: spatialObj ! --------------------------------------------------------------------------! !append cylinder to cylinder array spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = cylinder call append ( cylArray , loc_cylinder ) spatialObj % primitive_position = cylArray % nVals !add spatialObj to spatialObj list call append ( spaObjArray , spatialObj ) end subroutine append_cylinder2SpaObj end module sdr_cylinder_module !> \\page cylinder Cylinders !! Cylinders are defined by an origin, vector defining the length and the !! axis and the radius. !! Cylinder is considered to be solid as default i.e. all the cubes inside the !! cylinder are marked as intersected cubes. !! It is possible to created hollow cylinders by setting only_surface = true, !! it will mark only the cubes intersect with cylinder surface as intersected !! cubes !! !! Valid definition: !! \\li Single cylinder !! \\verbatim !! geometry={ !!   kind='cylinder', !!     object={ !!       origin={0.0,0.0,0.0}, !!       vec={1.0,0.0,0.0}, !!       radius=0.25, !!       only_surface = true, -- If not defined default is set to false !!     } !! } !! \\endverbatim !! !! \\li Multiple cylinder !! \\verbatim !! geometry={ !!   kind='cylinder', !!     object={ !!       { !!       origin={0.0,0.0,0.0}, !!       vec={1.0,0.0,0.0}, !!       radius=0.25 !!       }, !!       { !!       origin={0.0,0.0,0.0}, !!       vec={1.0,1.0,0.0}, !!       radius=0.25 !!       } !!     } !! } !! \\endverbatim !! \\n\\n !! Seeder file to generate mesh with single cylinder (only_surface=true) is below: !! include testsuite/plane/seeder.lua !! \\n\\n !! Mesh with hollow cylinder (Hollow => only_surface = true) !! \\image html cylinder.png !! \\n\\n !! \\image html cylinder_withedges.png !! \\n\\n !! Cutview of mesh with hollow cylinder !! \\image html cylinder_hollow.png !! \\n\\n !! As said earlier, cylinder can be created as solid one using 'only_surface=false'. !! Cutview of Mesh generated with 'only_surface=false': !! \\image html cylinder_solid.png !! \\n\\n !! Example lua file is available at \\link testsuite/cylinder/seeder.lua !! \\example testsuite/cylinder/seeder.lua","tags":"","url":"sourcefile/sdr_cylinder_module.f90.html"},{"title":"ply_lagrange_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_lagrange_module.f90~~EfferentGraph sourcefile~ply_lagrange_module.f90 ply_lagrange_module.f90 sourcefile~ply_nodeset_module.f90 ply_nodeset_module.f90 sourcefile~ply_lagrange_module.f90->sourcefile~ply_nodeset_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ply_lagrange_module.f90~~AfferentGraph sourcefile~ply_lagrange_module.f90 ply_lagrange_module.f90 sourcefile~ply_l2p_module.f90 ply_l2p_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_lagrange_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! ! !> Lagrange polynomial representation. !! !! Lagrange polynomial series by the values at given nodes. !! The nodes to be used are to be given in form of [[ply_nodeset_coords]]. module ply_lagrange_module use env_module , only : rk use ply_nodeset_module , only : ply_nodeset_coords implicit none private type ply_lagrange_type !> Number of points to represent the Lagrange polynomials integer :: nPoints !> Coordinates of the points where the nodes are to be found. real ( kind = rk ), allocatable :: coords (:) !> Values of the function at all coords. real ( kind = rk ), allocatable :: values (:) end type ply_lagrange_type public :: ply_lagrange_type public :: ply_lagrange_define public :: ply_lagrange_eval public :: ply_lagrange_mode_at public :: ply_lagrange_1D contains ! ------------------------------------------------------------------------ ! !> Define a new polynomial in the Lagrange basis. function ply_lagrange_define ( nPoints , nodeset , values ) result ( me ) ! -------------------------------------------------------------------- ! !> Number of points to define the polynomial. integer , intent ( in ) :: nPoints !> The set of nodes where the function assumes the given values. procedure ( ply_nodeset_coords ) :: nodeset !> Function values at all nPoints of the nodeset. real ( kind = rk ), intent ( in ) :: values ( nPoints ) !> The newly created Lagrange series describing the polynomial function. type ( ply_lagrange_type ) :: me ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! me % nPoints = nPoints allocate ( me % coords ( nPoints )) me % coords = nodeset ( nPoints ) allocate ( me % values ( nPoints )) me % values = values end function ply_lagrange_define ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Evaluate a polynomial in the Lagrange basis at some point x. function ply_lagrange_eval ( me , x ) result ( f ) ! -------------------------------------------------------------------- ! !> The polynomial in Lagrange basis to evaluate at point x. type ( ply_lagrange_type ), intent ( in ) :: me !> Coordinate at which the function is to be evaluated. real ( kind = rk ), intent ( in ) :: x !> Value of the polynomial at coordinate x. real ( kind = rk ) :: f ! -------------------------------------------------------------------- ! integer :: iPoint ! -------------------------------------------------------------------- ! f = me % values ( 1 ) * ply_lagrange_mode_at ( me = me , mode = 1 , x = x ) do iPoint = 2 , me % nPoints f = f + me % values ( iPoint ) & & * ply_lagrange_mode_at ( me = me , mode = iPoint , x = x ) end do end function ply_lagrange_eval ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Evaluate the given Lagrangian mode (which is 1 at coord(mode) and 0 in !! all other points) at a given point x. function ply_lagrange_mode_at ( me , mode , x ) result ( f ) ! -------------------------------------------------------------------- ! !> The polynomial in Lagrange basis. type ( ply_lagrange_type ), intent ( in ) :: me !> Mode to evaluate at x. !! !! Here mode identifies the polynomial that is 1 in me%coord(mode) and !! 0 in all other nodes. integer , intent ( in ) :: mode !> Coordinate at which the mode is to be evaluated. real ( kind = rk ), intent ( in ) :: x !> Value of the polynomial at coordinate x. real ( kind = rk ) :: f ! -------------------------------------------------------------------- ! integer :: iPoint real ( kind = rk ) :: x_m ! -------------------------------------------------------------------- ! f = 1.0_rk x_m = me % coords ( mode ) do iPoint = 1 , mode - 1 f = f * ( x - me % coords ( iPoint )) & & / ( x_m - me % coords ( iPoint )) end do do iPoint = mode + 1 , me % nPoints f = f * ( x - me % coords ( iPoint )) & & / ( x_m - me % coords ( iPoint )) end do end function ply_lagrange_mode_at ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! Compute each Lagrange mode for every given point. function ply_lagrange_1D ( me , points ) result ( pointval ) ! -------------------------------------------------------------------- ! !> Definition of the Lagrange polynomial basis to evaluate at points. type ( ply_lagrange_type ), intent ( in ) :: me !> List of points at which the polynomials are to be evaluated. real ( kind = rk ), intent ( in ) :: points (:) !> Resulting Lagrange values at all points. !! !! First dimension holds the Lagrange modes, second dimension the !! points. real ( kind = rk ) :: pointval ( me % nPoints , size ( points )) ! -------------------------------------------------------------------- ! integer :: nPoints integer :: iPoint integer :: iMode ! -------------------------------------------------------------------- ! nPoints = size ( points ) do iPoint = 1 , nPoints do iMode = 1 , me % nPoints pointval ( iMode , iPoint ) = ply_lagrange_mode_at ( & & me = me , & & mode = iMode , & & x = points ( iPoint ) ) end do end do end function ply_lagrange_1D ! ------------------------------------------------------------------------ ! end module ply_lagrange_module","tags":"","url":"sourcefile/ply_lagrange_module.f90.html"},{"title":"sdr_geometry_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_geometry_module.f90~~EfferentGraph sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_canonicalnd_module.f90 sdr_canonicalND_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_canonicalnd_module.f90 sourcefile~sdr_cylinder_module.f90 sdr_cylinder_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_cylinder_module.f90 sourcefile~sdr_ellipsoid_module.f90 sdr_ellipsoid_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_ellipsoid_module.f90 sourcefile~sdr_sphere_module.f90 sdr_sphere_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_sphere_module.f90 sourcefile~sdr_stl_module.f90 sdr_stl_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_stl_module.f90 sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_geometry_module.f90~~AfferentGraph sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2015, 2017 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2015, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012, 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> This module provides the description of the complete geometry to mesh. module sdr_geometry_module use env_module , only : rk , labelLen use tem_aux_module , only : tem_abort use tem_tools_module , only : upper_to_lower , tem_horizontalSpacer use tem_logging_module , only : logunit use tem_dyn_array_module , only : dyn_labelArray_type , PositionOfVal use tem_grow_array_module , only : grw_intArray_type use tem_cube_module , only : tem_cube_type , tem_load_cube use tem_triangle_module , only : grw_triangleArray_type , init , truncate , & & tem_triangleCubeOverlap , & & tem_load_triangle use tem_point_module , only : grw_pointArray_type , init , truncate , & & tem_pointCubeOverlap use tem_line_module , only : grw_lineArray_type , init , truncate , & & tem_lineCubeOverlap use tem_box_module , only : grw_boxArray_type , init , truncate , & & tem_boxCubeOverlap use tem_sphere_module , only : tem_load_sphere , tem_sphereCubeOverlap , & & grw_sphereArray_type , init , truncate , & & append , tem_sphere_type use tem_ellipsoid_module , only : tem_load_ellipsoid , & & tem_ellipsoidCubeOverlap , & & grw_ellipsoidArray_type , init , truncate ,& & append , tem_ellipsoid_type use tem_cylinder_module , only : tem_load_cylinder , & & tem_cylinderCubeOverlap , & & grw_cylinderArray_type , init , truncate use tem_stl_module , only : tem_load_stl use tem_transformation_module , only : tem_transformation_type , & & tem_load_transformation use sdr_spatialObj_module , only : grw_spatialObjArray_type , & & sdr_spatialObj_type , & & point , line , triangle , box , sphere , ellipsoid ,& & spacerInterwoven , periodicPlane , & & cylinder , init , append , truncate use sdr_periodic_module , only : grw_periPlaneArray_type , & & init , truncate , & & sdr_load_periodic , & & sdr_periodicPlaneCubeOverlap use sdr_attribute_module , only : sdr_load_attribute , sdr_init_attribute , & & sdr_attrList_type , init , truncate , & & append , sdr_attribute_type , & & sdr_Refinement_object , & & sdr_Boundary_object , & & sdr_Seed_object , & & sdr_identify_bc_colors , & & sdr_identify_inv_colors , & & sdr_isPeriodicDefined use sdr_spacer_module , only : sdr_load_spacer , & & sdr_spacerInterwovenCubeOverlap , & & grw_spacerInterwovenArray_type , & & init , truncate use sdr_canonicalND_module , only : sdr_load_canonicalND use sdr_triangle_module , only : sdr_load_triangle use sdr_stl_module , only : sdr_load_stl use sdr_sphere_module , only : sdr_load_sphere use sdr_ellipsoid_module , only : sdr_load_ellipsoid use sdr_cylinder_module , only : sdr_load_cylinder use flu_binding , only : flu_State use aotus_module , only : aot_get_val , flu_State , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length , aot_table_top , & & aot_table_first implicit none public :: sdr_geometry_type public :: sdr_load_geometry public :: is_intersecting public :: sdr_append_distanceRefineObject !> Geometric description of the space to mesh. type sdr_geometry_type !> The universe given as a bounding cube. type ( tem_cube_type ) :: universe !> growing array of all points type ( grw_pointArray_type ) :: point !> growing array of all lines type ( grw_lineArray_type ) :: line !> growing array of all triangles type ( grw_triangleArray_type ) :: triangle !> growing array of all boxes type ( grw_boxArray_type ) :: box !> growing array of periodic plane objects type ( grw_periPlaneArray_type ) :: periPlane !> growing array of spheres type ( grw_sphereArray_type ) :: sphere !> growing array of spheres type ( grw_ellipsoidArray_type ) :: ellipsoid !> growing array of cylinders type ( grw_cylinderArray_type ) :: cylinder !> growing array of spacer type ( grw_spacerInterwovenArray_type ) :: spacerInterwoven !> Growing array of geometrical objects. type ( grw_spatialObjArray_type ) :: spatialObj !> Dynamic Unique array of attributes connected to the objects !! (seed, boundary or refinement) type ( sdr_attrList_type ) :: attribute !> Smooth refinement towards boundaries. logical :: smoothbounds = . true . !> Smooth level jumps, avoid level jump > 1 in domain logical :: smoothLevels = . true . !> Number of user defined spatial objects !! i.e excluding spatial objects created for distance refine integer :: nUserObjs end type sdr_geometry_type contains !> Test the intersection between the given cube and the object specified by !! obj_pos. !! !! This test obviously depends on the kind of object to intersect, thus a !! select case has to be used. Alternatively we might think of deploying !! function pointers. function is_intersecting ( cube , geometry , obj_pos ) result ( intersects ) ! --------------------------------------------------------------------------! type ( tem_cube_type ), intent ( in ) :: cube type ( sdr_geometry_type ), intent ( in ) :: geometry integer , intent ( in ) :: obj_pos logical :: intersects ! --------------------------------------------------------------------------! integer :: prim_pos integer :: prim_kind ! --------------------------------------------------------------------------! intersects = . false . prim_pos = geometry % spatialObj % val ( obj_pos )% primitive_position prim_kind = geometry % spatialObj % val ( obj_pos )% geometry_primitive select case ( prim_kind ) case ( point ) intersects = tem_pointCubeOverlap ( geometry % point % val ( prim_pos ), cube ) case ( line ) intersects = tem_lineCubeOverlap ( geometry % line % val ( prim_pos ), cube ) case ( triangle ) intersects = tem_triangleCubeOverlap ( geometry % triangle % val ( prim_pos ), & & cube ) case ( box ) intersects = tem_boxCubeOverlap ( geometry % box % val ( prim_pos ), cube ) case ( sphere ) intersects = tem_sphereCubeOverlap ( geometry % sphere % val ( prim_pos ), cube ) case ( ellipsoid ) intersects = tem_ellipsoidCubeOverlap ( geometry % ellipsoid % val ( prim_pos ), & & cube ) case ( cylinder ) intersects = tem_cylinderCubeOverlap ( geometry % cylinder % val ( prim_pos ), & & cube ) case ( spacerInterwoven ) intersects = sdr_spacerInterwovenCubeOverlap ( & & geometry % spacerInterwoven % val ( prim_pos ), cube ) case ( periodicPlane ) intersects = sdr_periodicPlaneCubeOverlap (& & geometry % periPlane % val ( prim_pos ), cube ) case default write ( logunit ( 1 ), * ) 'WARNING: Unknown primitive geometry ignored' end select end function is_intersecting ! ***************************************************************************** !> Routine to load spatial object defined in config file and store in !! geometry type subroutine sdr_load_geometry ( me , subres_colors , invert_colors , conf ) ! --------------------------------------------------------------------------! !> contains all geometry infomation type ( sdr_geometry_type ), intent ( out ) :: me !> All the colors, which should be default use subelement resolution for !! their boundaries. type ( dyn_labelArray_type ), intent ( in ) :: subres_colors type ( dyn_labelArray_type ), intent ( in ) :: invert_colors type ( flu_State ) :: conf !< lua state ! --------------------------------------------------------------------------! integer :: spa_handle , spa_subHandle integer :: spa_length , iSpaObj integer :: iColor , nColors integer :: iBnd , nBounds integer :: iError ! --------------------------------------------------------------------------! ! Read the bounding cube definition from the config file. write ( logunit ( 1 ), * ) 'Loading bounding cube:' call tem_load_cube ( me = me % universe , conf = conf , key = 'bounding_cube' ) ! Smoothbounds sets, whether refinement towards boundaries should be ! somewhat smoothed or not. call aot_get_val ( L = conf , key = 'smoothbounds' , & & val = me % smoothbounds , ErrCode = iError , default = . true .) if ( me % smoothbounds ) then write ( logunit ( 1 ), * ) 'Smoothed refinement towards boundaries.' else write ( logunit ( 1 ), * ) '*** NO Smoothed refinement towards boundaries. ***' end if ! Smoothlevels sets, whether to allow level jump > 1 in domain call aot_get_val ( L = conf , key = 'smoothlevels' , & & val = me % smoothLevels , ErrCode = iError , default = . true .) if ( me % smoothLevels ) then write ( logunit ( 1 ), * ) 'Smoothed levels with level jump = 1.' else write ( logunit ( 1 ), * ) '*** NO Smoothed levels. ***' end if ! Intialize growing array of geom object. call init ( me % spatialObj ) ! Intialize growing arrays of geometric primitives. call init ( me % point , length = 8 ) call init ( me % line , length = 8 ) call init ( me % triangle , length = 128 ) call init ( me % sphere , length = 8 ) call init ( me % ellipsoid , length = 8 ) call init ( me % cylinder , length = 8 ) call init ( me % spacerInterwoven , length = 8 ) call init ( me % periPlane , length = 8 ) call init ( me % box , length = 8 ) ! Initialize dynamic array of attributes. call sdr_init_attribute ( me % attribute ) ! Load spatial objects. call aot_table_open ( L = conf , thandle = spa_handle , key = 'spatial_object' ) ! Load spatial sub handle to check between single table or multiple table call aot_table_open ( L = conf , parent = spa_handle , & & thandle = spa_subhandle , pos = 1 ) if ( spa_handle . gt . 0 ) then ! Spatial Object definition exists in the configuration and is a table. if ( spa_subHandle . eq . 0 ) then ! There is no second table within the opened spatial object table at the ! first position. Interpret the parent table as a single spatial object. call aot_table_close ( L = conf , thandle = spa_subHandle ) call sdr_load_spatialObject_single ( me = me , conf = conf , & & subres_colors = subres_colors , & & thandle = spa_handle ) else ! The first entry in the spatial object table is a table in itself, try ! to interpret all entries as object definitions and read multiple ! objects from the spatial object table. call aot_table_close ( L = conf , thandle = spa_subHandle ) spa_length = aot_table_length ( L = conf , thandle = spa_handle ) do iSpaObj = 1 , spa_length call aot_table_open ( L = conf , parent = spa_handle , & & thandle = spa_subhandle , pos = iSpaObj ) call sdr_load_spatialObject_single ( me = me , conf = conf , & & subres_colors = subres_colors , & & thandle = spa_subhandle ) call aot_table_close ( L = conf , thandle = spa_subHandle ) end do endif else write ( logunit ( 1 ), * ) 'WARNING: No geometrical objects are defined!' end if call aot_table_close ( L = conf , thandle = spa_handle ) ! Look up bc colors in the list of seed colors to match them correctly ! during flooding. call sdr_identify_bc_colors ( me % attribute ) ! Look up colors that are to be inverted and flag them accordingly. call sdr_identify_inv_colors ( me % attribute , invert_colors ) ! Truncate all arrays, to free unused memory. call truncate ( me % spatialObj ) call truncate ( me % attribute % dynArray ) call truncate ( me % point ) call truncate ( me % line ) call truncate ( me % triangle ) call truncate ( me % sphere ) call truncate ( me % ellipsoid ) call truncate ( me % cylinder ) call truncate ( me % spacerInterwoven ) call truncate ( me % periPlane ) call truncate ( me % box ) ! Number of user defined spatial objects to exclude spatial objects ! defined by distance refine me % nUserObjs = me % spatialObj % nVals write ( logunit ( 1 ), * ) '' write ( logunit ( 1 ), \"(A,I0)\" ) 'Total number of spatial objs created:' , & & me % nUserObjs write ( logunit ( 1 ), \"(A,I0)\" ) 'Total number of boundaries defined:' , & & me % attribute % kindpos ( sdr_Boundary_object )% nVals nBounds = me % attribute % uni_name ( sdr_Boundary_object )% nVals if ( nBounds > 0 ) then write ( logunit ( 1 ), \"(A,I0,A)\" ) 'There are ' , nBounds , & & ' unique boundaries defined:' do iBnd = 1 , nBounds write ( logunit ( 1 ), '(A)' ) ' * ' // trim ( me % attribute & & % uni_name ( sdr_Boundary_object ) & & % val ( iBnd ) ) end do end if write ( logunit ( 1 ), * ) '' nColors = me % attribute % uni_name ( sdr_seed_object )% nVals if ( nColors > 1 ) then write ( logunit ( 1 ), '(a,i0,a)' ) 'There are ' , nColors , & & ' colors in this mesh:' do iColor = 1 , nColors if ( me % attribute % color_inverted ( iColor )) then write ( logunit ( 1 ), * ) trim ( me % attribute % uni_name ( sdr_seed_object ) & & % val ( iColor )) & & // ' (inverted)' else write ( logunit ( 1 ), * ) trim ( me % attribute % uni_name ( sdr_seed_object ) & & % val ( iColor )) end if end do else write ( logunit ( 1 ), * ) 'This is a single color mesh.' end if write ( logunit ( 1 ), * ) '' end subroutine sdr_load_geometry ! ***************************************************************************** ! ***************************************************************************** !> Routine to load single spatial object table defined in config file subroutine sdr_load_spatialObject_single ( me , subres_colors , conf , thandle ) ! --------------------------------------------------------------------------! !> contains all geometry infomation type ( sdr_geometry_type ), intent ( inout ) :: me !> All the colors, which should be default use subelement resolution for !! their boundaries. type ( dyn_labelArray_type ), intent ( in ) :: subres_colors type ( flu_State ) :: conf !< lua state integer , intent ( in ) :: thandle !< handle for spatialObject ! --------------------------------------------------------------------------! integer :: attr_pos type ( tem_transformation_type ) :: transform ! --------------------------------------------------------------------------! call tem_horizontalSpacer ( funit = logunit ( 1 )) ! Load the attribute of the object and append it to the list. call sdr_load_attribute ( attrList = me % attribute , conf = conf , & & subres_colors = subres_colors , & & thandle = thandle , attr_pos = attr_pos ) ! load transformation table if defined and pass the transformation ! to geom table to apply the transformation to geometry object call tem_load_transformation ( transform = transform , conf = conf , & & thandle = thandle ) ! Load the geometry definition of the spatial object (and connect its ! primitives to the current attribute). call sdr_load_geom_table ( me = me , conf = conf , thandle = thandle , & & attr_pos = attr_pos , transform = transform ) end subroutine sdr_load_spatialObject_single ! ***************************************************************************** ! ***************************************************************************** !> This routine loads the geometry table from the config file i.e loading !! different geometry kinds like canoND, cube, periodic, STL etc. subroutine sdr_load_geom_table ( me , conf , thandle , attr_pos , transform ) ! --------------------------------------------------------------------------! type ( sdr_geometry_type ), intent ( inout ) :: me type ( flu_State ) :: conf !< lua state integer , intent ( in ) :: thandle !< handle for spatialObject !> Position of the attribute to connect the geometric objects to. integer , intent ( in ) :: attr_pos type ( tem_transformation_type ), intent ( in ) :: transform ! --------------------------------------------------------------------------! integer :: geom_handle , geom_subHandle integer :: nTables , iTab ! --------------------------------------------------------------------------! write ( logunit ( 1 ), * ) 'Loading geometry ' ! Open the geometry table. call aot_table_open ( L = conf , parent = thandle , thandle = geom_handle , & & key = 'geometry' ) ! Try to open a sub table of the geometry. call aot_table_open ( L = conf , parent = geom_handle , & & thandle = geom_subhandle , pos = 1 ) if ( geom_handle . gt . 0 ) then ! Geometry table is defined if ( geom_subhandle . eq . 0 ) then ! It is propably just a single entry, as the first entry is not a table ! in itself. call aot_table_close ( L = conf , thandle = geom_subhandle ) call sdr_load_geom_table_single ( me = me , conf = conf , & & thandle = geom_handle , & & attr_pos = attr_pos , & & transform = transform ) else ! Geometry table contains propably multiple geometry definitions. call aot_table_close ( L = conf , thandle = geom_subhandle ) nTables = aot_table_length ( L = conf , thandle = geom_handle ) do iTab = 1 , nTables call aot_table_open ( L = conf , parent = geom_handle , & & thandle = geom_subhandle , pos = iTab ) call sdr_load_geom_table_single ( me = me , conf = conf , & & thandle = geom_subhandle , & & attr_pos = attr_pos , & & transform = transform ) call aot_table_close ( L = conf , thandle = geom_subhandle ) end do end if else write ( logunit ( 0 ), * ) 'ERROR loading geometry for spatial object: ' write ( logunit ( 0 ), * ) '      NO geometry table defined!' call tem_abort () end if call aot_table_close ( L = conf , thandle = geom_handle ) end subroutine sdr_load_geom_table ! ***************************************************************************** ! ***************************************************************************** !> This routine reads a single geometry table from the config file i.e !! loading different geometry kinds like canoND, cube, periodic, STL etc. subroutine sdr_load_geom_table_single ( me , conf , thandle , attr_pos , transform ) ! --------------------------------------------------------------------------! type ( sdr_geometry_type ), intent ( inout ) :: me type ( flu_State ) :: conf !< lua state integer , intent ( in ) :: thandle !< handle for spatialObject !> Position of the attribute to connect all primitives to. integer , intent ( in ) :: attr_pos type ( tem_transformation_type ), intent ( in ) :: transform ! --------------------------------------------------------------------------! integer :: iError character ( len = labelLen ) :: geom_kind ! --------------------------------------------------------------------------! ! Get the kind of the geometry to read. call aot_get_val ( L = conf , thandle = thandle , key = 'kind' , & & val = geom_kind , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logunit ( 0 ), * ) 'FATAL Error occured, while retrieving geometry kind:' if ( btest ( iError , aoterr_NonExistent )) & & write ( logunit ( 0 ), * ) 'Geometry kind not defined!' if ( btest ( iError , aoterr_WrongType )) & & write ( logunit ( 0 ), * ) 'Geometry kind has wrong type!' call tem_abort () end if select case ( upper_to_lower ( trim ( geom_kind ))) case ( 'canond' , 'canonicalnd' ) call sdr_load_canonicalND ( pntArray = me % point , & & lineArray = me % line , & & triArray = me % triangle , & & boxArray = me % box , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , thandle = thandle ) case ( 'triangle' ) call sdr_load_triangle ( triArray = me % triangle , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , & & thandle = thandle ) case ( 'stl' ) call sdr_load_stl ( triArray = me % triangle , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , & & thandle = thandle ) case ( 'sphere' ) call sdr_load_sphere ( sphArray = me % sphere , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , & & thandle = thandle ) case ( 'ellipsoid' ) call sdr_load_ellipsoid ( sphArray = me % ellipsoid , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , & & thandle = thandle ) case ( 'cylinder' ) call sdr_load_cylinder ( cylArray = me % cylinder , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , & & thandle = thandle ) case ( 'spacer' ) call sdr_load_spacer ( sprInterwovenArray = me % spacerInterwoven , & & cylArray = me % cylinder , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , & & thandle = thandle ) case ( 'periodic' ) call sdr_load_periodic ( periArray = me % periPlane , & & spaObjArray = me % spatialObj , & & attr_pos = attr_pos , & & transform = transform , & & conf = conf , & & thandle = thandle ) case default write ( logunit ( 0 ), * ) 'ERROR: Unknown geometry kind: ' // trim ( geom_kind ) call tem_abort () end select end subroutine sdr_load_geom_table_single ! ***************************************************************************** ! **************************************************************************** !> This routine created sphere objects and new attribute and extend !! a list of spatial objects if node intersected boundary has distance !! refine. subroutine sdr_append_distanceRefineObject ( coord , dx , iLevel , geometry , & & intersected_first , intersected_last , intersected_object ) ! --------------------------------------------------------------------------! !> Coordinate of current node integer , intent ( in ) :: coord ( 4 ) real ( kind = rk ), intent ( in ) :: dx !< size of the element !> Current node level integer , intent ( in ) :: iLevel !> type which contains all geometry object infos type ( sdr_geometry_type ), intent ( inout ) :: geometry !> This node's first position in intersected_object integer , intent ( in ) :: intersected_first !> This node's last position in intersected_object integer , intent ( in ) :: intersected_last !> Growing array of intersected_objects type ( grw_intArray_type ), intent ( in ) :: intersected_object ! --------------------------------------------------------------------------! type ( tem_sphere_type ) :: loc_sphere type ( sdr_spatialObj_type ) :: spatialObj type ( sdr_attribute_type ) :: attribute integer :: iDistRefine , iObject integer :: distRef_first , distRef_last integer :: obj_pos , attr_pos , uni_pos logical :: wasAdded logical :: attrChecked ( geometry % attribute % dynArray % nVals ) ! --------------------------------------------------------------------------! attrChecked = . false . ! Set origin of sphere, barcenter of current node loc_sphere % origin = geometry % universe % origin & & + ( real ( coord ( 1 : 3 ), kind = rk ) + 0.5_rk ) * dx loc_sphere % only_surface = . false . ! Set attribute kind to refinement and label to distance attribute % kind = sdr_Refinement_object attribute % label = 'distance_refine' do iObject = intersected_first , intersected_last obj_pos = intersected_object % val ( iObject ) attr_pos = geometry % spatialObj % val ( obj_pos )% attribute_position ! if attribute contains distance function and this attribute is ! not checked before if ( geometry % attribute % dynArray % val ( attr_pos )% distRefine_id > 0 & . and . . not . attrChecked ( attr_pos ) ) then attrChecked ( attr_pos ) = . true . distRef_first = geometry % attribute % dynArray % val ( attr_pos )% distance_first distRef_last = geometry % attribute % dynArray % val ( attr_pos )% distance_last do iDistRefine = distRef_first , distRef_last ! set sphere radius loc_sphere % radius = geometry % attribute % distRefine & & % val ( iDistRefine )% radius ! set attribute level attribute % level = geometry % attribute % distRefine & & % val ( iDistRefine )% reach_level ! Create distance refine object only if reach_level>0 ! and same as current level to reduce number of spatial objects if ( attribute % level > 0 . and . attribute % level == iLevel ) then ! append attribute to dynamic array of attribute call append ( geometry % attribute % dynArray , attribute , & & pos = attr_pos , & & wasAdded = wasAdded ) if ( wasAdded ) then ! Update the counters for refinement kind of object. call append ( geometry % attribute % kindPos ( attribute % kind ), attr_pos ) geometry % attribute % dynArray % val ( attr_pos )% id & & = geometry % attribute % kindPos ( attribute % kind )% nVals call append ( geometry % attribute % uni_name ( attribute % kind ), & & val = attribute % label , & pos = uni_pos ) geometry % attribute % dynArray % val ( attr_pos )% uni_id = uni_pos end if ! append sphere to sphereObject call append ( geometry % sphere , loc_sphere ) ! append spatial object spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = sphere spatialObj % primitive_position = geometry % sphere % nVals call append ( geometry % spatialObj , spatialObj ) end if end do end if end do end subroutine sdr_append_distanceRefineObject ! **************************************************************************** end module sdr_geometry_module","tags":"","url":"sourcefile/sdr_geometry_module.f90.html"},{"title":"ply_nodeset_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~ply_nodeset_module.f90~~AfferentGraph sourcefile~ply_nodeset_module.f90 ply_nodeset_module.f90 sourcefile~ply_l2p_module.f90 ply_l2p_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_nodeset_module.f90 sourcefile~ply_lagrange_module.f90 ply_lagrange_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_lagrange_module.f90 sourcefile~ply_lagrange_module.f90->sourcefile~ply_nodeset_module.f90 sourcefile~ply_nodes_module.f90 ply_nodes_module.f90 sourcefile~ply_nodes_module.f90->sourcefile~ply_nodeset_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! ! !> Collection of node sets to use in the nodal representation of the solution. !! !! Node distributions on the reference interval [-1,1] are to be described by !! functions that satisfy the [[ply_nodeset_coords]] interface and return an !! array of 1D coordinates for the given number of points. !! !! The following sets of nodes are available: !! !! * [[ply_nodeset_legendre]] the nodes of the Gauss-Legendre integration !! * [[ply_nodeset_chebyshev]] the nodes of the Chebyshev integration !! * [[ply_nodeset_chebyloba]] the nodes of the Chebyshev-Lobatto integration !!   (includes the interval boundaries) module ply_nodeset_module use env_module , only : rk use tem_param_module , only : PI implicit none private interface function ply_nodeset_coords ( nPoints ) result ( x ) use env_module , only : rk !> The number of points to create. integer , intent ( in ) :: nPoints !> The coordinates of the nodeset in the interval [-1,1]. !! The array has to have the length nPoints. real ( kind = rk ) :: x ( nPoints ) end function ply_nodeset_coords end interface public :: ply_nodeset_coords public :: ply_nodeset_legendre public :: ply_nodeset_chebyshev public :: ply_nodeset_chebyloba contains ! ------------------------------------------------------------------------ ! !> Compute Gauss-Legendre integration points on the interval [-1,1]. function ply_nodeset_legendre ( nPoints ) result ( x ) ! -------------------------------------------------------------------- ! !> The number of integration points. integer , intent ( in ) :: nPoints !> The coordinates of the Legendre points on the interval [-1,1]. !! The array has to have the length nPoints. real ( kind = rk ) :: x ( nPoints ) ! -------------------------------------------------------------------- ! ! some working variables real ( kind = rk ) :: z1 , z , pp , p3 , p2 , p1 ! Precision to find roots and stop Newton iterations. real ( kind = rk ) :: EPS integer :: m , i , j ! -------------------------------------------------------------------- ! EPS = epsilon ( z ) * 16 m = nPoints / 2 ! Set all symmetric points (center is done seperately for odd nPoints) PointLoop : do i = 1 , m z = cos ( PI * (( i - 1 ) + 0.75_rk ) / ( nPoints + 0.5_rk )) NewtonLoop : do p1 = 1.0_rk p2 = 0.0_rk PolyEval : do j = 0 , nPoints - 1 p3 = p2 p2 = p1 p1 = ( real ( 2 * j + 1 , kind = rk ) * z * p2 - j * p3 ) / real ( j + 1 , kind = rk ) end do PolyEval pp = nPoints * ( z * p1 - p2 ) / ( z * z - 1.0_rk ) z1 = z z = z1 - p1 / pp if ( abs ( z - z1 ) < EPS ) EXIT NewtonLoop end do NewtonLoop x ( i ) = - z x ( nPoints - i + 1 ) = z end do PointLoop ! For odd number of points the center is an integration point. if ( mod ( nPoints , 2 ) > 0 ) then i = ( nPoints + 1 ) / 2 x ( i ) = 0.0_rk end if end function ply_nodeset_legendre ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Generates a given number of Chebyshev points on the unit interval [-1;+1]. function ply_nodeset_chebyshev ( nPoints ) result ( x ) ! -------------------------------------------------------------------- ! !> The number of points to generate integer , intent ( in ) :: nPoints !> The coordinates of the Chebyshev points on the interval [-1,1]. !! The array has to have the length nPoints. real ( kind = rk ) :: x ( nPoints ) ! -------------------------------------------------------------------- ! integer :: iPoint integer :: iBack integer :: nHalf ! -------------------------------------------------------------------- ! nHalf = nPoints / 2 ! Set the middle point for odd number of points. ! Will be overwritten for even number of points. x ( nHalf + 1 ) = 0.0_rk do iPoint = 1 , nHalf iBack = nPoints - iPoint + 1 x ( iBack ) = cos ( PI / nPoints * ( ( iPoint - 1 ) + 0.5_rk ) ) x ( iPoint ) = - x ( iBack ) end do end function ply_nodeset_chebyshev ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Generates a given number of Chebyshev-Lobatto points on the unit interval !! [-1;+1]. function ply_nodeset_chebyloba ( nPoints ) result ( x ) ! -------------------------------------------------------------------- ! !> The number of points to generate integer , intent ( in ) :: nPoints !> The coordinates of the Chebyshev-Lobatto points on the interval [-1,1]. !! The array has to have the length nPoints. real ( kind = rk ) :: x ( nPoints ) ! -------------------------------------------------------------------- ! integer :: iPoint integer :: iBack integer :: nHalf ! -------------------------------------------------------------------- ! nHalf = nPoints / 2 ! Set the middle point for odd number of points. ! Will be overwritten for even number of points. x ( nHalf + 1 ) = 0.0_rk ! Both interval limits can be set directly and don't have to be ! computed. x ( 1 ) = 1.0_rk x ( nPoints ) = - 1.0_rk do iPoint = 2 , nHalf iBack = nPoints - iPoint + 1 x ( iPoint ) = cos ( ( iPoint - 1 ) * PI / real ( nPoints - 1 , kind = rk ) ) x ( iBack ) = - x ( iPoint ) end do end function ply_nodeset_chebyloba ! ------------------------------------------------------------------------ ! end module ply_nodeset_module","tags":"","url":"sourcefile/ply_nodeset_module.f90.html"},{"title":"sdr_triangle_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_triangle_module.f90~~AfferentGraph sourcefile~sdr_triangle_module.f90 sdr_triangle_module.f90 sourcefile~sdr_geometry_module.f90 sdr_geometry_module.f90 sourcefile~sdr_geometry_module.f90->sourcefile~sdr_triangle_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_geometry_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_geometry_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2014, 2017 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012 Sathish Krishnan P S <s.krishnan@grs-sim.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> \\brief This module is an adapter to tem_triangle_module, Contains !! a routine to load triangle and added it to list of spatial objects module sdr_triangle_module use tem_logging_module , only : logunit use tem_transformation_module , only : tem_transformation_type use tem_triangle_module , only : tem_triangle_type , & & grw_triangleArray_type , & & tem_load_triangle , append use aotus_module , only : flu_State use sdr_spatialObj_module , only : grw_spatialObjArray_type , & & sdr_spatialObj_type , append , & & triangle implicit none private public :: sdr_load_triangle contains ! **************************************************************************** !> Load triangle information from config file. subroutine sdr_load_triangle ( triArray , spaObjArray , attr_pos , transform , & & conf , thandle ) !--------------------------------------------------------------------------! !inferface variables !> growing array of triangles type ( grw_triangleArray_type ), intent ( inout ) :: triArray !> growing array of geometrical objects. type ( grw_spatialObjArray_type ), intent ( inout ) :: spaObjArray !> Position of the attribute to connect this object to. integer , intent ( in ) :: attr_pos !> transformation for spatial object type ( tem_transformation_type ), intent ( in ) :: transform !> lua state type ( flu_state ) :: conf integer , intent ( in ) :: thandle !< handle for canonical objects !--------------------------------------------------------------------------! ! local varaibles type ( tem_triangle_type ), allocatable :: loc_triangle (:) type ( sdr_spatialObj_type ) :: spatialObj integer :: iTri !--------------------------------------------------------------------------! call tem_load_triangle ( me = loc_triangle , & & transform = transform , & & conf = conf , & & thandle = thandle ) !append triangle to triangle array spatialObj % attribute_position = attr_pos spatialObj % geometry_primitive = triangle do iTri = 1 , size ( loc_triangle ) call append ( triArray , loc_triangle ( iTri ) ) spatialObj % primitive_position = triArray % nVals !add spatialObj to spatialObj list call append ( spaObjArray , spatialObj ) end do end subroutine sdr_load_triangle ! **************************************************************************** end module sdr_triangle_module","tags":"","url":"sourcefile/sdr_triangle_module.f90.html"},{"title":"ply_split_element_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_split_element_module.f90~~EfferentGraph sourcefile~ply_split_element_module.f90 ply_split_element_module.f90 sourcefile~ply_split_legendre_module.f90 ply_split_legendre_module.f90 sourcefile~ply_split_element_module.f90->sourcefile~ply_split_legendre_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ply_split_element_module.f90~~AfferentGraph sourcefile~ply_split_element_module.f90 ply_split_element_module.f90 sourcefile~ply_sampling_adaptive_module.f90 ply_sampling_adaptive_module.f90 sourcefile~ply_sampling_adaptive_module.f90->sourcefile~ply_split_element_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2017, 2019 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> This module provides the methods to project the polynomial representation in !! elements onto the representations in their halves in each dimension. !! !! To perform the projection for Legendre polynomials we will use the computed !! coefficients for the Clenshaw algorithm from [[ply_split_legendre_module]]. !! With those the transformation is just a simple triangular matrix !! multiplication, but we need to take care of the orthogonal degrees of freedom !! as we want to handle all of them at the same time. !! Further we want to allow the transformation to be performed for multiple !! elements at once. !! !! In each dimension we need to perform the following coordinate transformation: !! !!  x = 0.5 \\cdot \\xi_{left} - 0.5  !!  x = 0.5 \\cdot \\xi_{right} + 0.5  !! !! Where x refers to the coordinate in the original (coarse) element, and !! \\xi to the coordinates in the two (left and right) halves of the element. module ply_split_element_module use env_module , only : rk use ply_split_legendre_module , only : ply_split_legendre_matrix use ply_modg_basis_module , only : ply_legendre_1d implicit none private public :: ply_split_element_singleD public :: ply_split_element public :: ply_split_element_1D public :: ply_split_element_2D public :: ply_split_element_3D public :: ply_split_element_init public :: ply_split_element_test abstract interface !> Split elements of degree parent_degree into elements with polynomials of !! degree child_degree. subroutine ply_split_element ( parent_degree , child_degree , parent_data , & & child_data , ignore_highmodes ) ! -------------------------------------------------------------------- ! import :: rk !> Polynomial degree in the parent element. integer , intent ( in ) :: parent_degree !> Polynomial degree in the child elements. integer , intent ( in ) :: child_degree !> Polynomial data in the parent element. The first index describes the !! degrees of freedom. The second index refers to the elements to split. real ( kind = rk ), intent ( in ) :: parent_data (:,:) !> Polynomial data in the child elements. The first index describes the !! degrees of freedom. The second index refers to the elements, there !! needs to be four times as many elements than in the parent_data. !! !! Elements follow the ordering of the Z space filling curve. real ( kind = rk ), intent ( out ) :: child_data (:,:) !> Whether to ignore high modes from the parent element. !! !! This can be used as a simple lowpass filter by ignoring all higher !! modes from the parent element, that exceed the target polynomial !! degree. Thus, the polynomials are filtered before projection, !! instead of cutting them only of after refinement. !! Defaults to false (no filtering). logical , optional , intent ( in ) :: ignore_highmodes ! -------------------------------------------------------------------- ! end subroutine ply_split_element end interface !> Precomputed matrix to hold the transformation operation to project !! Legendre polynomials to its two half intervals. !! !! This is computed by [[ply_split_legendre_matrix]], see there for details. !! There are two triangular matrices stored in this array, one for the !! projection to the left half (-1,0) , and one for the projection to the !! right half (0,1). !! !! This is a module variable, as it is only needed to be computed once with !! sufficient size. All lower orders are just subarrays out of the larger one. real ( kind = rk ), allocatable :: split_legendre (:,:) contains ! ------------------------------------------------------------------------ ! !> Initialization of the module. !! This needs to be performed before any call of the actual transformation !! [[ply_split_element_1D]]. !! !! The initialization will compute the transformation matrix for Legendre !! polynomials with at least nMaxModes. If the initialization was already !! called before with the same or larger nMaxModes, the matrix will not be !! changed. Thus, calling this routine will only increase the size of the !! module variable split_legendre, never decrease it. subroutine ply_split_element_init ( nMaxModes ) ! -------------------------------------------------------------------- ! !> Maximal number of expected modes to perform the splitting for. integer , intent ( in ) :: nMaxModes ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! if ( allocated ( split_legendre )) then if ( size ( split_legendre , 1 ) < nMaxModes ) deallocate ( split_legendre ) end if if (. not . allocated ( split_legendre )) then allocate ( split_legendre ( nMaxModes , nMaxModes )) split_legendre = ply_split_legendre_matrix ( nMaxModes ) end if end subroutine ply_split_element_init ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Project a polynomial representation in elements in one dimension to its !! two halves in that direction. !! !! For each parent element the projection on the two respective child elements !! (half intervals) are computed for one dimension. !! !>@note Preliminary data layout and interface planning. !! It might be that we should rather split the index into the direction !! in which we perform the operation and all the other directions normal !! to that. For a dense matrix this may allow the compiler to detect !! the matrix multiply. However, here for the triangular matrix it is not !! so sure, whether this would be possible. !!@endnote !! !>@note After discussions with Stephan Walter, it looks like the separate !! indices would most likely be better. !! Maybe, using explicit shaped arrays and therby allowing more dimensions !! in the input, while keeping the interface to two dimensions for all !! cases (the normal direction and all independent degrees of freedom). !! For vectorization on x86 it also is necessary to have a stride-1 access !! only in reading and writing. !! The rotation of data might not be the best option because of this. !! Instead, it may be that we need to have different routines for each !! direction. !! Or, maybe, we need to use the elements as first index and vectorize !! over those. !!@endnote !! !! As we need to perform this operation in all dimensions, it would be good !! to shift the indices around. When doing this, we can stick to the same !! implementation for all directions, without the need to put any logic in !! here to decide on the current direction. !! In 3D we would end up with this chain: !! (x,y,z) -> split_element for Z -> (z,x,y) !!         -> split_element for Y -> (y,z,x) !!         -> split_element for X -> (x,y,z) !! Thus, the logic is that we perform the split on the last dimension, and !! cycle the indices in the output. !! !! We can generalize this to arbitrary dimensions. !! In 2D it would look like this: !! (x,y) -> split_element for Y -> (y,x) !!       -> split_element for X -> (x,y) !! And in 1D, we just need to perform one transformation: !! (x) -> split_element for X -> (x) !! !! As we allow for a changed number of polynomial degrees in the input and !! output, we need to take care of different lengths for each direction. !! Thus, we need: the dimensionality, two 1D arrays with the length of this !! dimensionality to provide the number of degrees of freedom for each !! direction (once for the input, and once for the output). !! !! We need: nDofs in the direction where the transformation is to be done !!          and the nDofs for all normal directions. subroutine ply_split_element_singleD ( nDims , inLen , outLen , parent_data , & & child_data , ignore ) ! -------------------------------------------------------------------- ! !> Number of dimensions of the polynomial data. integer , intent ( in ) :: nDims !> Number degrees of freedom for each direction in parent_Data. !! !! The first index of parent_data needs to have a length equal to the !! product of all inLen components. !! The splitting operation will be done in the last dimension. integer , intent ( in ) :: inLen ( nDims ) !> Number degrees of freedom for each direction in child_Data. !! !! The first index of child_data needs to have a length equal to the !! product of all outLen components. !! The data will be cyclicly exchanged. Thus, the last dimension in !! parent_data corresponds to the first in one in child_data and all !! other components are shifted once to the right. integer , intent ( in ) :: outLen ( nDims ) !> Polynomial representation in the parent elements. !! !! The first index are the degrees of freedom in elements, the second index !! are the elements. !! In the first index the shape of data has to be in the form !! (inLen(1), inLen(2), ... , inLen(nDims)). !! The splitting operation is performed on the last dimension in that !! data. real ( kind = rk ), intent ( in ) :: parent_data (:,:) !> Whether to ignore high modes that exceed the target maximal polynomial !! degree. !! !! This can be used as a simple lowpass filter that cuts off the highest !! modes in the parent elements prior to mapping to child elements. logical , intent ( in ) :: ignore !> Computed projection of the polynomial representation in the child !! elements. !! !! Again, the first index refers to the degrees of freedom, while the !! second index are the elements. There need to be twice as many elements !! as in the parent_data. !! Left childs are stored in iChild = (iParent*2 - 1), and the right !! childs in iParent*2. !! !! In the first index the shape of the data has to be in the form !! (outLen(1), outLen(2), ... , outLen(nDims)), the data is rotated !! in comparison to parent_data and the splitted direction has to be !! the first one in child_data (while it was the last in parent_data), !! and all other dimensions are shifted by one to the right. real ( kind = rk ), intent ( out ) :: child_data (:,:) ! -------------------------------------------------------------------- ! integer :: iDir integer :: iParent , Lchild , Rchild integer :: parentMode , childMode integer :: maxrow integer :: maxcol integer :: indep integer :: nIndeps integer :: nParents integer :: parentpos , childpos ! -------------------------------------------------------------------- ! nParents = size ( parent_data , 2 ) ! Use split_legendre to compute the two child_data elements for each ! parent_data element. ! We store the left childs in iChild = (iParent*2 - 1), and the right ! childs in iParent*2. child_data = 0.0_rk ! The number of independent modes (in normal directions) is given ! by the product of the length in all directions, except the last one. nIndeps = 1 do iDir = 1 , nDims - 1 nIndeps = nIndeps * inLen ( iDir ) end do if ( ignore ) then maxcol = min ( outLen ( 1 ), inLen ( nDims )) else maxcol = inLen ( nDims ) end if oldmodes : do parentMode = 1 , maxcol ! Maximal number modes to compute, as this is a triangular matrix ! it is limited by the diagonal (parentMode). However, it may be ! that the target polynomial space in the output is smaller, in this ! case we cap the computations and no more than outLen(1) entries ! are to be computed. maxrow = min ( parentMode , outLen ( 1 )) elemloop : do iParent = 1 , nParents Rchild = iParent * 2 Lchild = Rchild - 1 newmodes : do childMode = 1 , maxrow do indep = 1 , nIndeps parentpos = indep + nIndeps * ( parentMode - 1 ) childpos = childmode + ( indep - 1 ) * outLen ( 1 ) child_data ( childpos , Lchild ) = child_data ( childpos , Lchild ) & & + split_legendre ( parentmode , & & childmode ) & & * parent_data ( parentpos , iParent ) child_data ( childpos , Rchild ) = child_data ( childpos , Rchild ) & & + split_legendre ( childmode , & & parentmode ) & & * parent_data ( parentpos , iParent ) end do end do newmodes end do elemloop end do oldmodes end subroutine ply_split_element_singleD ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Split one-dimensional elements of degree parent_degree into two elements !! with polynomials of degree child_degree. subroutine ply_split_element_1D ( parent_degree , child_degree , parent_data , & & child_data , ignore_highmodes ) ! -------------------------------------------------------------------- ! !> Polynomial degree in the parent element. integer , intent ( in ) :: parent_degree !> Polynomial degree in the child elements. integer , intent ( in ) :: child_degree !> Polynomial data in the parent element. The first index describes the !! degrees of freedom. The second index refers to the elements to split. real ( kind = rk ), intent ( in ) :: parent_data (:,:) !> Polynomial data in the child elements. The first index describes the !! degrees of freedom. The second index refers to the elements, there !! needs to be four times as many elements than in the parent_data. !! !! Elements follow the ordering of the Z space filling curve. real ( kind = rk ), intent ( out ) :: child_data (:,:) !> Whether to ignore high modes from the parent element. !! !! This can be used as a simple lowpass filter by ignoring all higher !! modes from the parent element, that exceed the target polynomial !! degree. Thus, the polynomials are filtered before projection, !! instead of cutting them only of after refinement. !! Defaults to false (no filtering). logical , optional , intent ( in ) :: ignore_highmodes ! -------------------------------------------------------------------- ! logical :: ignore integer :: pardofs integer :: childdofs ! -------------------------------------------------------------------- ! ignore = . false . if ( present ( ignore_highmodes )) then ignore = ignore_highmodes end if pardofs = parent_degree + 1 childdofs = child_degree + 1 call ply_split_element_singleD ( nDims = 1 , & & inLen = [ pardofs ], & & outLen = [ childdofs ], & & ignore = ignore , & & parent_data = parent_data , & & child_data = child_data ) end subroutine ply_split_element_1D ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Split two-dimensional elements of degree parent_degree into four elements !! with polynomials of degree child_degree. subroutine ply_split_element_2D ( parent_degree , child_degree , parent_data , & & child_data , ignore_highmodes ) ! -------------------------------------------------------------------- ! !> Polynomial degree in the parent element. integer , intent ( in ) :: parent_degree !> Polynomial degree in the child elements. integer , intent ( in ) :: child_degree !> Polynomial data in the parent element. The first index describes the !! degrees of freedom. The second index refers to the elements to split. real ( kind = rk ), intent ( in ) :: parent_data (:,:) !> Polynomial data in the child elements. The first index describes the !! degrees of freedom. The second index refers to the elements, there !! needs to be four times as many elements than in the parent_data. !! !! Elements follow the ordering of the Z space filling curve. real ( kind = rk ), intent ( out ) :: child_data (:,:) !> Whether to ignore high modes from the parent element. !! !! This can be used as a simple lowpass filter by ignoring all higher !! modes from the parent element, that exceed the target polynomial !! degree. Thus, the polynomials are filtered before projection, !! instead of cutting them only of after refinement. !! Defaults to false (no filtering). logical , optional , intent ( in ) :: ignore_highmodes ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: ysplit (:,:) logical :: ignore integer :: pardofs integer :: childdofs ! -------------------------------------------------------------------- ! ignore = . false . if ( present ( ignore_highmodes )) then ignore = ignore_highmodes end if pardofs = parent_degree + 1 childdofs = child_degree + 1 allocate ( ysplit ( childdofs * pardofs , 2 )) call ply_split_element_singleD ( nDims = 2 , & & inLen = [ pardofs , pardofs ], & & outLen = [ childdofs , pardofs ], & & ignore = ignore , & & parent_data = parent_data , & & child_data = ysplit ) call ply_split_element_singleD ( nDims = 2 , & & inLen = [ childdofs , pardofs ], & & outLen = [ childdofs , childdofs ], & & ignore = ignore , & & parent_data = ysplit , & & child_data = child_data ) deallocate ( ysplit ) end subroutine ply_split_element_2D ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Split three-dimensional elements of degree parent_degree into eight !! elements with polynomials of degree child_degree. subroutine ply_split_element_3D ( parent_degree , child_degree , parent_data , & & child_data , ignore_highmodes ) ! -------------------------------------------------------------------- ! !> Polynomial degree in the parent element. integer , intent ( in ) :: parent_degree !> Polynomial degree in the child elements. integer , intent ( in ) :: child_degree !> Polynomial data in the parent element. The first index describes the !! degrees of freedom. The second index refers to the elements to split. real ( kind = rk ), intent ( in ) :: parent_data (:,:) !> Polynomial data in the child elements. The first index describes the !! degrees of freedom. The second index refers to the elements, there !! needs to be four times as many elements than in the parent_data. !! !! Elements follow the ordering of the Z space filling curve. real ( kind = rk ), intent ( out ) :: child_data (:,:) !> Whether to ignore high modes from the parent element. !! !! This can be used as a simple lowpass filter by ignoring all higher !! modes from the parent element, that exceed the target polynomial !! degree. Thus, the polynomials are filtered before projection, !! instead of cutting them only of after refinement. !! Defaults to false (no filtering). logical , optional , intent ( in ) :: ignore_highmodes ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: ysplit (:,:) real ( kind = rk ), allocatable :: zsplit (:,:) logical :: ignore integer :: pardofs integer :: childdofs ! -------------------------------------------------------------------- ! pardofs = parent_degree + 1 childdofs = child_degree + 1 ignore = . false . if ( present ( ignore_highmodes )) then ignore = ignore_highmodes end if allocate ( zsplit ( childdofs * pardofs ** 2 , 2 )) allocate ( ysplit ( childdofs ** 2 * pardofs , 4 )) call ply_split_element_singleD ( nDims = 3 , & & inLen = [ pardofs , pardofs , & & pardofs ], & & outLen = [ childdofs , pardofs , & & pardofs ], & & ignore = ignore , & & parent_data = parent_data , & & child_data = zsplit ) call ply_split_element_singleD ( nDims = 3 , & & inLen = [ childdofs , pardofs , & & pardofs ], & & outLen = [ childdofs , childdofs , & & pardofs ], & & ignore = ignore , & & parent_data = zsplit , & & child_data = ysplit ) call ply_split_element_singleD ( nDims = 3 , & & inLen = [ childdofs , childdofs , & & pardofs ], & & outLen = [ childdofs , childdofs , & & childdofs ], & & ignore = ignore , & & parent_data = ysplit , & & child_data = child_data ) deallocate ( ysplit ) deallocate ( zsplit ) end subroutine ply_split_element_3D ! ======================================================================== ! ! !!!!!!! ! ! testing ! ! !!!!!!! ! ! To test the transformation, we check various mode combinations. ! For those, with the same number of modes in the children as in the ! parents, the resulting polynomials in the children should coincide. ! We check this by creating random parent polynomials, and then testing ! a random set of points after the split operation. ! ! When modes are cutted off, we only check the first mode, to see, whether ! the resulting integral mean, is the same as in the parent polynomial. ! ! To identify the children we use the following terminology to refer to ! the directions: ! west   = -x, east  = +x ! south  = -y, north = +y ! bottom = -z, top   = +z ! ! The children are expected to have the following layout: ! !                      |   west  |   east  | ! !                      +---------+---------+ !                      |         |         | !                north |    7    |    8    | !                      |         |         | !    top layer:        +---------+---------+ !                      |         |         | !                south |    5    |    6    | !                      |         |         | !                      +---------+---------+ ! ! !                      +---------+---------+ !                      |         |         | !                north |    3    |    4    | !                      |         |         | ! bottom layer:        +---------+---------+ !                      |         |         | !                south |    1    |    2    | !                      |         |         | !                      +---------+---------+ ! ------------------------------------------------------------------------ ! !> Testing the 1D splitting. !! !! We test all combinations, even though a higher number of modes in the !! children is probably not that relevant, it should still be possible. subroutine ply_split_element_1D_test ( nModes , success ) ! -------------------------------------------------------------------- ! !> Number of modes in the (1D) polynomials to use in the check. integer , intent ( in ) :: nModes !> Indication whether the tests were completed successfully. logical , intent ( out ) :: success ! -------------------------------------------------------------------- ! integer :: parentModes , childmodes integer :: iPoint integer :: iElem real ( kind = rk ) :: xi ( nModes ) real ( kind = rk ) :: x_left ( nModes ) real ( kind = rk ) :: x_right ( nModes ) real ( kind = rk ) :: legchild ( nModes , nModes ) real ( kind = rk ) :: legleft ( nModes , nModes ) real ( kind = rk ) :: legright ( nModes , nModes ) real ( kind = rk ) :: rootval ( nModes , 2 ) real ( kind = rk ) :: childval real ( kind = rk ), allocatable :: rootelem (:,:) real ( kind = rk ), allocatable :: childelem (:,:) real ( kind = rk ) :: tolerance ! -------------------------------------------------------------------- ! call ply_split_element_init ( nModes ) tolerance = 8 * epsilon ( 1.0_rk ) * nmodes ** 2 success = . true . ! Some random points to check the resulting child polynomials. call random_number ( xi ) legchild = ply_legendre_1d ( xi , nModes - 1 ) ! The corresponding positions in the left and right half of the root ! element. x_right = 0.5_rk * xi + 0.5_rk x_left = 0.5_rk * xi - 0.5_rk legleft = ply_legendre_1d ( x_left , nModes - 1 ) legright = ply_legendre_1d ( x_right , nModes - 1 ) do parentmodes = 1 , nModes allocate ( rootelem ( parentModes , 1 )) call random_number ( rootelem ) do iPoint = 1 , nModes rootval ( iPoint , 1 ) = sum ( rootelem (:, 1 ) & & * legleft (: parentModes , iPoint ) ) rootval ( iPoint , 2 ) = sum ( rootelem (:, 1 ) & & * legright (: parentModes , iPoint ) ) end do do childmodes = 1 , parentModes - 1 allocate ( childelem ( childmodes , 2 )) call ply_split_element_singleD ( nDims = 1 , & & inLen = [ parentModes ], & & outLen = [ childModes ], & & ignore = . false ., & & parent_data = rootelem , & & child_data = childelem ) success = success & & . and . ( 0.5_rk * ( childelem ( 1 , 1 ) + childelem ( 1 , 2 )) & & - rootelem ( 1 , 1 ) < tolerance ) deallocate ( childelem ) end do do childmodes = parentmodes , nModes allocate ( childelem ( childmodes , 2 )) call ply_split_element_singleD ( nDims = 1 , & & inLen = [ parentModes ], & & outLen = [ childModes ], & & ignore = . false ., & & parent_data = rootelem , & & child_data = childelem ) do iElem = 1 , 2 do iPoint = 1 , nModes childval = sum ( childelem (:, iElem ) & * legchild (: childmodes , iPoint ) ) success = success & & . and . ( abs ( rootval ( iPoint , iElem ) - childval ) & & < tolerance ) end do end do deallocate ( childelem ) end do deallocate ( rootelem ) end do end subroutine ply_split_element_1D_test ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Testing the 2D splitting. !! !! In two dimensions we only check the downsized polynomial splitting !! (child_degree <= parent_degree), upsized splitting is checked for 1D !! operations already. !! For child_degree == parent_degree the resulting polynomials are probed !! at a set of random points to ensure the polynomials coincide with the !! parent polynomial. !! For those, where modes are cut off, we check the integral mean to be !! maintained. subroutine ply_split_element_2D_test ( nModes , success ) ! -------------------------------------------------------------------- ! !> Number of modes in the (1D) polynomials to use in the check. integer , intent ( in ) :: nModes !> Indication whether the tests were completed successfully. logical , intent ( out ) :: success ! -------------------------------------------------------------------- ! integer :: parentModes , childmodes integer :: iPoint integer :: iElem integer :: iMode real ( kind = rk ) :: xi ( nModes , 2 ) real ( kind = rk ) :: x_southwest ( nModes , 2 ) real ( kind = rk ) :: x_southeast ( nModes , 2 ) real ( kind = rk ) :: x_northwest ( nModes , 2 ) real ( kind = rk ) :: x_northeast ( nModes , 2 ) real ( kind = rk ) :: legchild ( nModes , nModes , 2 ) real ( kind = rk ) :: legsouthwest ( nModes , nModes , 2 ) real ( kind = rk ) :: legsoutheast ( nModes , nModes , 2 ) real ( kind = rk ) :: legnorthwest ( nModes , nModes , 2 ) real ( kind = rk ) :: legnortheast ( nModes , nModes , 2 ) real ( kind = rk ) :: rootvaly ( nModes , 4 ) real ( kind = rk ) :: rootval ( nModes , 4 ) real ( kind = rk ) :: childval real ( kind = rk ) :: childvaly ( nModes ) real ( kind = rk ), allocatable :: rootelem (:,:) real ( kind = rk ), allocatable :: childelem (:,:) real ( kind = rk ) :: tolerance ! -------------------------------------------------------------------- ! call ply_split_element_init ( nModes ) tolerance = 8 * epsilon ( 1.0_rk ) * nmodes ** 2 success = . true . ! Some random points to check the resulting child polynomials. call random_number ( xi ) legchild (:,:, 1 ) = ply_legendre_1d ( xi (:, 1 ), nModes - 1 ) legchild (:,:, 2 ) = ply_legendre_1d ( xi (:, 2 ), nModes - 1 ) ! The corresponding positions in the left and right half of the root ! element. x_southwest = 0.5_rk * xi - 0.5_rk x_northeast = 0.5_rk * xi + 0.5_rk x_southeast (:, 1 ) = 0.5_rk * xi (:, 1 ) + 0.5_rk x_southeast (:, 2 ) = 0.5_rk * xi (:, 2 ) - 0.5_rk x_northwest (:, 1 ) = 0.5_rk * xi (:, 1 ) - 0.5_rk x_northwest (:, 2 ) = 0.5_rk * xi (:, 2 ) + 0.5_rk legsouthwest (:,:, 1 ) = ply_legendre_1d ( x_southwest (:, 1 ), nModes - 1 ) legsouthwest (:,:, 2 ) = ply_legendre_1d ( x_southwest (:, 2 ), nModes - 1 ) legsoutheast (:,:, 1 ) = ply_legendre_1d ( x_southeast (:, 1 ), nModes - 1 ) legsoutheast (:,:, 2 ) = ply_legendre_1d ( x_southeast (:, 2 ), nModes - 1 ) legnorthwest (:,:, 1 ) = ply_legendre_1d ( x_northwest (:, 1 ), nModes - 1 ) legnorthwest (:,:, 2 ) = ply_legendre_1d ( x_northwest (:, 2 ), nModes - 1 ) legnortheast (:,:, 1 ) = ply_legendre_1d ( x_northeast (:, 1 ), nModes - 1 ) legnortheast (:,:, 2 ) = ply_legendre_1d ( x_northeast (:, 2 ), nModes - 1 ) do parentmodes = 1 , nModes allocate ( rootelem ( parentModes ** 2 , 1 )) call random_number ( rootelem ) do iPoint = 1 , nModes do iMode = 1 , parentmodes rootvaly ( iMode , 1 ) = sum ( rootelem (( iMode - 1 ) * parentmodes + 1 & & : iMode * parentmodes , 1 ) & & * legsouthwest (: parentModes , iPoint , & & 1 ) ) rootvaly ( iMode , 2 ) = sum ( rootelem (( iMode - 1 ) * parentmodes + 1 & & : iMode * parentmodes , 1 ) & & * legsoutheast (: parentModes , iPoint , & & 1 ) ) rootvaly ( iMode , 3 ) = sum ( rootelem (( iMode - 1 ) * parentmodes + 1 & & : iMode * parentmodes , 1 ) & & * legnorthwest (: parentModes , iPoint , & & 1 ) ) rootvaly ( iMode , 4 ) = sum ( rootelem (( iMode - 1 ) * parentmodes + 1 & & : iMode * parentmodes , 1 ) & & * legnortheast (: parentModes , iPoint , & & 1 ) ) end do rootval ( iPoint , 1 ) = sum ( rootvaly (: parentmodes , 1 ) & & * legsouthwest (: parentModes , iPoint , 2 ) ) rootval ( iPoint , 2 ) = sum ( rootvaly (: parentmodes , 2 ) & & * legsoutheast (: parentModes , iPoint , 2 ) ) rootval ( iPoint , 3 ) = sum ( rootvaly (: parentmodes , 3 ) & & * legnorthwest (: parentModes , iPoint , 2 ) ) rootval ( iPoint , 4 ) = sum ( rootvaly (: parentmodes , 4 ) & & * legnortheast (: parentModes , iPoint , 2 ) ) end do do childmodes = 1 , parentModes - 1 allocate ( childelem ( childmodes ** 2 , 4 )) call ply_split_element_2D ( parent_degree = parentModes - 1 , & & child_degree = childModes - 1 , & & parent_data = rootelem , & & child_data = childelem ) success = success & & . and . ( 0.25_rk * sum ( childelem ( 1 ,:)) & & - rootelem ( 1 , 1 ) < tolerance ) deallocate ( childelem ) end do childmodes = parentmodes allocate ( childelem ( childmodes ** 2 , 4 )) call ply_split_element_2D ( parent_degree = parentModes - 1 , & & child_degree = childModes - 1 , & & parent_data = rootelem , & & child_data = childelem ) do iElem = 1 , 4 do iPoint = 1 , nModes do iMode = 1 , childmodes childvaly ( iMode ) = sum ( childelem (( iMode - 1 ) * childmodes + 1 & & : iMode * childmodes , iElem ) & & * legchild (: childmodes , iPoint , 1 ) ) end do childval = sum ( childvaly (: childmodes ) & & * legchild (: childmodes , iPoint , 2 ) ) success = success & & . and . ( abs ( rootval ( iPoint , iElem ) - childval ) & & < tolerance ) end do end do deallocate ( childelem ) deallocate ( rootelem ) end do end subroutine ply_split_element_2D_test ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Testing the 3D splitting. !! !! In three dimensions we only check the splitting to polynomials of same !! polynomial degree. !! Downsizing is checked in 2D, and upsizing is only checked for 1D. !! The resulting polynomials are probed at a set of random points to ensure !  the polynomials coincide with the parent polynomial. subroutine ply_split_element_3D_test ( nModes , success ) ! -------------------------------------------------------------------- ! !> Number of modes in the (1D) polynomials to use in the check. integer , intent ( in ) :: nModes !> Indication whether the tests were completed successfully. logical , intent ( out ) :: success ! -------------------------------------------------------------------- ! integer :: parentModes , childmodes integer :: iPoint integer :: iElem integer :: iMode , jMode integer :: ij integer :: iX , iY , iZ real ( kind = rk ) :: xi ( nModes , 3 ) real ( kind = rk ) :: x ( nModes , 3 , 8 ) real ( kind = rk ) :: legchild ( nModes , nModes , 3 ) real ( kind = rk ) :: legparent ( nModes , nModes , 3 , 8 ) real ( kind = rk ) :: rootvalz ( nModes , 8 ) real ( kind = rk ) :: rootvaly ( nModes , 8 ) real ( kind = rk ) :: rootval ( nModes , 8 ) real ( kind = rk ) :: childval real ( kind = rk ) :: childvaly ( nModes ) real ( kind = rk ) :: childvalz ( nModes ) real ( kind = rk ), allocatable :: rootelem (:,:) real ( kind = rk ), allocatable :: childelem (:,:) real ( kind = rk ) :: tolerance ! -------------------------------------------------------------------- ! call ply_split_element_init ( nModes ) tolerance = 8 * epsilon ( 1.0_rk ) * nmodes ** 3 success = . true . ! Some random points to check the resulting child polynomials. call random_number ( xi ) legchild (:,:, 1 ) = ply_legendre_1d ( xi (:, 1 ), nModes - 1 ) legchild (:,:, 2 ) = ply_legendre_1d ( xi (:, 2 ), nModes - 1 ) legchild (:,:, 3 ) = ply_legendre_1d ( xi (:, 3 ), nModes - 1 ) ! The corresponding positions in the left and right half of the root ! element. do iZ = 0 , 1 do iY = 0 , 1 do iX = 0 , 1 iElem = 1 + iX + ( iY + iZ * 2 ) * 2 x (:, 1 , iElem ) = 0.5_rk * xi (:, 1 ) + 0.5_rk * ( iX * 2 - 1 ) x (:, 2 , iElem ) = 0.5_rk * xi (:, 2 ) + 0.5_rk * ( iY * 2 - 1 ) x (:, 3 , iElem ) = 0.5_rk * xi (:, 3 ) + 0.5_rk * ( iZ * 2 - 1 ) end do end do end do do iElem = 1 , 8 legparent (:,:, 1 , iElem ) = ply_legendre_1d ( x (:, 1 , iElem ), nModes - 1 ) legparent (:,:, 2 , iElem ) = ply_legendre_1d ( x (:, 2 , iElem ), nModes - 1 ) legparent (:,:, 3 , iElem ) = ply_legendre_1d ( x (:, 3 , iElem ), nModes - 1 ) end do do parentmodes = 1 , nModes allocate ( rootelem ( parentModes ** 3 , 1 )) call random_number ( rootelem ) do iPoint = 1 , nModes ! Evaluation in Y direction do jMode = 1 , parentmodes do iElem = 1 , 8 ! For each Y mode evaluate the polynomial in X (in each of the ! children elements) do iMode = 1 , parentmodes ij = ( jMode - 1 ) * parentmodes + iMode rootvaly ( iMode , iElem ) = sum ( rootelem (( ij - 1 ) * parentmodes + 1 & & : ij * parentmodes , 1 ) & & * legparent (: parentModes , iPoint , 1 , & & iElem ) ) end do end do ! Evaluate the current Y-Mode to get the 1D polynomial in Z at the ! xy coordinates of iPoint. do iElem = 1 , 8 rootvalz ( jMode , iElem ) = sum ( rootvaly (: parentmodes , iElem ) & & * legparent (: parentModes , iPoint , 2 , & & iElem ) ) end do end do ! Finally evaluate the Z polynomial at the position of iPoint. do iElem = 1 , 8 rootval ( iPoint , iElem ) = sum ( rootvalz (: parentmodes , iElem ) & & * legparent (: parentModes , iPoint , 3 , & & iElem ) ) end do end do childmodes = parentmodes allocate ( childelem ( childmodes ** 3 , 8 )) call ply_split_element_3D ( parent_degree = parentModes - 1 , & & child_degree = childModes - 1 , & & parent_data = rootelem , & & child_data = childelem ) do iElem = 1 , 8 do iPoint = 1 , nModes do jMode = 1 , childmodes do iMode = 1 , childmodes ij = ( jMode - 1 ) * childmodes + iMode childvaly ( iMode ) = sum ( childelem (( ij - 1 ) * childmodes + 1 & & : ij * childmodes , iElem ) & & * legchild (: childmodes , iPoint , 1 ) ) end do childvalz ( jMode ) = sum ( childvaly (: childmodes ) & & * legchild (: childmodes , iPoint , 2 ) ) end do childval = sum ( childvalz (: childmodes ) & & * legchild (: childmodes , iPoint , 3 ) ) success = success & & . and . ( abs ( rootval ( iPoint , iElem ) - childval ) & & < tolerance ) end do end do deallocate ( childelem ) deallocate ( rootelem ) end do end subroutine ply_split_element_3D_test ! ======================================================================== ! ! ------------------------------------------------------------------------ ! !> Testing routine for the functions of this module. subroutine ply_split_element_test ( success ) ! -------------------------------------------------------------------- ! !> Indication whether the tests were completed successfully. logical , intent ( out ) :: success ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! call ply_split_element_init ( 80 ) ! The split_legendre matrix generation is already checked by the ! ply_split_legendre_test routine. call ply_split_element_1D_test ( nModes = 30 , success = success ) if (. not . success ) then write ( * , * ) 'Check for 1D splitting FAILED!' RETURN end if call ply_split_element_2D_test ( nModes = 20 , success = success ) if (. not . success ) then write ( * , * ) 'Check for 2D splitting FAILED!' RETURN end if call ply_split_element_3D_test ( nModes = 10 , success = success ) if (. not . success ) then write ( * , * ) 'Check for 3D splitting FAILED!' RETURN end if end subroutine ply_split_element_test ! ======================================================================== ! end module ply_split_element_module","tags":"","url":"sourcefile/ply_split_element_module.f90.html"},{"title":"ply_l2p_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_l2p_module.f90~~EfferentGraph sourcefile~ply_l2p_module.f90 ply_l2p_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~ply_lagrange_module.f90 ply_lagrange_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_lagrange_module.f90 sourcefile~ply_nodeset_module.f90 ply_nodeset_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_nodeset_module.f90 sourcefile~ply_space_integration_module.f90 ply_space_integration_module.f90 sourcefile~ply_l2p_module.f90->sourcefile~ply_space_integration_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_lagrange_module.f90->sourcefile~ply_nodeset_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2012-2015,2018,2020 Harald Klimach <harald.klimach@uni-siegen.de.de> ! Copyright (c) 2012 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2012 Melven Zoellner <yameta@freenet.de> ! Copyright (c) 2013-2014,2016 Verena Krupp ! Copyright (c) 2013-2014, 2017, 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2014-2015 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Parts of this file were written by Jens Zudrop, Jan Hueckelheim, Melven ! Zoellner and Harald Klimach for German Research School for Simulation ! Sciences GmbH. ! ! Parts of this file were written by Harald Klimach, Verena Krupp, Peter Vitt, ! Tobias Girresser, Jiaxing Qi and Nikhil Anand for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! module ply_l2p_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_compileconf_module , only : vlen use tem_logging_module , only : logUnit use ply_modg_basis_module , only : ply_scalProdLeg use ply_space_integration_module , only : ply_gaussLegPoints use ply_modg_basis_module , only : ply_legendre_1d use ply_nodeset_module , only : ply_nodeset_chebyshev , & & ply_nodeset_chebyloba use ply_l2p_header_module , only : ply_l2p_header_type use ply_lagrange_module , only : ply_lagrange_type , & & ply_lagrange_define , & & ply_lagrange_1D implicit none private !> Storage of the transformation matrices for the L2 projection method to !! convert between modal and nodal values. type ply_l2p_type real ( kind = rk ), allocatable :: leg2node (:,:) real ( kind = rk ), allocatable :: node2leg (:,:) end type ply_l2p_type interface assignment ( = ) module procedure Copy_ply_l2p end interface public :: ply_l2p_type public :: ply_init_l2p public :: assignment ( = ) public :: ply_l2p_trafo_1D , ply_l2p_trafo_2D , ply_l2p_trafo_3D contains ! ************************************************************************ ! subroutine Copy_ply_l2p ( left , right ) ! -------------------------------------------------------------------- ! !> fpt to copy to !type(ply_legFpt_2D_type), intent(out) :: left type ( ply_l2p_type ), intent ( out ) :: left !> fpt to copy from !type(ply_legFpt_2D_type), intent(in) :: right type ( ply_l2p_type ), intent ( in ) :: right ! -------------------------------------------------------------------- ! left % leg2node = right % leg2node left % node2leg = right % node2leg end subroutine Copy_ply_l2p ! ************************************************************************ ! ! ************************************************************************ ! !> Initialize the transformations via L2 projections. subroutine ply_init_l2p ( l2p , header , degree ) ! -------------------------------------------------------------------- ! type ( ply_l2p_type ), intent ( out ) :: l2p type ( ply_l2p_header_type ), intent ( in ) :: header integer , intent ( in ) :: degree ! -------------------------------------------------------------------- ! integer :: iPoint , iDof integer :: nDofs integer :: nPoints real ( kind = rk ), allocatable :: gaussp1D (:) real ( kind = rk ), allocatable :: target_nodes (:) real ( kind = rk ), allocatable :: leg_at_gauss (:,:) real ( kind = rk ), allocatable :: lagrange_at_gauss (:,:) real ( kind = rk ), allocatable :: weights1D (:) real ( kind = rk ) :: quad real ( kind = rk ) :: scalprod_q type ( ply_lagrange_type ) :: lagrange ! -------------------------------------------------------------------- ! nDofs = degree + 1 nPoints = nDofs allocate ( leg_at_gauss ( nDofs , nPoints )) allocate ( gaussp1D ( nPoints )) allocate ( weights1D ( nPoints )) allocate ( target_nodes ( nPoints )) allocate ( l2p % leg2node ( nDofs , nPoints )) allocate ( l2p % node2leg ( nPoints , nDofs )) ! Find points and weights for numerical Gauss-Legendre quadrature. call ply_gaussLegPoints ( x1 = - 1.0_rk , & & x2 = 1.0_rk , & & nIntP = nPoints , & & w = weights1D , & & x = gaussp1D ) leg_at_gauss = ply_legendre_1d ( points = gaussp1D , & & degree = degree ) select case ( trim ( header % nodes_header % nodes_kind )) case ( 'gauss-legendre' ) ! Create the projection matrix. ! Coefficients to transform legendre to nodal values (evaluate ! each mode at all points in the node set. ! As we project to the Gauss-Legendre nodes we can simply ! utilize the results for all the mode values at those points. l2p % leg2node = leg_at_gauss ! Coefficients to transform nodal to legendre values. do iDoF = 1 , nDofs scalProd_q = 1.0_rk / ply_scalProdLeg ( iDoF ) do iPoint = 1 , nPoints l2p % node2leg ( iPoint , iDoF ) = l2p % leg2node ( iDoF , iPoint ) & & * weights1D ( iPoint ) & & * scalProd_q end do end do case ( 'chebyshev' ) ! Defining a lagrange polynomial series to allow the evaluation of ! its basis functions, the values do not matter to us here. if ( header % nodes_header % lobattoPoints ) then lagrange = ply_lagrange_define ( nPoints = nPoints , & & nodeset = ply_nodeset_chebyloba , & & values = target_nodes ) else lagrange = ply_lagrange_define ( nPoints = nPoints , & & nodeset = ply_nodeset_chebyshev , & & values = target_nodes ) end if allocate ( lagrange_at_gauss ( nDofs , nPoints )) ! Create the projection matrix. ! Coefficients to transform legendre to nodal values (evaluate ! each mode at all points in the node set. l2p % leg2node = ply_legendre_1d ( points = lagrange % coords , & & degree = degree ) ! Coefficients to transform nodal to legendre values. ! This matrix is computed by using the numerical Gauss-Legendre ! integration for the L2 projection of the Lagrange series to ! the Legendre basis. lagrange_at_gauss = ply_lagrange_1D ( me = lagrange , points = gaussP1D ) do iDoF = 1 , nDofs scalProd_q = 1.0_rk / ply_scalProdLeg ( iDoF ) do iPoint = 1 , nPoints quad = sum ( weights1D * lagrange_at_gauss ( iPoint , :) & & * leg_at_gauss ( iDoF , :) ) l2p % node2leg ( iPoint , iDoF ) = quad * scalProd_q end do end do case default write ( logUnit ( 1 ), * ) 'Error in L2P initialization' write ( logUnit ( 1 ), * ) '\"' // trim ( header % nodes_header % nodes_kind ) & & // '\" NOT supported by L2P!' write ( logUnit ( 1 ), * ) 'Aborting...' call tem_abort () end select end subroutine ply_init_l2p ! ************************************************************************ ! ! ************************************************************************ ! !> Actual implementation of the matrix operation to change between nodal !! and modal representations. !! !! The operation is applied simultaneously to nIndeps 1D sections of the !! provided original data. !! These 1D sections have to run fastest in the original array and will be !! transposed (running slowest in the projected array). !! The actual direction of the operation depends on the passed matrix. !! matrix = l2p%leg2node will do the modal to nodal transformation !! matrix = l2p%node2leg will do the nodal to modal transformation subroutine ply_l2_projection ( nDofs , nIndeps , projected , original , matrix ) !ICE! Directive for Cray compiler to prevent inlining of this routine, !ICE! what causes the compiler to fail. !dir$ inlinenever ply_l2_projection ! -------------------------------------------------------------------- ! !> Number of degree of freedoms integer , intent ( in ) :: nDofs !> Number of values that can be computed independently. integer , intent ( in ) :: nIndeps !> Projected data. !! !! Size has to be nIndeps*size(matrix,1), and the layout is changed here !! when compared to the original array, as the projected direction moves !! to the end. real ( kind = rk ), intent ( out ) :: projected ( nIndeps , nDofs ) !> Original data. !! !! Size has to be size(matrix,1) and the direction to be projected has to !! be the fastest running one. real ( kind = rk ), intent ( in ) :: original ( nDofs , nIndeps ) !> Matrix to apply in this operation. !! !! The matrix defines wether this is a modal to nodal transformation or the !! other way around. real ( kind = rk ), intent ( in ) :: matrix ( nDofs , nDofs ) ! -------------------------------------------------------------------- ! integer :: iRow , iCol , iCell , iStrip , strip_ub real ( kind = rk ) :: mval ! JQ: on SX-ACE, vlen=nIndeps gives the best performance !     on    x86, vlen=256     gives the best performance ! integer, parameter :: vlen = nIndeps ! -------------------------------------------------------------------- ! if ( nDofs > 1 ) then do iStrip = 0 , nIndeps - 1 , vlen ! Calculate the upper bound of the current strip strip_ub = min ( iStrip + vlen , nIndeps ) - iStrip do iRow = 1 , nDofs do iCell = iStrip + 1 , iStrip + strip_ub projected ( iCell , iRow ) = 0.0_rk end do do iCol = 1 , nDofs mval = matrix ( iCol , iRow ) do iCell = iStrip + 1 , iStrip + strip_ub ! on SX-ACE, this can be identified as matrix multiplication ! which results in VERY HIGH performance projected ( iCell , iRow ) = projected ( iCell , iRow ) & & + mval * original ( iCol , iCell ) end do ! iCell end do ! iCol = 1, nCols end do ! iRow = 1, nRows end do ! iStrip else projected = matrix ( nDofs , 1 ) * original end if end subroutine ply_l2_projection ! ************************************************************************ ! ! ************************************************************************ ! !> Transformation between modal and nodal values in 1D via L2 projection. subroutine ply_l2p_trafo_1D ( trafo , projected , original ) ! -------------------------------------------------------------------- ! !> L2 Projection matrix, this determines the direction of the trafo at hand !! !! l2p%leg2node = modal to nodal !! l2p%node2leg = nodal to modal real ( kind = rk ), intent ( in ) :: trafo (:,:) !> Original coefficients to project. real ( kind = rk ), intent ( inout ) :: original (:) !> Projected coefficients. real ( kind = rk ), intent ( inout ) :: projected (:) ! -------------------------------------------------------------------- ! call ply_l2_projection ( nIndeps = 1 , & & nDofs = size ( trafo , 1 ), & & projected = projected , & & original = original , & & matrix = trafo ) end subroutine ply_l2p_trafo_1D ! ************************************************************************ ! ! ************************************************************************ ! !> Transformation between modal and nodal values in 2D via L2 projection. subroutine ply_l2p_trafo_2D ( trafo , projected , original ) ! -------------------------------------------------------------------- ! !> L2 Projection matrix, this determines the direction of the trafo at hand !! !! l2p%leg2node = modal to nodal !! l2p%node2leg = nodal to modal real ( kind = rk ), intent ( in ) :: trafo (:,:) !> Original coefficients to project. real ( kind = rk ), intent ( inout ) :: original (:) !> Projected coefficients. real ( kind = rk ), intent ( inout ) :: projected (:) ! -------------------------------------------------------------------- ! integer :: nDofs ! -------------------------------------------------------------------- ! nDofs = size ( trafo , 1 ) ! Transformation in X direction call ply_l2_projection ( nIndeps = nDofs , & & nDofs = nDofs , & & projected = projected , & & original = original , & & matrix = trafo ) ! Transformation in Y direction call ply_l2_projection ( nIndeps = nDofs , & & nDofs = nDofs , & & projected = original , & & original = projected , & & matrix = trafo ) ! As we reuse the original array in Y-direction to store the projected ! values, thus we need to copy those back into the projected array. projected = original end subroutine ply_l2p_trafo_2D ! ************************************************************************ ! ! ************************************************************************ ! !> Transformation between modal and nodal values in 3D via L2 projection. subroutine ply_l2p_trafo_3D ( trafo , projected , original ) ! -------------------------------------------------------------------- ! !> L2 Projection matrix, this determines the direction of the trafo at hand !! !! l2p%leg2node = modal to nodal !! l2p%node2leg = nodal to modal real ( kind = rk ), intent ( in ) :: trafo (:,:) !> Original coefficients to project. real ( kind = rk ), intent ( inout ) :: original (:) !> Projected coefficients. real ( kind = rk ), intent ( inout ) :: projected (:) ! -------------------------------------------------------------------- ! integer :: nDofs integer :: nDofs_square ! -------------------------------------------------------------------- ! nDofs = size ( trafo , 1 ) nDofs_square = nDofs ** 2 ! Transformation in X direction call ply_l2_projection ( nIndeps = nDofs_square , & & nDofs = nDofs , & & projected = projected , & & original = original , & & matrix = trafo ) ! Transformation in Y direction call ply_l2_projection ( nIndeps = nDofs_square , & & nDofs = nDofs , & & projected = original , & & original = projected , & & matrix = trafo ) ! Transformation in Z direction call ply_l2_projection ( nIndeps = nDofs_square , & & nDofs = nDofs , & & projected = projected , & & original = original , & & matrix = trafo ) end subroutine ply_l2p_trafo_3D ! ************************************************************************ ! end module ply_l2p_module","tags":"","url":"sourcefile/ply_l2p_module.f90.html"},{"title":"ply_fxt_header_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_fxt_header_module.f90~~EfferentGraph sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ply_fxt_header_module.f90~~AfferentGraph sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_fxt_module.f90 ply_fxt_module.f90 sourcefile~ply_fxt_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2015,2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2017 Daniel Petró <daniel.petro@student.uni-siegen.de> ! Copyright (c) 2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2019 Neda Ebrahimi Pour <neda.epour@uni-siegen.de> ! ! Parts of this file were written by Nikhil Anand, Harald Klimach, Daniel Petró, ! Peter Vitt and Neda Ebrahimi Pour for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> The FXT method offers a transformation from Legendre modes to nodes by a !! fast multipole approach implemented in the !! [FXTPACK](http://sudalab.is.s.u-tokyo.ac.jp/~reiji/fxtpack.html) library by !! Reiji Suda: !! R. Suda, \"Fast Spherical Harmonic Transform Algorithm based on !! Generalized Fast Multiple Method\", RIMS Kokyuroku vol 1606, !! pp. 18-29, Jun. 2008, RIMS, Kyoto University. !! !! Besides the oversampling `factor` that can be used to increase the number !! points in the nodal representation to achieve an de-aliasing, there is only !! one other option to this method: !! The `prec` parameter configures the precision up to which the FXTPACK !! should compute the transformation. !! It defaults to the square root of the epsilon for the real kind. With !! double precision this would something around 1.4e-8. !! !! This transformation utilizes the Gauss Legendre integration points in the !! nodal representation. !! !! Thus, the configuration for a FXT projection takes the following form: !! !!```lua !!  projection = { !!    kind = 'fxt', !!    prec = 1.e-10 !!  } !!``` !! module ply_fxt_header_module use env_module , only : rk use aotus_module , only : flu_State , aot_get_val use aot_out_module , only : aot_out_type , aot_out_val use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use tem_float_module use ply_nodes_header_module , only : ply_nodes_header_type , & & operator ( == ), & & operator ( /= ), & & operator ( <= ), & & operator ( >= ), & & operator ( < ), & & operator ( > ) implicit none private !> Fxt projection header type, consisting of the node header which give !! information about the type and number of points for the projection type ply_fxt_header_type type ( ply_nodes_header_type ) :: nodes_header real ( kind = rk ) :: factor = 1.0 real ( kind = rk ) :: prec = epsilon ( 1.0 ) end type ply_fxt_header_type interface assignment ( = ) module procedure Copy_fxt_header end interface interface operator ( == ) module procedure isEqual end interface interface operator ( /= ) module procedure isUnequal end interface interface operator ( < ) module procedure isSmaller end interface interface operator ( <= ) module procedure isSmallerOrEqual end interface interface operator ( > ) module procedure isGreater end interface interface operator ( >= ) module procedure isGreaterOrEqual end interface public :: operator ( == ), operator ( /= ), operator ( < ), operator ( <= ) public :: operator ( > ), operator ( >= ) public :: assignment ( = ) public :: ply_fxt_header_type public :: ply_fxt_header_load , ply_fxt_header_display public :: ply_fxt_header_out contains ! ------------------------------------------------------------------------ ! pure subroutine Copy_fxt_header ( left , right ) ! -------------------------------------------------------------------- ! !> fpt to copy to type ( ply_fxt_header_type ), intent ( out ) :: left !> fpt to copy from type ( ply_fxt_header_type ), intent ( in ) :: right ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! left % factor = right % factor left % prec = right % prec left % nodes_header = right % nodes_header end subroutine Copy_fxt_header ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Load settings to describe a projection method from a Lua table. subroutine ply_fxt_header_load ( me , conf , thandle ) ! -------------------------------------------------------------------- ! type ( ply_fxt_header_type ), intent ( out ) :: me type ( flu_State ) :: conf integer , intent ( in ) :: thandle ! -------------------------------------------------------------------- ! integer :: iError ! -------------------------------------------------------------------- ! ! for fxt gauss-legendre points are used me % nodes_header % nodes_kind = 'gauss-legendre' ! fill up fxt header call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'factor' , & & val = me % factor , & & default = 1.0_rk , & & ErrCode = iError ) if ( me % factor <= 0 ) then write ( logUnit ( 1 ), * ) 'ERROR in loading projection: factor for' & & // ' projection has to be larger than 0!' write ( logUnit ( 1 ), * ) 'But it is set to ' , me % factor call tem_abort () end if call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'prec' , & & val = me % prec , & & default = sqrt ( epsilon ( 1.0_rk )), & & ErrCode = iError ) !>\\todo Check, wether Lobatto Points could be used with FXTPACK. me % nodes_header % lobattoPoints = . false . !!call aot_get_val(L       = conf,                          & !!  &              thandle = thandle,                       & !!  &              key     = 'lobattoPoints',               & !!  &              val     = me%nodes_header%lobattoPoints, & !!  &              ErrCode = iError,                        & !!  &              default = .false.                        ) end subroutine ply_fxt_header_load ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Write FXT settings into a Lua table. subroutine ply_fxt_header_out ( me , conf ) ! -------------------------------------------------------------------- ! type ( ply_fxt_header_type ), intent ( in ) :: me type ( aot_out_type ) :: conf ! -------------------------------------------------------------------- ! call aot_out_val ( put_conf = conf , & & vname = 'factor' , & & val = me % factor ) call aot_out_val ( put_conf = conf , & & vname = 'lobattoPoints' , & & val = me % nodes_header % lobattoPoints ) end subroutine ply_fxt_header_out ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine ply_fxt_header_display ( me ) ! -------------------------------------------------------------------- ! type ( ply_fxt_header_type ), intent ( in ) :: me ! -------------------------------------------------------------------- ! write ( logUnit ( 1 ), * ) ' * Kind of projection method = fxt' write ( logUnit ( 1 ), * ) ' * Precision for the fast multipole: ' , me % prec write ( logUnit ( 1 ), * ) ' * Factor to use in projection = ' , me % factor write ( logUnit ( 1 ), * ) ' * using LobattoPoints = ' , & & me % nodes_header % lobattoPoints if ( me % factor < 2.0_rk ) then write ( logUnit ( 1 ), * ) '' write ( logUnit ( 1 ), * ) & & '+-----------------------------------------------------+' write ( logUnit ( 1 ), * ) & & '| WARNING, the oversampling factor is smaller than 2! |' write ( logUnit ( 1 ), * ) & & '|        this might lead to bad projections!          |' write ( logUnit ( 1 ), * ) & & '+-----------------------------------------------------+' end if end subroutine ply_fxt_header_display ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides the test for equality of two projections. !! !! Two fxt header are considered to be equal, if their node_header, !! and the factor are equal. pure function isEqual ( left , right ) result ( equality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fxt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fxt_header_type ), intent ( in ) :: right !> is equal?? logical :: equality ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! equality = ( left % nodes_header == right % nodes_header ) & & . and . ( left % factor . feq . right % factor ) end function isEqual ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides the test for unequality of two projections. !! !! Two fxt header are considered to be unequal, if their node_header, !! or the factor are not equal. pure function isUnequal ( left , right ) result ( unequality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fxt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fxt_header_type ), intent ( in ) :: right !> is unequal?? logical :: unequality ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! unequality = ( left % nodes_header /= right % nodes_header ) & & . or . ( left % factor . fne . right % factor ) end function isUnequal ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a < comparison of two projections. !! !! Sorting of fxt header is given by node_header and by the factor. pure function isSmaller ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fxt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fxt_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! small = . false . if ( left % nodes_header < right % nodes_header ) then small = . true . else if ( left % nodes_header == right % nodes_header ) then small = ( left % factor < right % factor ) end if end if end function isSmaller ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a <= comparison of two projections. !! !! Sorting of fxt header is given by node_header, fxt_blocksize and !! last by factor. pure function isSmallerOrEqual ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fxt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fxt_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! small = . false . if ( left % nodes_header < right % nodes_header ) then small = . true . else if ( left % nodes_header == right % nodes_header ) then small = ( left % factor <= right % factor ) end if end if end function isSmallerOrEqual ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a > comparison of two projections. !! !! Sorting of fxt header is given by node_header, fxt_blocksize and !! last by factor. pure function isGreater ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fxt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fxt_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! great = . false . if ( left % nodes_header > right % nodes_header ) then great = . true . else if ( left % nodes_header == right % nodes_header ) then great = ( left % factor > right % factor ) end if end if end function isGreater ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a >= comparison of two projections. !! !! Sorting of fxt header is given by node_header, fxt_blocksize and !! last by factor. pure function isGreaterOrEqual ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fxt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fxt_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! great = . false . if ( left % nodes_header > right % nodes_header ) then great = . true . else if ( left % nodes_header == right % nodes_header ) then great = ( left % factor >= right % factor ) end if end if end function isGreaterOrEqual ! ------------------------------------------------------------------------ ! end module ply_fxt_header_module","tags":"","url":"sourcefile/ply_fxt_header_module.f90.html"},{"title":"sdr_aux_module.f90 – Seeder","text":"Files dependent on this one sourcefile~~sdr_aux_module.f90~~AfferentGraph sourcefile~sdr_aux_module.f90 sdr_aux_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2014 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011-2012, 2014 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ******************************************************************************! !> Some auxilary functionalities. module sdr_aux_module ! treelm modules use tem_aux_module , only : tem_print_execInfo use tem_logging_module , only : logunit use tem_solveHead_module , only : tem_solveHead_type implicit none private public :: sdr_init_global contains ! ****************************************************************************! !> Prominently let the user now, what he actually is running right now. !! !! Also set the solvername and version number in the solveHead. subroutine sdr_init_global ( solveHead ) !> contains solver header information type ( tem_solveHead_type ), intent ( in ) :: solveHead write ( logunit ( 1 ), * ) \"                                             \" write ( logunit ( 1 ), * ) \"                              _              \" write ( logunit ( 1 ), * ) \"            ___  ___  ___  __| | ___ _ __    \" write ( logunit ( 1 ), * ) \"           / __|/ _ \\/ _ \\/ _` |/ _ \\ '__|   \" write ( logunit ( 1 ), * ) \"           \\__ \\  __/  __/ (_| |  __/ |      \" write ( logunit ( 1 ), * ) \"           |___/\\___|\\___|\\__,_|\\___|_\" & // trim ( solveHead % version ) write ( logunit ( 1 ), * ) \"                                             \" write ( logunit ( 1 ), * ) & & \" (C) 2012 German Research School for Simulation Sciences\" write ( logunit ( 1 ), * ) \" (C) 2013 University of Siegen               \" write ( logunit ( 1 ), * ) \"                                             \" ! Write the information about the executable, gathered at build time to ! the screen. call tem_print_execInfo () write ( logunit ( 1 ), * ) \"                                             \" write ( logunit ( 1 ), * ) \"                                             \" end subroutine sdr_init_global ! ****************************************************************************! end module sdr_aux_module ! ******************************************************************************!","tags":"","url":"sourcefile/sdr_aux_module.f90.html"},{"title":"ply_fpt_header_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_fpt_header_module.f90~~EfferentGraph sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ply_fpt_header_module.f90~~AfferentGraph sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_legfpt_module.f90 ply_legFpt_module.f90 sourcefile~ply_legfpt_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013-2014 Verena Krupp ! Copyright (c) 2013-2014, 2016, 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2013-2014, 2016-2017, 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2014 Nikhil Anand <nikhil.anand@uni-siegen.de> ! Copyright (c) 2017 Daniel Petró <daniel.petro@student.uni-siegen.de> ! Copyright (c) 2019 Neda Ebrahimi Pour <neda.epour@uni-siegen.de> ! ! Parts of this file were written by Verena Krupp, Harald Klimach, Peter Vitt, ! Nikhil Anand, Daniel Petró and Neda Ebrahimi Pour for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! ! !> Parameters for the FPT method !! !! The Fast Polynomial Transformation implements the approach described in !! B. K. Alpert und V. Rokhlin, „A Fast Algorithm for the Evaluation of !! Legendre Expansions“, SIAM Journal on Scientific and Statistical Computing, !! Vol. 12, Nr. 1, pp. 158–179, Jan. 1991, doi: 10.1137/0912009. !! !! It utilizes the Fast Fourier Transformation by first converting the !! Legendre modes into Chebyshev modes. !! The conversion between Legendre and Chebyshev modes is done approximately !! by approximating increasingly larger blocks away from the diagonal. !! This method is only available if the executable is linked against the !! [FFTW](http://fftw.org/). !! !! As with the other projection methods, a `factor` can be specified to !! use more points in the nodal representation and achieve some de-aliasing. !! Because the FFT works especially well for powers of two, it is possible to !! choose the oversampling such, that the oversampled modes have count of the !! next larger power of 2. !! To achieve this, the option `adapt_factor_pow2` has to be set to `true`, !! by default it is assumed to be `false`. !! Further it is possible to make use of `lobattoPoints` with this !! transformation method. !! If `lobattoPoints = true`, the points on the interval boundary will be !! included in the set of points in the nodal representation. This is for !! example necessary when positivity is to be preserved for the numerical !! fluxes. !! By default this setting is `false`. !! !! All other options tune the transformation algorithm: !! !! * `blocksize` defines the minimal block size that is to be approximated in !!   the transformation matrix. It defaults to 64, which is the recommendation !!   for double precision computations, but requires high polynomial degrees to !!   attain any approximation at all. The (oversampled) number of nodes needs to !!   be larger than two times the blocksize, to have at least one approximated !!   block. As long as the number modes is below this threshold the method is !!   not \"fast\" and a computational complexity of number of modes squared is !!   required for the operation. Smaller values push the approximation closer !!   to the diagonal. This can speed up the computation for smaller number of !!   modes but also detoriates the accuracy of the transformation. !! * `approx_terms` number of terms to use in the approximation of blocks, !!   defaults to 18, which is recommended for double precision computations. !!   In each block only `approx_terms` will be used to represent rows in the !!   block. Smaller values make the transformation faster, but less accurate !!   (if blocks are actually approximated). !! * `implementation` selects the implementation for the transformation. There !!   are two variants of the implementation: `'scalar'` this is the default !!   and treats the transformations with an outer loop over the independent !!   operations. The `'vector'` implementation on the other hand gathers !!   multiple independent operations together and performs them all at once !!   with an inner loop over blocks length `striplen`. While the `'vector'` !!   variant may exploit vector instructions, it utilizes a larger amount of !!   temporary memory. The default setting for this option is `'scalar'`. !! * `striplen` determines the length for vectorized loops to be used in the !!   matrix operation. It defaults to the `vlen` setting defined in !!   [[tem_compileconf_module]] during compilation. !!   Depending on the computing architecture, different values may provide !!   more efficient computations. !! * `subblockingWidth` defines striding in the multiplication of the diagonal !!   elements in the transformation matrix. The default for this setting is 8. !! !! The configuration table for the FPT table may, for example, look as follows: !! !!```lua !!  projection = { !!    kind              = 'fpt', !!    factor            = 1.5, !!    adapt_factor_pow2 = true, !!    lobattoPoints     = false, !!    blocksize         = 16, !!    approx_terms      = 12, !!    implementation    = 'scalar', !!    striplen          = 256, !!    subblockingWidth  = 8 !!  } !!``` module ply_fpt_header_module use env_module , only : rk , labelLen use aotus_module , only : flu_State , aot_get_val use aot_out_module , only : aot_out_type , aot_out_val use tem_aux_module , only : tem_abort use tem_tools_module , only : upper_to_lower use tem_logging_module , only : logUnit use tem_compileconf_module , only : vlen use tem_float_module use ply_nodes_header_module implicit none private !> The recommended minimal blocksize for double precision. integer , public , parameter :: ply_fpt_default_blocksize = 64 !> The default width of the subblocking of the diagonal calculation of the !! fpt projection integer , public , parameter :: ply_fpt_default_subblockingWidth = 8 !> Default number of terms to use in FPT blocks. 18 is recommended for !! double precision. integer , public , parameter :: ply_fpt_default_approx_terms = 18 !> Value to signify the use of the scalar FPT implementation. integer , public , parameter :: ply_fpt_scalar = 1 !> Value to signify the use of the vector FPT implementation. integer , public , parameter :: ply_fpt_vector = 2 !> Type for the fpt header, stores all information needed to initialize the !! fpt method later on type ply_fpt_header_type type ( ply_nodes_header_type ) :: nodes_header !> In case of nonlinear equations, aliasing occurs if the projections !! of the nonlinear terms on the testfunctions are not calculated !! accurately enough. To avoid these errors it is possible to !! extend the transformation vectors of the FPT with zeros. This !! factor determines by how many zeros the modal vector is extended !! before transformation. This factor has to be chosen properly with !! respect of the type of nonlinearity of your equation. real ( kind = rk ) :: factor = 1.0_rk !> The blockisze of the fast bases exchange algorithm from !! Legendre to Chebyshev polynomials. !! A negative number indicates to use the default blocksize of the !! algorithm. integer :: blocksize = ply_fpt_default_blocksize !> The number of approximation terms to use for blocks apart from the !! diagonal. !! !! This defaults to 18, which is recommended for double precision. integer :: approx_terms = ply_fpt_default_approx_terms !> The implementation variant to use for the transformation computation. !! !! The computation can be done either by a `'vector'` implementation or !! by a `'scalar'` implementation. !! We indicate the respective implementations by the integers !! [[ply_fpt_header_module:ply_fpt_scalar]] or !! [[ply_fpt_header_module:ply_fpt_vector]]. integer :: implementation !> The striplen, that should be used for vectorized simultaneous !! computations of the matrix operation. !! !! This defaults to the vlen from the TEM_compileconf_module, it might !! be set differently here, as we are dealing with a twodimensional !! problem here, and the optimal setting might be different from the code !! parts. integer :: striplen = vlen !> The width of the subblocks used during the unrolled base exchange to !! ensure a better cache usage. !! !! The default is a subblocking width of 8. integer :: subblockingWidth = ply_fpt_default_subblockingWidth !> Should the oversampling factor be adapted to ensure a power of 2 !! in the oversampled polynomial? !! !! If this is true, the factor will be increased to ensure !! an oversampled representation with a power of 2. !! Default is false. logical :: adapt_factor_pow2 = . false . end type ply_fpt_header_type interface assignment ( = ) module procedure Copy_fpt_header end interface interface operator ( == ) module procedure isEqual end interface interface operator ( /= ) module procedure isUnequal end interface interface operator ( < ) module procedure isSmaller end interface interface operator ( <= ) module procedure isSmallerOrEqual end interface interface operator ( > ) module procedure isGreater end interface interface operator ( >= ) module procedure isGreaterOrEqual end interface public :: operator ( == ), operator ( /= ), operator ( < ), operator ( <= ) public :: operator ( > ), operator ( >= ) public :: ply_fpt_header_load , ply_fpt_header_display public :: ply_fpt_header_define public :: ply_fpt_header_type public :: ply_fpt_header_out public :: assignment ( = ) contains ! ------------------------------------------------------------------------ ! !> Copy the FPT header information. pure subroutine Copy_fpt_header ( left , right ) ! -------------------------------------------------------------------- ! !> fpt to copy to type ( ply_Fpt_header_type ), intent ( out ) :: left !> fpt to copy from type ( ply_Fpt_header_type ), intent ( in ) :: right ! -------------------------------------------------------------------- ! left % nodes_header = right % nodes_header left % factor = right % factor left % blocksize = right % blocksize left % adapt_factor_pow2 = right % adapt_factor_pow2 left % approx_terms = right % approx_terms left % implementation = right % implementation left % striplen = right % striplen left % subblockingWidth = right % subblockingWidth end subroutine Copy_fpt_header ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Read the FPT configuration options from the provided Lua script in !! `conf`. subroutine ply_fpt_header_load ( me , conf , thandle ) ! -------------------------------------------------------------------- ! type ( ply_fpt_header_type ), intent ( out ) :: me type ( flu_State ), intent ( inout ) :: conf integer , intent ( in ) :: thandle ! -------------------------------------------------------------------- ! integer :: iError character ( len = labelLen ) :: impl_variant ! -------------------------------------------------------------------- ! ! check for fpt lib ! for fpt chebyshev nodes are used me % nodes_header % nodes_kind = 'chebyshev' ! fill up the fpt_header call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'blocksize' , & & val = me % blocksize , & & default = ply_fpt_default_blocksize , & & ErrCode = iError ) if ( me % blocksize <= 0 ) then write ( logUnit ( 1 ), * ) 'ERROR in loading projection: blocksize for FPT has' & & // ' to be larger than 0!' write ( logUnit ( 1 ), * ) 'But it is set to ' , me % blocksize call tem_abort () end if call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'factor' , & & val = me % factor , & & default = 1.0_rk , & & ErrCode = iError ) if ( me % factor <= 0 ) then write ( logUnit ( 1 ), * ) 'ERROR in loading projection: factor for projection' & & // ' has to be larger than 0!' write ( logUnit ( 1 ), * ) 'But it is set to ' , me % factor call tem_abort () end if call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'approx_terms' , & & val = me % approx_terms , & & ErrCode = iError , & & default = ply_fpt_default_approx_terms ) call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'implementation' , & & val = impl_variant , & & ErrCode = iError , & & default = 'scalar' ) impl_variant = upper_to_lower ( impl_variant ) impl_variant = adjustl ( impl_variant ) select case ( trim ( impl_variant )) case ( 'scalar' ) me % implementation = ply_fpt_scalar case ( 'vector' ) me % implementation = ply_fpt_vector case default write ( logUnit ( 1 ), * ) 'ERROR in loading projection: implementation' & & // ' has to be either \"scalar\" or \"vector\"!' write ( logUnit ( 1 ), * ) 'But it is set to ' , trim ( impl_variant ) call tem_abort () end select call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'striplen' , & & val = me % striplen , & & ErrCode = iError , & & default = vlen ) call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'subblockingWidth' , & & val = me % subblockingWidth , & & ErrCode = iError , & & default = ply_fpt_default_subblockingWidth ) write ( logUnit ( 1 ), * ) 'subblockingWidth = ' , me % subblockingWidth call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'adapt_factor_pow2' , & & val = me % adapt_factor_pow2 , & & ErrCode = iError , & & default = . false . ) ! check for lobatto Points call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'lobattoPoints' , & & val = me % nodes_header % lobattoPoints , & & ErrCode = iError , & & default = . false . ) end subroutine ply_fpt_header_load ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Define settings for the Fast Polynomial Transformation. subroutine ply_fpt_header_define ( & & me , blocksize , factor , approx_terms , implementation , striplen , & & subBlockingWidth , adapt_factor_pow2 , lobattoPoints ) ! -------------------------------------------------------------------- ! !> FPT header to hold the defined settings. type ( ply_fpt_header_type ), intent ( out ) :: me !> Blocksize to use in approximation algorithm. Defaults to !! [[ply_fpt_header_module:ply_fpt_default_blocksize]]. integer , optional , intent ( in ) :: blocksize !> Oversampling factor to use. !! !! This can be used to reduce aliasing when projecting functions that !! will be truncated in the polynomial series expansion. !! Default is a factor of 1, so no oversampling. real ( kind = rk ), optional , intent ( in ) :: factor !> Number of approximation terms to use for the representation of the !! blocks in the Legendre to Chebyshev transformation algorithm. !! Defaults to [[ply_fpt_header_module:ply_fpt_default_approx_terms]]. integer , optional , intent ( in ) :: approx_terms !> Implementation to use in the computation. !! !! Select the implementation variant to use. Either scalar !! ([[ply_fpt_header_module:ply_fpt_scalar]]) or vectorized !! ([[ply_fpt_header_module:ply_fpt_vector]]). !! Default is [[ply_fpt_header_module:ply_fpt_scalar]]. integer , optional , intent ( in ) :: implementation !> Length of strips to use in the transformation implementation. !! Defaults to [[tem_compileconf_module:vlen]]. integer , optional , intent ( in ) :: striplen !> Width for subblocks in unrolling the approximate Legendre to !! Chebyshev transformation. Defaults to !! [[ply_fpt_header_module:ply_fpt_default_subblockingWidth]]. integer , optional , intent ( in ) :: subBlockingWidth !> Adapt the oversampling factor such, that oversampled space has a !! number of degrees of freedoms in one direction that is a power of 2. !! Default is .false.. logical , optional , intent ( in ) :: adapt_factor_pow2 !> Wether to use Chebyshev-Lobatto points (include boundary points) or !! not. Defaults to .false.. logical , optional , intent ( in ) :: lobattoPoints ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! ! for fpt chebyshev nodes are used me % nodes_header % nodes_kind = 'chebyshev' ! Defaults me % blocksize = ply_fpt_default_blocksize me % factor = 1.0_rk me % approx_terms = ply_fpt_default_approx_terms me % implementation = ply_fpt_scalar me % striplen = vlen me % subBlockingWidth = ply_fpt_default_subblockingWidth me % adapt_factor_pow2 = . false . me % nodes_header % lobattoPoints = . false . ! Overwrite defaults if set by caller. if ( present ( blocksize )) me % blocksize = blocksize if ( present ( factor )) me % factor = factor if ( present ( approx_terms )) me % approx_terms = approx_terms if ( present ( implementation )) me % implementation = implementation if ( present ( striplen )) me % striplen = striplen if ( present ( subBlockingWidth )) me % subBlockingWidth = subBlockingWidth if ( present ( adapt_factor_pow2 )) me % adapt_factor_pow2 = adapt_factor_pow2 if ( present ( lobattoPoints )) me % nodes_header % lobattoPoints = lobattoPoints if ( me % factor <= 0 ) then write ( logUnit ( 1 ), * ) 'ERROR in defining projection: factor for projection' & & // ' has to be larger than 0!' write ( logUnit ( 1 ), * ) 'But it is set to ' , me % factor call tem_abort () end if if ( me % implementation /= ply_fpt_scalar & & . and . me % implementation /= ply_fpt_vector ) then write ( logUnit ( 1 ), * ) 'ERROR in defining projection: implementation' & & // ' has to be either \"scalar\" or \"vector\"!' write ( logUnit ( 1 ), * ) 'But it is set to unknown value ' , me % implementation call tem_abort () end if end subroutine ply_fpt_header_define ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Write FPT settings into a Lua table. subroutine ply_fpt_header_out ( me , conf ) ! -------------------------------------------------------------------- ! type ( ply_fpt_header_type ), intent ( in ) :: me type ( aot_out_type ), intent ( inout ) :: conf ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! ! fill up the fpt_header call aot_out_val ( put_conf = conf , & & vname = 'blocksize' , & & val = me % blocksize ) call aot_out_val ( put_conf = conf , & & vname = 'factor' , & & val = me % factor ) call aot_out_val ( put_conf = conf , & & vname = 'approx_terms' , & & val = me % approx_terms ) select case ( me % implementation ) case ( ply_fpt_scalar ) call aot_out_val ( put_conf = conf , & & vname = 'implementation' , & & val = 'scalar' ) case ( ply_fpt_vector ) call aot_out_val ( put_conf = conf , & & vname = 'implementation' , & & val = 'vector' ) end select call aot_out_val ( put_conf = conf , & & vname = 'striplen' , & & val = me % striplen ) call aot_out_val ( put_conf = conf , & & vname = 'subblockingWidth' , & & val = me % subblockingWidth ) call aot_out_val ( put_conf = conf , & & vname = 'adapt_factor_pow2' , & & val = me % adapt_factor_pow2 ) call aot_out_val ( put_conf = conf , & & vname = 'lobattoPoints' , & & val = me % nodes_header % lobattoPoints ) end subroutine ply_fpt_header_out ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Print the FPT settings to the log output. subroutine ply_fpt_header_display ( me ) ! -------------------------------------------------------------------- ! type ( ply_fpt_header_type ), intent ( in ) :: me ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! write ( logUnit ( 1 ), * ) ' Using fast polynomial transforms for projection.' write ( logUnit ( 1 ), * ) write ( logUnit ( 1 ), * ) ' * Kind of projection method = fpt' write ( logUnit ( 1 ), * ) ' * Dealising factor to use in projection = ' , & & me % factor write ( logUnit ( 1 ), * ) ' * Adapt factor to ensure power of 2 order = ' , & & me % adapt_factor_pow2 write ( logUnit ( 3 ), * ) '     This setting is only relevant for' & & // ' polynomial degrees < 2*blocksize.' write ( logUnit ( 1 ), * ) ' * using LobattoPoints =' , & & me % nodes_header % lobattoPoints if ( me % implementation == ply_fpt_scalar ) then write ( logUnit ( 1 ), * ) ' * Using scalar implementation' else write ( logUnit ( 1 ), * ) ' * Using VECTOR implementation' end if write ( logUnit ( 1 ), * ) ' * Block approximation:' write ( logUnit ( 1 ), * ) '   * Blocksize for FPT =' , me % blocksize write ( logUnit ( 1 ), * ) '   * Number of approximation terms = ' , me % approx_terms write ( logUnit ( 1 ), * ) '   * Strip length = ' , me % striplen write ( logUnit ( 1 ), * ) '   * Subblocking width = ' , me % subblockingWidth write ( logUnit ( 1 ), * ) '' end subroutine ply_fpt_header_display ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides the test for equality of two projections. !! !! Two fpt header are considered to be equal, if their  node_header, !! fpt_blocksize or the factor are equal. pure function isEqual ( left , right ) result ( equality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fpt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fpt_header_type ), intent ( in ) :: right !> is equal?? logical :: equality ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! equality = ( left % nodes_header == right % nodes_header ) & & . and . ( left % factor . feq . right % factor ) & & . and . ( left % blocksize == right % blocksize ) & & . and . ( left % approx_terms == right % approx_terms ) & & . and . ( left % striplen == right % striplen ) & & . and . ( left % subblockingWidth == right % subblockingWidth ) & & . and . ( left % adapt_factor_pow2 . eqv . right % adapt_factor_pow2 ) end function isEqual ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides the test for unequality of two projections. !! !! Two fpt header are considered to be unequal, if their  node_header, !! fpt_blocksize or the factor are not equal. pure function isUnequal ( left , right ) result ( unequality ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fpt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fpt_header_type ), intent ( in ) :: right !> is unequal?? logical :: unequality ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! unequality = ( left % nodes_header /= right % nodes_header ) & & . or . ( left % factor . fne . right % factor ) & & . or . ( left % blocksize /= right % blocksize ) & & . or . ( left % approx_terms /= right % approx_terms ) & & . or . ( left % striplen /= right % striplen ) & & . or . ( left % subblockingWidth /= right % subblockingWidth ) & & . or . ( left % adapt_factor_pow2 . neqv . right % adapt_factor_pow2 ) end function isUnequal ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a < comparison of two projections. !! !! Sorting of fpt header is given by node_header, fpt_blocksize and !! last by factor. pure function isSmaller ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fpt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fpt_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! !> help variables integer :: left_log , right_log ! -------------------------------------------------------------------- ! small = . false . if ( left % adapt_factor_pow2 ) then left_log = 1 else left_log = 0 end if if ( right % adapt_factor_pow2 ) then right_log = 1 else right_log = 0 end if small = left % nodes_header < right % nodes_header if ( left % nodes_header == right % nodes_header ) then small = left % factor < right % factor if ( left % factor . feq . right % factor ) then small = left % blocksize < right % blocksize if ( left % blocksize == right % blocksize ) then small = left % approx_terms < right % approx_terms if ( left % approx_terms == right % approx_terms ) then small = left % striplen < right % striplen if ( left % striplen == right % striplen ) then small = left % subblockingWidth < right % subblockingWidth if ( left % subblockingWidth == right % subblockingWidth ) then small = ( left_log < right_log ) end if end if end if end if end if end if end function isSmaller ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a <= comparison of two projections. !! !! Sorting of fpt header is given by node_header, fpt_blocksize and !! last by factor. pure function isSmallerOrEqual ( left , right ) result ( small ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fpt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fpt_header_type ), intent ( in ) :: right !> is smaller?? logical :: small ! -------------------------------------------------------------------- ! !> help variables integer :: left_log , right_log ! -------------------------------------------------------------------- ! small = . false . if ( left % adapt_factor_pow2 ) then left_log = 1 else left_log = 0 end if if ( right % adapt_factor_pow2 ) then right_log = 1 else right_log = 0 end if small = left % nodes_header < right % nodes_header if ( left % nodes_header == right % nodes_header ) then small = left % factor < right % factor if ( left % factor . feq . right % factor ) then small = left % blocksize < right % blocksize if ( left % blocksize == right % blocksize ) then small = left % approx_terms < right % approx_terms if ( left % approx_terms == right % approx_terms ) then small = left % striplen < right % striplen if ( left % striplen == right % striplen ) then small = left % subblockingWidth < right % subblockingWidth if ( left % subblockingWidth == right % subblockingWidth ) then small = ( left_log <= right_log ) end if end if end if end if end if end if end function isSmallerOrEqual ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a > comparison of two projections. !! !! Sorting of fpt header is given by node_header, fpt_blocksize and !! last by factor. pure function isGreater ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fpt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fpt_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! !> help variables integer :: left_log , right_log ! -------------------------------------------------------------------- ! great = . false . if ( left % adapt_factor_pow2 ) then left_log = 1 else left_log = 0 end if if ( right % adapt_factor_pow2 ) then right_log = 1 else right_log = 0 end if great = left % nodes_header > right % nodes_header if ( left % nodes_header == right % nodes_header ) then great = left % factor > right % factor if ( left % factor . feq . right % factor ) then great = left % blocksize > right % blocksize if ( left % blocksize == right % blocksize ) then great = left % approx_terms > right % approx_terms if ( left % approx_terms == right % approx_terms ) then great = left % striplen > right % striplen if ( left % striplen == right % striplen ) then great = left % subblockingWidth > right % subblockingWidth if ( left % subblockingWidth == right % subblockingWidth ) then great = ( left_log > right_log ) end if end if end if end if end if end if end function isGreater ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function provides a >= comparison of two projections. !! !! Sorting of fpt header is given by node_header, fpt_blocksize and !! last by factor. pure function isGreaterOrEqual ( left , right ) result ( great ) ! -------------------------------------------------------------------- ! !> projection to compare type ( ply_fpt_header_type ), intent ( in ) :: left !> projection to compare against type ( ply_fpt_header_type ), intent ( in ) :: right !> is greater?? logical :: great ! -------------------------------------------------------------------- ! !> help variables integer :: left_log , right_log ! -------------------------------------------------------------------- ! great = . false . if ( left % adapt_factor_pow2 ) then left_log = 1 else left_log = 0 end if if ( right % adapt_factor_pow2 ) then right_log = 1 else right_log = 0 end if great = left % nodes_header > right % nodes_header if ( left % nodes_header == right % nodes_header ) then great = left % factor > right % factor if ( left % factor . feq . right % factor ) then great = left % blocksize > right % blocksize if ( left % blocksize == right % blocksize ) then great = left % approx_terms > right % approx_terms if ( left % approx_terms == right % approx_terms ) then great = left % striplen > right % striplen if ( left % striplen == right % striplen ) then great = left % subblockingWidth > right % subblockingWidth if ( left % subblockingWidth == right % subblockingWidth ) then great = ( left_log >= right_log ) end if end if end if end if end if end if end function isGreaterOrEqual ! ------------------------------------------------------------------------ ! end module ply_fpt_header_module","tags":"","url":"sourcefile/ply_fpt_header_module.f90.html"},{"title":"ply_legFpt_module.f90 – Seeder","text":"This file depends on sourcefile~~ply_legfpt_module.f90~~EfferentGraph sourcefile~ply_legfpt_module.f90 ply_legFpt_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_legfpt_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2014, 2016, 2018 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2012-2014,2020 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2013-2014, 2017 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2013-2014 Verena Krupp ! Copyright (c) 2016 Langhammer Kay <kay.langhammer@student.uni-siegen.de> ! ! Parts of this file were written by Jens Zudrop and Harald Klimach ! for German Research School for Simulation Sciences GmbH. ! ! Parts of this file were written by Verena Krupp, Harald Klimach, Peter Vitt ! and Kay Langhammer for University of Siegen. ! ! Permission to use, copy, modify, and distribute this software for any ! purpose with or without fee is hereby granted, provided that the above ! copyright notice and this permission notice appear in all copies. ! ! THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHORS DISCLAIM ALL WARRANTIES ! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF ! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES ! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF ! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ! **************************************************************************** ! !> Module providing datatypes and routines for a fast !! transformation of Legendre expansion to point values. !! \\author{Jens Zudrop} module ply_legFpt_module use , intrinsic :: iso_c_binding use env_module , only : rk use tem_compileconf_module , only : vlen use ply_polyBaseExc_module , only : ply_trafo_params_type , & & ply_fpt_init , & & ply_fpt_exec_striped , & & ply_fpt_single , & & ply_legToCheb_param , & & ply_chebToLeg_param , & & assignment ( = ) use ply_fpt_header_module , only : ply_fpt_header_type , & & ply_fpt_scalar , & & ply_fpt_vector use fftw_wrap implicit none private !> Datatype for parameters of the FPT used for 1d, 2d and 3d. !! !! Stores of the parameters for a fast conversion of a modal !! Legendre expansion to point values (located at Chebyshev nodes) !! and vice versa. \\n !! The FPT covers: \\n !! - Transformation from Legendre expansion to point values !!   at Chebyshev nodes \\n !! - Transformation from point values (Chebyshev nodes) to !!   modal Legendre expansion \\n type ply_legFpt_type !> FPT params for the fast base exchange from Legendre to !! Chebyshev expansion. type ( ply_trafo_params_type ) :: legToChebParams !> FPT params for the fast base exchange from Chebyshev to !! Legendre expansion. type ( ply_trafo_params_type ) :: chebToLegParams !> FFTW plan for DCT from Chebyshev coefficients to point values. type ( C_PTR ) :: planChebToPnt !> FFTW plan for DCT from point values to Chebyshev coefficients. type ( C_PTR ) :: planPntToCheb !> Flag whether to use Lobatto points (include boundary points) logical :: use_lobatto_points procedure ( ply_fptm2n ), pointer :: legtopnt => NULL () procedure ( ply_fptn2m ), pointer :: pnttoleg => NULL () end type ply_legFpt_type interface assignment ( = ) module procedure Copy_fpt end interface public :: ply_legFpt_type , ply_init_legFpt public :: assignment ( = ) interface subroutine ply_fptm2n ( fpt , legCoeffs , pntVal , nIndeps ) import :: ply_legFpt_type , rk real ( kind = rk ), intent ( inout ) :: legCoeffs (:) class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) integer , intent ( in ) :: nIndeps end subroutine subroutine ply_fptn2m ( fpt , pntVal , legCoeffs , nIndeps ) import :: ply_legFpt_type , rk real ( kind = rk ), intent ( inout ) :: pntVal (:) class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: legCoeffs (:) integer , intent ( in ) :: nIndeps end subroutine end interface contains ! ------------------------------------------------------------------------ ! subroutine Copy_fpt ( left , right ) ! -------------------------------------------------------------------- ! !> fpt to copy to type ( ply_legFpt_type ), intent ( out ) :: left !> fpt to copy from type ( ply_legFpt_type ), intent ( in ) :: right ! -------------------------------------------------------------------- ! left % legToChebParams = right % legToChebParams left % chebToLegParams = right % chebToLegParams left % planChebToPnt = right % planChebToPnt left % planPntToCheb = right % planPntToCheb left % legtopnt => right % legtopnt left % pnttoleg => right % pnttoleg end subroutine Copy_fpt ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Subroutine to initialize the fast polynomial transformation !! for Legendre expansion. subroutine ply_init_legFpt ( maxPolyDegree , nIndeps , fpt , header , fft_flags ) ! -------------------------------------------------------------------- ! !> Maximal polynomial degree for the transformation. integer , intent ( in ) :: maxPolyDegree !> Number of independent values that can be computed simultaneously. integer , intent ( in ) :: nIndeps !> The Fast Polynomial Transformation setting to initialize. type ( ply_legFpt_type ), intent ( inout ) :: fpt !> Configuration settings for the projection. type ( ply_fpt_header_type ), intent ( in ) :: header !> Planning flags for the FFT. !! !! Configuration to how much time to spend on finding an optimal FFT !! implementation in the FFTW. !! See: http://www.fftw.org/doc/Planner-Flags.html#Planner-Flags !! !! Defaults to FFTW_MEASURE. integer , optional , intent ( in ) :: fft_flags ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: tmpOut (:), tmpIn (:) logical :: lob integer :: n integer :: maxstriplen integer :: planning_flags ! -------------------------------------------------------------------- ! if ( present ( fft_flags )) then planning_flags = fft_flags else planning_flags = FFTW_MEASURE end if maxstriplen = min ( header % striplen , nIndeps ) lob = header % nodes_header % lobattoPoints fpt % use_lobatto_points = lob ! Init the fast Legendre to Chebyshev transformation. call ply_fpt_init ( n = maxPolyDegree + 1 , & & params = fpt % legToChebParams , & & trafo = ply_legToCheb_param , & & blocksize = header % blocksize , & & approx_terms = header % approx_terms , & & striplen = maxstriplen , & & subblockingWidth = header % subblockingWidth ) ! Init the fast Chebyshev to Legendre transformation. call ply_fpt_init ( n = maxPolyDegree + 1 , & & params = fpt % chebToLegParams , & & trafo = ply_chebToLeg_param , & & blocksize = header % blocksize , & & approx_terms = header % approx_terms , & & striplen = maxstriplen , & & subblockingWidth = header % subblockingWidth ) ! Create the buffers for the intermediate arrays n = fpt % legToChebParams % n ! Temporary arrays to initialize FFTW real->real transformations select case ( header % implementation ) case ( ply_fpt_scalar ) allocate ( tmpIn ( n ) ) allocate ( tmpOut ( n ) ) case ( ply_fpt_vector ) allocate ( tmpIn ( n * nIndeps ) ) allocate ( tmpOut ( n * nIndeps ) ) end select if (. not . lob ) then select case ( header % implementation ) case ( ply_fpt_scalar ) fpt % legtopnt => ply_legtopnt_single fpt % pnttoleg => ply_pnttoleg_single ! Init the DCT III ( Leg -> Point values ) !NEC: The NEC FFTW interface use n0 as parameter name instead of n !NEC: (nlc 2.0.0). !NEC: Omitting keywords to be compatible. !!fpt%planPntToCheb = fftw_plan_r2r_1d( n     = n,             & !!  &                                   in    = tmpIn,         & !!  &                                   out   = tmpOut,        & !!  &                                   kind  = FFTW_REDFT10,  & !!  &                                   flags = planning_flags ) fpt % planChebToPnt = fftw_plan_r2r_1d ( n , & & tmpIn , & & tmpOut , & & FFTW_REDFT01 , & & planning_flags ) ! Init the DCT II ( Point values -> Leg ) !NEC: The NEC FFTW interface use n0 as parameter name instead of n !NEC: (nlc 2.0.0). !NEC: Omitting keywords to be compatible. !!fpt%planPntToCheb = fftw_plan_r2r_1d( n     = n,             & !!  &                                   in    = tmpIn,         & !!  &                                   out   = tmpOut,        & !!  &                                   kind  = FFTW_REDFT10,  & !!  &                                   flags = planning_flags ) fpt % planPntToCheb = fftw_plan_r2r_1d ( n , & & tmpIn , & & tmpOut , & & FFTW_REDFT10 , & & planning_flags ) case ( ply_fpt_vector ) fpt % legtopnt => ply_legtopnt_vec fpt % pnttoleg => ply_pnttoleg_vec fpt % planChebToPnt = fftw_plan_many_r2r ( & & rank = 1 , & & n = [ n ], & & howmany = nIndeps , & & in = tmpIn , & & inembed = [ n ], & & istride = 1 , & & idist = n , & & out = tmpOut , & & onembed = [ n ], & & ostride = 1 , & & odist = n , & & kind = [ FFTW_REDFT01 ], & & flags = planning_flags ) fpt % planPntToCheb = fftw_plan_many_r2r ( & & rank = 1 , & & n = [ n ], & & howmany = nIndeps , & & in = tmpIn , & & inembed = [ n ], & & istride = 1 , & & idist = n , & & out = tmpOut , & & onembed = [ n ], & & ostride = 1 , & & odist = n , & & kind = [ FFTW_REDFT10 ], & & flags = planning_flags ) end select else select case ( header % implementation ) case ( ply_fpt_scalar ) fpt % legtopnt => ply_legtopnt_lobatto_single fpt % pnttoleg => ply_pnttoleg_lobatto_single ! Init the DCT I  (Leg -> nodal): !   To be used with a normalization factor for trafo ... !NEC: The NEC FFTW interface use n0 as parameter name instead of n !NEC: (nlc 2.0.0). !NEC: Omitting keywords to be compatible. !!fpt%planChebToPnt = fftw_plan_r2r_1d( n     = n,             & !!  &                                   in    = tmpIn,         & !!  &                                   out   = tmpOut,        & !!  &                                   kind  = FFTW_REDFT00,  & !!  &                                   flags = planning_flags ) fpt % planChebToPnt = fftw_plan_r2r_1d ( n , & & tmpIn , & & tmpOut , & & FFTW_REDFT00 , & & planning_flags ) case ( ply_fpt_vector ) fpt % legtopnt => ply_legtopnt_lobatto_vec fpt % pnttoleg => ply_pnttoleg_lobatto_vec fpt % planChebToPnt = fftw_plan_many_r2r ( & & rank = 1 , & & n = [ n ], & & howmany = nIndeps , & & in = tmpIn , & & inembed = [ n ], & & istride = 1 , & & idist = n , & & out = tmpOut , & & onembed = [ n ], & & ostride = 1 , & & odist = n , & & kind = [ FFTW_REDFT00 ], & & flags = planning_flags ) end select ! Init the DCT I  (nodal -> Leg): !   To be used with a normalization factor for trafo ... fpt % planPntToCheb = fpt % planChebToPnt end if deallocate ( tmpIn , tmpOut ) end subroutine ply_init_legFpt ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Subroutine to transform Legendre expansion to point values !! at Chebyshev nodes. subroutine ply_legToPnt_single ( fpt , legCoeffs , pntVal , nIndeps ) ! -------------------------------------------------------------------- ! real ( kind = rk ), intent ( inout ) :: legCoeffs (:) class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n ) integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n do iDof = 1 , nIndeps * n , n call ply_fpt_single ( alph = legCoeffs ( iDof : iDof + n - 1 ), & & gam = cheb , & & params = fpt % legToChebParams ) ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( 2 : n : 2 ) = - 0.5_rk * cheb ( 2 : n : 2 ) cheb ( 3 : n : 2 ) = 0.5_rk * cheb ( 3 : n : 2 ) call fftw_execute_r2r ( fpt % planChebToPnt , & & cheb , & & pntVal ( iDof : iDof + n - 1 ) ) end do end subroutine ply_legToPnt_single ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Vectorizing subroutine to transform Legendre expansion to point values !! at Chebyshev nodes. subroutine ply_legToPnt_vec ( fpt , legCoeffs , pntVal , nIndeps ) ! -------------------------------------------------------------------- ! real ( kind = rk ), intent ( inout ) :: legCoeffs (:) class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n * nIndeps ) integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n call ply_fpt_exec_striped ( nIndeps = nIndeps , & & alph = legCoeffs , & & gam = cheb , & & params = fpt % legToChebParams ) do iDof = 1 , nIndeps * n , n ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( iDof + 1 : n + iDof - 1 : 2 ) = - 0.5_rk * cheb ( iDof + 1 : n + iDof - 1 : 2 ) cheb ( iDof + 2 : n + iDof - 1 : 2 ) = 0.5_rk * cheb ( iDof + 2 : n + iDof - 1 : 2 ) end do call fftw_execute_r2r ( fpt % planChebToPnt , & & cheb , & & pntVal ) end subroutine ply_legToPnt_vec ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Subroutine to transform Legendre expansion to point values !! at Chebyshev-Lobatto nodes. subroutine ply_legToPnt_lobatto_single ( fpt , legCoeffs , pntVal , nIndeps ) ! -------------------------------------------------------------------- ! real ( kind = rk ), intent ( inout ) :: legCoeffs (:) class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n ) integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n do iDof = 1 , nIndeps * n , n call ply_fpt_single ( alph = legCoeffs ( iDof : iDof + n - 1 ), & & gam = cheb , & & params = fpt % legToChebParams ) ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( 2 : n - 1 ) = 0.5_rk * cheb ( 2 : n - 1 ) call fftw_execute_r2r ( fpt % planChebToPnt , & & cheb , & & pntVal ( iDof : iDof + n - 1 ) ) end do end subroutine ply_legToPnt_lobatto_single ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Vectorizing subroutine to transform Legendre expansion to point values !! at Chebyshev-Lobatto nodes. subroutine ply_legToPnt_lobatto_vec ( fpt , legCoeffs , pntVal , nIndeps ) ! -------------------------------------------------------------------- ! real ( kind = rk ), intent ( inout ) :: legCoeffs (:) class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n * nIndeps ) integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n call ply_fpt_exec_striped ( nIndeps = nIndeps , & & alph = legCoeffs , & & gam = cheb , & & params = fpt % legToChebParams ) do iDof = 1 , nIndeps * n , n ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( iDof + 1 : n + iDof - 2 ) = 0.5_rk * cheb ( iDof + 1 : n + iDof - 2 ) end do call fftw_execute_r2r ( fpt % planChebToPnt , & & cheb , & & pntVal ) end subroutine ply_legToPnt_lobatto_vec ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Subroutine to transform point values at Chebyshev nodes to a Legendre !! expansion. subroutine ply_pntToLeg_single ( fpt , pntVal , legCoeffs , nIndeps ) ! -------------------------------------------------------------------- ! class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) real ( kind = rk ), intent ( inout ) :: legCoeffs (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n ) real ( kind = rk ) :: normFactor integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n normFactor = 1.0_rk / real ( n , kind = rk ) do iDof = 1 , nIndeps * n , n call fftw_execute_r2r ( fpt % planPntToCheb , & & pntVal ( iDof : iDof + n - 1 ), & & cheb ) ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( 1 ) = cheb ( 1 ) * 0.5_rk * normfactor cheb ( 2 : n : 2 ) = - normFactor * cheb ( 2 : n : 2 ) cheb ( 3 : n : 2 ) = normFactor * cheb ( 3 : n : 2 ) call ply_fpt_single ( gam = legCoeffs ( iDof : iDof + n - 1 ), & & alph = cheb , & & params = fpt % ChebToLegParams ) end do end subroutine ply_pntToLeg_single ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Vectorizing subroutine to transform point values at Chebyshev nodes to a !! Legendre expansion. subroutine ply_pntToLeg_vec ( fpt , pntVal , legCoeffs , nIndeps ) ! -------------------------------------------------------------------- ! class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) real ( kind = rk ), intent ( inout ) :: legCoeffs (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n * nIndeps ) real ( kind = rk ) :: normFactor integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n call fftw_execute_r2r ( fpt % planPntToCheb , & & pntVal , & & cheb ) normFactor = 1.0_rk / real ( n , kind = rk ) do iDof = 1 , nIndeps * n , n ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( iDof ) = cheb ( iDof ) * 0.5_rk * normfactor cheb ( iDof + 1 : iDof + n - 1 : 2 ) = - normFactor * cheb ( iDof + 1 : iDof + n - 1 : 2 ) cheb ( iDof + 2 : iDof + n - 1 : 2 ) = normFactor * cheb ( iDof + 2 : iDof + n - 1 : 2 ) end do call ply_fpt_exec_striped ( nIndeps = nIndeps , & & alph = cheb , & & gam = legCoeffs , & & params = fpt % ChebToLegParams ) end subroutine ply_pntToLeg_vec ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Subroutine to transform point values at Chebyshev-Lobatto nodes to a !! Legendre expansion. subroutine ply_pntToLeg_lobatto_single ( fpt , pntVal , legCoeffs , nIndeps ) ! -------------------------------------------------------------------- ! class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) real ( kind = rk ), intent ( inout ) :: legCoeffs (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n ) real ( kind = rk ) :: normFactor integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n normFactor = 0.5_rk / real ( n - 1 , kind = rk ) do iDof = 1 , nIndeps * n , n call fftw_execute_r2r ( fpt % planPntToCheb , & & pntVal ( iDof : iDof + n - 1 ), & & cheb ) ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( 1 ) = cheb ( 1 ) * normFactor cheb ( 2 : n - 1 ) = 2.0_rk * normFactor * cheb ( 2 : n - 1 ) cheb ( n ) = cheb ( n ) * normFactor call ply_fpt_single ( gam = legCoeffs ( iDof : iDof + n - 1 ), & & alph = cheb , & & params = fpt % ChebToLegParams ) end do end subroutine ply_pntToLeg_lobatto_single ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Vectorizing subroutine to transform point values at Chebyshev-Lobatto !! nodes to a Legendre expansion. subroutine ply_pntToLeg_lobatto_vec ( fpt , pntVal , legCoeffs , nIndeps ) ! -------------------------------------------------------------------- ! class ( ply_legFpt_type ), intent ( inout ) :: fpt real ( kind = rk ), intent ( inout ) :: pntVal (:) real ( kind = rk ), intent ( inout ) :: legCoeffs (:) integer , intent ( in ) :: nIndeps ! -------------------------------------------------------------------- ! real ( kind = rk ) :: cheb ( fpt % legToChebParams % n * nIndeps ) real ( kind = rk ) :: normFactor integer :: iDof integer :: n ! -------------------------------------------------------------------- ! n = fpt % legToChebParams % n call fftw_execute_r2r ( fpt % planPntToCheb , & & pntVal , & & cheb ) normFactor = 0.5_rk / real ( n - 1 , kind = rk ) do iDof = 1 , nIndeps * n , n ! Normalize the coefficients of the Chebyshev polynomials due ! to the unnormalized version of DCT in the FFTW. cheb ( iDof ) = cheb ( iDof ) * normFactor cheb ( iDof + 1 : iDof + n - 2 ) = 2.0_rk * normFactor * cheb ( iDof + 1 : iDof + n - 2 ) cheb ( iDof + n - 1 ) = cheb ( iDof + n - 1 ) * normFactor end do call ply_fpt_exec_striped ( nIndeps = nIndeps , & & alph = cheb , & & gam = legCoeffs , & & params = fpt % ChebToLegParams ) end subroutine ply_pntToLeg_lobatto_vec ! ------------------------------------------------------------------------ ! end module ply_legFpt_module","tags":"","url":"sourcefile/ply_legfpt_module.f90.html"},{"title":"sdr_hvs_props_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_hvs_props_module.f90~~EfferentGraph sourcefile~sdr_hvs_props_module.f90 sdr_hvs_props_module.f90 sourcefile~ply_subresolution_module.f90 ply_subresolution_module.f90 sourcefile~sdr_hvs_props_module.f90->sourcefile~ply_subresolution_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_hvs_props_module.f90~~AfferentGraph sourcefile~sdr_hvs_props_module.f90 sdr_hvs_props_module.f90 sourcefile~sdr_harvesting.f90 sdr_harvesting.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_props_module.f90 sourcefile~sdr_hvs_config_module.f90 sdr_hvs_config_module.f90 sourcefile~sdr_harvesting.f90->sourcefile~sdr_hvs_config_module.f90 sourcefile~sdr_hvs_config_module.f90->sourcefile~sdr_hvs_props_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> This module describes the properties in a treelmesh to allow their output. module sdr_hvs_props_module use , intrinsic :: iso_c_binding , only : c_loc , c_f_pointer use env_module , only : rk use treelmesh_module , only : treelmesh_type use tem_bc_prop_module , only : tem_bc_prop_type , init_tem_bc_prop use tem_color_prop_module , only : tem_color_prop_type , & & tem_color_prop_load , & & colors_per_char use tem_comm_env_module , only : tem_comm_env_type use tem_logging_module , only : logunit use tem_time_module , only : tem_time_type use tem_varsys_module , only : tem_varSys_proc_element , & & tem_varSys_proc_point , & & tem_varSys_proc_getParams , & & tem_varSys_proc_setupIndices , & & tem_varSys_proc_getValOfIndex , & & tem_varsys_append_dervar , & & tem_varSys_type , tem_varSys_op_type , & & tem_varSys_getParams_dummy use ply_dof_module , only : Q_space use ply_subresolution_module , only : ply_subresolution_type , & & ply_subresolution_load , & & ply_subres_import_color , & & ply_subres_get_elemcolor , & & ply_subres_colvar_type implicit none private !> Auxilary data type to allow an array of pointers to colvar objects. type sdr_hvs_colvar_ptr_type type ( ply_subres_colvar_type ), pointer :: p => NULL () procedure ( tem_varSys_proc_element ), nopass , pointer :: get_element end type sdr_hvs_colvar_ptr_type !> Datatype to collect the various properties of the mesh. type sdr_hvs_props_type !> Property describing the boundary conditions in the mesh. type ( tem_bc_prop_type ), pointer :: bc => NULL () !> Property describing the coloring of the mesh. type ( tem_color_prop_type ), pointer :: color => NULL () !> Additional color distribution information via subresolution. type ( ply_subresolution_type ), pointer :: subres => NULL () !> Description of color variables. type ( sdr_hvs_colVar_ptr_type ), allocatable :: colorVar (:) !> Position in the variables for each color. !! !! If a color was not added as variable, the entry will be negative. !! This is useful to iterate through all colors, that were actually added !! as variables. integer , allocatable :: colorvarpos (:) end type sdr_hvs_props_type public :: sdr_hvs_props_type public :: sdr_hvs_props_load public :: sdr_hvs_props_import_dofs contains !----------------------------------------------------------------------------! !> Load the properties from the mesh. subroutine sdr_hvs_props_load ( me , varsys , mesh , proc ) !> Properties to load. type ( sdr_hvs_props_type ), intent ( out ) :: me !> A variable system, to which the colors should be appended. type ( tem_varsys_type ), intent ( inout ) :: varsys !> Mesh to load the properties for. type ( treelmesh_type ), intent ( in ) :: mesh !> Process description for MPI-IO type ( tem_comm_env_type ), intent ( in ) :: proc !----------------------------------------------------------------------! integer :: iCol logical :: wasAdded procedure ( tem_varSys_proc_element ), pointer :: get_element => NULL () procedure ( tem_varSys_proc_point ), pointer :: get_point => NULL () procedure ( tem_varSys_proc_getParams ), pointer :: get_params => NULL () procedure ( tem_varSys_proc_setupIndices ), pointer :: setup_indices => NULL () procedure ( tem_varSys_proc_getValOfIndex ), pointer :: get_valOfIndex & & => NULL () !----------------------------------------------------------------------! write ( logunit ( 1 ), '(a)' ) 'Loading mesh properties...' call sdr_hvs_props_clean ( me ) allocate ( me % bc ) allocate ( me % color ) allocate ( me % subres ) write ( logunit ( 5 ), '(a)' ) 'Init tem BC prop' call init_tem_bc_prop ( tree = mesh , & & myPart = proc % rank , & & comm = proc % comm , & & bc = me % bc ) write ( logunit ( 5 ), '(a)' ) 'Load color prop' call tem_color_prop_load ( me = me % color , & & tree = mesh , & & myPart = proc % rank , & & comm = proc % comm ) write ( logunit ( 5 ), '(a)' ) 'Load subres prop' call ply_subresolution_load ( me = me % subres , & & tree = mesh , & & proc = proc , & & coloring = me % color ) get_element => ply_subres_get_elemcolor get_params => tem_varSys_getparams_dummy nullify ( get_point ) nullify ( setup_indices ) allocate ( me % colorvar ( me % color % nColors )) allocate ( me % colorvarpos ( me % color % nColors )) write ( logunit ( 1 ), '(a,i0,a)' ) 'Appending ' , me % color % nColors , & & ' to the varsys:' do iCol = 1 , me % color % nColors allocate ( me % colorvar ( iCol )% p ) me % colorvar ( iCol )% p % color => me % color me % colorvar ( iCol )% p % subres => me % subres me % colorvar ( iCol )% p % colpos = iCol call tem_varSys_append_derVar ( & & me = varsys , & & varname = me % color % color_label ( iCol ), & & nComponents = 1 , & & method_data = c_loc ( me % colorvar ( iCol )% p ), & & get_point = get_point , & & get_element = get_element , & & get_params = get_params , & & setup_indices = setup_indices , & & get_valofindex = get_valofindex , & & wasAdded = wasAdded , & & pos = me % colorvarpos ( iCol ) ) if (. not . wasAdded ) then ! The color was not added, due to an already existing variable with the ! same name, issue a warning and mark this color to skip when iterating ! through all colors. me % colorvarpos ( iCol ) = - 1 write ( logunit ( 1 ), * ) 'WARNING: Color ' , & & trim ( me % color % color_label ( iCol )), & & ' was NOT appended!' write ( logunit ( 1 ), * ) 'Colors that have the same name as meshinfos' write ( logunit ( 1 ), * ) 'can not be considered!' write ( logunit ( 1 ), * ) '' write ( logunit ( 1 ), * ) 'Please be aware, that this name will not refer' write ( logunit ( 1 ), * ) 'to the color in the final visualization file!' else write ( logunit ( 1 ), * ) 'Appended Color ' , & & trim ( me % color % color_label ( iCol )), & & ' to the available variables.' end if end do write ( logunit ( 1 ), '(a)' ) '... done loading mesh properties.' end subroutine sdr_hvs_props_load !----------------------------------------------------------------------------! !----------------------------------------------------------------------------! !----------------------------------------------------------------------------! !> Import subresolved color data. subroutine sdr_hvs_props_import_dofs ( me , mesh , proc , maxdegree , ndims ) !> Properties to get the subresolution dofs for. type ( sdr_hvs_props_type ), intent ( inout ) :: me !> Mesh definition, these properties belong to. type ( treelmesh_type ), intent ( in ) :: mesh !> Communicating environment. type ( tem_comm_env_type ), intent ( in ) :: proc !> Maximal polynomial degree to import. !! !! Set to 0, if only the integral mean value is to be loaded. integer , intent ( in ) :: maxdegree !> Dimensions of the polynomials after importing. integer , intent ( in ) :: ndims !----------------------------------------------------------------------! integer :: iColor , cpos !----------------------------------------------------------------------! do iColor = 1 , me % color % nColors cpos = me % colorvarpos ( iColor ) if ( cpos > 0 ) then ! Skip colors that where not added to the list of variables. And only ! process those with a valid variable position. ! Import the subresolution data for each color and store it in the ! subresdat of each variable method data. ! We always use Q_space here. call ply_subres_import_color ( me = me % subres , & & tree = mesh , & & iColor = iColor , & & coloring = me % color , & & target_degree = maxdegree , & & target_space = Q_space , & & target_dim = ndims , & & subresdat = me % colorvar ( iColor ) & & % p % subresdat ) me % colorvar ( iColor )% p % nsubdofs = ( maxdegree + 1 ) ** nDims end if end do end subroutine sdr_hvs_props_import_dofs !----------------------------------------------------------------------------! !----------------------------------------------------------------------------! !----------------------------------------------------------------------------! !> Clean up the properties data type. !! !! Takes care of the pointers, nullifies and deallocates them properly. subroutine sdr_hvs_props_clean ( me ) type ( sdr_hvs_props_type ), intent ( out ) :: me !----------------------------------------------------------------------! integer :: iCol !----------------------------------------------------------------------! if ( allocated ( me % colorvar )) then do iCol = lbound ( me % colorvar , 1 ), ubound ( me % colorvar , 1 ) if ( associated ( me % colorvar ( iCol )% p )) then nullify ( me % colorvar ( iCol )% p % color ) nullify ( me % colorvar ( iCol )% p % subres ) if ( allocated ( me % colorvar ( iCol )% p % subresdat ) ) then deallocate ( me % colorvar ( iCol )% p % subresdat ) end if deallocate ( me % colorvar ( iCol )% p ) end if end do deallocate ( me % colorvar ) end if if ( allocated ( me % colorvarpos )) then deallocate ( me % colorvarpos ) end if if ( associated ( me % bc )) deallocate ( me % bc ) if ( associated ( me % color )) deallocate ( me % color ) if ( associated ( me % subres )) deallocate ( me % subres ) end subroutine sdr_hvs_props_clean end module sdr_hvs_props_module","tags":"","url":"sourcefile/sdr_hvs_props_module.f90.html"},{"title":"sdr_subresolution_module.f90 – Seeder","text":"This file depends on sourcefile~~sdr_subresolution_module.f90~~EfferentGraph sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~ply_prj_header_module.f90 ply_prj_header_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~ply_prj_header_module.f90 sourcefile~sdr_subres_fills_module.f90 sdr_subres_fills_module.f90 sourcefile~sdr_subresolution_module.f90->sourcefile~sdr_subres_fills_module.f90 sourcefile~ply_fpt_header_module.f90 ply_fpt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fpt_header_module.f90 sourcefile~ply_fxt_header_module.f90 ply_fxt_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_fxt_header_module.f90 sourcefile~ply_l2p_header_module.f90 ply_l2p_header_module.f90 sourcefile~ply_prj_header_module.f90->sourcefile~ply_l2p_header_module.f90 sourcefile~ply_nodes_header_module.f90 ply_nodes_header_module.f90 sourcefile~ply_fpt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_fxt_header_module.f90->sourcefile~ply_nodes_header_module.f90 sourcefile~ply_l2p_header_module.f90->sourcefile~ply_nodes_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sdr_subresolution_module.f90~~AfferentGraph sourcefile~sdr_subresolution_module.f90 sdr_subresolution_module.f90 sourcefile~sdr_config_module.f90 sdr_config_module.f90 sourcefile~sdr_config_module.f90->sourcefile~sdr_subresolution_module.f90 sourcefile~sdr_flooding_module.f90 sdr_flooding_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_prototree_module.f90 sdr_protoTree_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_boundary_module.f90 sdr_boundary_module.f90 sourcefile~sdr_flooding_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_proto2treelm_module.f90 sdr_proto2treelm_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~sdr_proto2treelm_module.f90->sourcefile~sdr_boundary_module.f90 sourcefile~sdr_prototree_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90 sdr_refinePT_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_config_module.f90 sourcefile~sdr_refinept_module.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90 seeder.f90 sourcefile~seeder.f90->sourcefile~sdr_config_module.f90 sourcefile~seeder.f90->sourcefile~sdr_flooding_module.f90 sourcefile~seeder.f90->sourcefile~sdr_proto2treelm_module.f90 sourcefile~seeder.f90->sourcefile~sdr_prototree_module.f90 sourcefile~seeder.f90->sourcefile~sdr_refinept_module.f90 sourcefile~sdr_boundary_module.f90->sourcefile~sdr_prototree_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2014-2015 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this ! list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> This module describes settings that are required for the resolution of !! boundaries on a subelement level. !! !! These boundaries are represented by polynomials, and a nodal sampling in !! elements intersected by the boundary needs to be done accordingly. !! !! For subresolution to work, there needs to be a subresolution table !! defined, indicating at least the polynomial degree to use for polynomial !! representations. !! Only boundaries with a color (not the 'none' color), can be subresolved. !! For each color a separate file will be generated to contain the !! polynomial information on all the subresolved elements of this color. !! Note, that polynomial settings are global, all boundaries will be resolved !! with the same polynomial definition. !! !! Nodal values are obtained, by refining elements further down and probing !! integration points for their in or out status. This detaches the !! actual polynomial somewhat from the mesh resolution, and the number of !! levels to resolve beyond the target element can be stated independently !! of the polynomial degree. !! However, the subresolution levels should be set sufficiently high to !! provide a good resolution for the integration points. module sdr_subresolution_module use env_module , only : rk , labelLen use flu_binding , only : flu_State use aotus_module , only : aot_get_val , flu_State , & & aoterr_Fatal use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use ply_dof_module , only : P_Space , Q_Space use ply_dynarray_project_module , only : ply_prj_init_type , ply_prj_init_define use ply_prj_header_module , only : ply_prj_header_type , & & ply_prj_header_load use tem_aux_module , only : tem_abort use tem_logging_module , only : logunit use tem_tools_module , only : upper_to_lower use tem_dyn_array_module , only : dyn_labelArray_type , init , append use sdr_subres_fills_module , only : sdr_subres_fills_type , & & sdr_subres_fills_load , & & sdr_subres_fills_add implicit none !> Settings for the resolution below mesh elements. type sdr_subresolution_type !> Degree for the polynomials to use in the subelement resolution. integer :: polydegree !> Identification of the polynomial space to use. character :: polyspace !> Definition of conversions between modal and nodal values. type ( ply_prj_init_type ) :: projection !> Header definition of the projection header. !! !! Stored here for later output in the subresolution file. type ( ply_prj_header_type ) :: project_header !> Number of levels to use for the resolution of boundaries within elements. !! !! By default this value is automatically determined by the polydegree and !! the point set that is to be used. But that can be explicitly overwritten !! by the user with an arbitrary value here. !! If there is no subresolution to be done, this value will be 0. integer :: nLevels !> Dynamic array to store the color names, for which the default boundary !! resolution should reach subelements. !! !! All boundaries with this color will by default have subelement !! resolution, but this default can still be overwritten by the attribute !! setting of the boundary. type ( dyn_labelArray_type ) :: default_colors !> Definition of the values to use for color filling and color voids. type ( sdr_subres_fills_type ) :: color_values !> Position of value definitions for each color in the mesh. integer , allocatable :: value_pos (:) end type sdr_subresolution_type public :: sdr_subresolution_type public :: sdr_subresolution_load public :: sdr_subresolution_encolor contains !> Loading the settings for the subresolution in the mesh. subroutine sdr_subresolution_load ( subres , conf , parent ) !> The subresolution data structure to fill. type ( sdr_subresolution_type ), intent ( out ) :: subres !> Handle to the Lua configuration script. type ( flu_State ) :: conf !> Handle to a possible parent table. integer , optional , intent ( in ) :: parent integer :: basisType integer :: thandle integer :: phandle integer :: iError integer :: deflev character ( len = labelLen ) :: polyspace real ( kind = rk ) :: ofact ! Default: no subelement resolution: subres % polydegree = 0 subres % nLevels = 0 call aot_table_open ( L = conf , parent = parent , thandle = thandle , & & key = 'subresolution' ) if ( thandle > 0 ) then call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'polydegree' , & & val = subres % polydegree , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 0 ), * ) & & 'FATAL Error occured, while retrieving subresolution polydegree' call tem_abort () end if ! All other settings are only useful, if the polydegree is actually ! larger than 0! if ( subres % polydegree > 0 ) then call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'polyspace' , & & val = polyspace , & & default = 'q' , & & ErrCode = iError ) select case ( upper_to_lower ( trim ( polyspace ))) case ( 'q' ) basisType = Q_space case ( 'p' ) basisType = P_space case default write ( logunit ( 1 ), * ) 'ERROR in subresolution loading!' write ( logunit ( 1 ), * ) 'Unknown polyspace ' , trim ( polyspace ) write ( logUnit ( 1 ), * ) 'Supported are:' write ( logUnit ( 1 ), * ) '* Q (quadratic with i,j,k <= maxDegree)' write ( logUnit ( 1 ), * ) '* P (with i+j+k <= maxDegree)' write ( logUnit ( 1 ), * ) 'Stopping....' call tem_abort () end select subres % polyspace = upper_to_lower ( trim ( polyspace )) call aot_table_open ( L = conf , parent = thandle , thandle = phandle , & & key = 'projection' ) call ply_prj_header_load ( me = subres % project_header , & & conf = conf , & & parent = phandle ) if ( trim ( subres % project_header % kind ) == 'fpt' ) then ofact = subres % project_header % fpt_header % factor else ofact = subres % project_header % l2p_header % factor end if call aot_table_close ( L = conf , thandle = phandle ) call ply_prj_init_define ( me = subres % projection , & & header = subres % project_header , & & maxPolyDegree = subres % polydegree , & & basisType = basisType ) deflev = ceiling ( 2 * log ( real (( subres % polydegree + 1 ) * ofact )) / log ( 2.0 )) write ( logunit ( 2 ), * ) 'Reading the subresolving level to use.' write ( logunit ( 2 ), * ) 'Default: ' , deflev call aot_get_val ( L = conf , thandle = thandle , key = 'levels' , & & val = subres % nLevels , default = deflev , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 0 ), * ) & & 'FATAL Error occured, while retrieving subresolution levels' call tem_abort () end if if ( subres % nLevels < 1 ) then write ( logUnit ( 0 ), * ) 'If a subelement resolution by polynomials should' write ( logUnit ( 0 ), * ) 'be done, levels needs to be at least 1!' write ( logUnit ( 0 ), * ) 'But levels = ' , subres % nLevels write ( logUnit ( 0 ), * ) 'FATAL Error! Check your configuration.' call tem_abort () end if call subres_load_color_defaults ( label = subres % default_colors , & & conf = conf , & & parent = thandle ) end if ! Fills might even be defined, if there is no polynomial for ! subresolution. It still can be used to define color values. call sdr_subres_fills_load ( fills = subres % color_values , & & conf = conf , & & parent = thandle ) else ! Initialize the subres fills, also if there is no subresolution table. ! This is a little counter-intuitive, but we need to provide color values ! in any case, thus the arrays need to be properly initialized here. call sdr_subres_fills_load ( fills = subres % color_values , & & conf = conf , & & parent = parent ) end if call aot_table_close ( L = conf , thandle = thandle ) end subroutine sdr_subresolution_load !> Internal subroutine to load the list of colors, which by default should !! apply subelement resolution to its boundaries. !! !! This list is provided in the subresolution table by: !! \\code{.lua} !! default_colors = { 'colA', 'colB' } !! \\endcode !! This table is read by this routine. subroutine subres_load_color_defaults ( label , conf , parent ) !> Labels of the colors, for which a default setting is given. type ( dyn_labelArray_type ), intent ( out ) :: label !> Handle for the Lua script. type ( flu_State ) :: conf !> Parent table, within which to open the color_default table. integer , intent ( in ) :: parent character ( len = labelLen ) :: cLabel integer :: thandle integer :: nLabels integer :: iLabel integer :: iError integer :: cPos logical :: wasAdded call aot_table_open ( L = conf , parent = parent , thandle = thandle , & & key = 'default_colors' ) if ( thandle > 0 ) then nLabels = aot_table_length ( L = conf , thandle = thandle ) call init ( label , length = nLabels ) do iLabel = 1 , nLabels call aot_get_val ( L = conf , & & thandle = thandle , & & pos = iLabel , & & val = clabel , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logunit ( 0 ), * ) & & 'FATAL Error occured while retrieving a subresolved default' & & // ' color name!' call tem_abort () end if call append ( label , upper_to_lower ( trim ( clabel )), & & pos = cPos , wasAdded = wasAdded ) if (. not . wasAdded ) then write ( logunit ( 1 ), * ) 'WARNING: subresolution default color ' , cLabel write ( logunit ( 1 ), * ) 'already in the list!' write ( logunit ( 1 ), * ) 'Keep in mind that color names are case' & & // 'insensitive' end if end do end if call aot_table_close ( L = conf , thandle = thandle ) end subroutine subres_load_color_defaults !> Find the value definitions for all unique colors. subroutine sdr_subresolution_encolor ( me , colors ) type ( sdr_subresolution_type ), intent ( inout ) :: me type ( dyn_labelArray_type ), intent ( in ) :: colors integer :: iColor character ( len = labelLen ) :: cLabel logical :: wasAdded allocate ( me % value_pos ( colors % nVals )) me % value_pos = - 1 do iColor = 1 , colors % nVals cLabel = colors % val ( iColor ) if ( trim ( cLabel ) /= 'none' ) then write ( logunit ( 4 ), * ) 'Reading filling definition for color ' & & // trim ( cLabel ) call sdr_subres_fills_add ( fills = me % color_values , & & colorname = trim ( cLabel ), & & fill_value = 1.0_rk , & & void_value = 0.0_rk , & & pos = me % value_pos ( iColor ), & & wasAdded = wasAdded ) if ( wasAdded ) then write ( logunit ( 1 ), * ) 'NOTE: No values specified for color ' , & & trim ( cLabel ) write ( logunit ( 1 ), * ) 'Using default fill=1, void=0 !!!' end if write ( logunit ( 2 ), * ) 'Color values for ' // trim ( cLabel ) & & // ': fill=' , & & me % color_values % fill % val ( me % value_pos ( iColor )), & & '; void=' , & & me % color_values % void % val ( me % value_pos ( iColor )) end if end do end subroutine sdr_subresolution_encolor end module sdr_subresolution_module","tags":"","url":"sourcefile/sdr_subresolution_module.f90.html"},{"title":"Build and run Seeder – Seeder","text":"Generate a geometry Seeder relies mainly on STL files for geometry descriptions.\nUse your preferred tool to generate the geometry you want to\ncreate a mesh for.\nMost CAD applications allow you to export geometry in the\nSTL format, but also other 3D modelling tools like for\nexample Blender provide you with that option. Build and run Seeder Checkout: hg clone https://geb.sts.nt.uni-siegen.de/hg/seeder this will get you the repository including sub-repos aotus and treelm in the\ndirectory seeder . Note: You need MPI in order to compile the application.\n    Set the environment variable FC to point to the MPI compiler wrapper: export FC=mpif90 After that you can build and run Seeder. There are some further tutorials available to illustrate the\nusage of Seeder. Here is a very quick basic run through: Configure ./waf configure Build ./waf build Create a mesh directory in your working path: mkdir mesh Create a debug directory in your working path: mkdir debug Change settings in input/config.lua . Specify the STL file(s) and set the min and max tree levels. Run build/seeder input/config.lua The generated mesh is found in the mesh/ directory after the successful\n  execution of Seeder","tags":"","url":"page/index.html"},{"title":"Attribute – Seeder","text":"Attribute defines the property for the geometries defined in the spatial object. \nFollowing attribute kinds are supported: Boundary Seed Refinement Attribute list is dynamic unique list. Thus multiple definitions of the same attribute in the configuration file does not result in multiple storages.","tags":"","url":"page/attributes/index.html"},{"title":"Feature Overview – Seeder","text":"Seeder supports the use of .stl files that one can produce with Blender for example.\nMoreover the user can transform created objects with resizing or changing the orientation. Here you can find the documentation of these features: STL files Transformation","tags":"","url":"page/features/index.html"},{"title":"Boundary conditions – Seeder","text":"Boundary conditions are defined by the label attached to a boundary object.\nMultiple boundary objects might have the same label and therefore attached\nto the same boundary condition.\nIf there are multiple boundaries in a given direction of an element, the\none defined first in the configuration, will be used. This allows you to\nset the precedence order of boundaries that should be used at any\nintersections. Only boundary labels that actually appear in the final mesh will be written\nto the header description of the boundaries in the mesh.","tags":"","url":"page/features/boundary_cond.html"},{"title":"Colored seeds – Seeder","text":"Seeds might have colors and thereby define different areas within the mesh.\nThis is for example useful to ascribe special material parameters to parts\nof the domain.\nEach colored seed is bounded by a boundary of the same color, or boundaries\nwhich have the color none or all .\nElements which have a non 'none' color attached to them will have the\nisColored property and the additional property information about which colors\nare attached to that element will be stored.\nThere might be an arbitrary number of colors and multiple colors can be\nassigned to each element.\nColor names can be chosen arbitrarily and are case insensitive. We achieve this by using a bitfield for each color and basically do the\nflooding for each color. With up to three colors there should be little to\nno memory overhead imposed by this approach, as each color requires only one\nbyte in the integer bitfield, that we use (the last byte is reserved for\ngeneral node information). Beyond that additional integers will be used as\nneeded by the number of colors.\nIn the mesh on the disk, colors are stored in ASCII characters with 7 colors\nper byte, and meshes without coloring ( none color everywhere as only color)\nno color information will be written at all. Note colored boundaries are subject to the same rules of boundary labels\nas none colored boundaries and if they intersect with none colored boundaries\nwill take precedence over those, if configured first.\nAs this is typically not desired, you probably want to define your colored\nboundary objects after the none colored ones!","tags":"","url":"page/features/colored_seeds.html"},{"title":"STL – Seeder","text":"Stl files can be used as geometry kind. At first, seeder loads the \ntriangles from stl files to the temporary stl_data type and\nthen each triangle in the stl_data is converted to sdr_triangle_type.\nStl geometry requires filename and stl file format. If file format\nis not provided, default is set to binary.\nValid definition: Single stl geometry = { kind = 'stl' , object = { filename = 'cube.stl' , format = 'ascii' -- if not provided, default is binary } } Multiple stls geometry = { kind = 'stl' , object = { { filename = 'cube.stl' }, { filename = 'cylinder.stl' } } } Seeder file to create mesh with single 'stl' geometry: \\include testsuite/stl/seeder.lua Mesh with 'stl' geometry created by seeder file: Example lua file is available at testsuite/stl/seeder.lua","tags":"","url":"page/features/stl.html"},{"title":"Subresolved boundaries – Seeder","text":"Boundaries with a color might be resolved beyond the stair-case representation\noffered by the mesh by creating a polynomial representation of the color\nvalues within the intersected elements.\nFor this you need to define a subresolution table, describing at least the\npolynomial degree that should be used for this information.\nWhen this table is defined, you can indicate that a (colored) boundary is to\nbe subresolved by stating subresolution = true in its attribute. Polynomial information will be created per color and is accessible as a\nproperty in the mesh afterwards.","tags":"","url":"page/features/sub_boundaries.html"},{"title":"Transformation – Seeder","text":"Transformation is used to scale, translate, rotate and reflect\nthe geometrical objects. Trasformation table is defined in the spatial\nobject table in the lua config file. If the geometry in the spatial\nobject contains multiple geometries then the transformation defined in that\nspatial object is applied to all the geometries. If both translation and deformation are defined for the geometry object\nthen the deformation is applied first and then the deformed geometry\nis then translated. Translation Translation is a table with three entries defining x,y,z coordinate values\nto translate the geometrical object.\nGometry is translated just by adding the position of the geometry with \ngiven translation vector. Example: spatial_object = { ... < attribute > ... ... < geometry > ... transformation = { translation = { 0.0 , 2.0 , 0.0 } -- translating the object along y-axis by 2.0 } } Deformation Deformation table can be used to scale, rotate and reflect the geometry.\nDeformation cane be defined as const, vector and matrix. In the code,\nit is converted to matrix with 3x3. Matrix is multiplied with a geometry\nvector to scale, rotate or reflect depends on the given matrix. Scaling If deformation is const, then geometry is scaled in all three directions\nwith const and it is vector with three entries, then geometry is scaled in\nx,y,z directions with different factor.\nExample:\n* Constant scaling in three direction spatial_object = { ... < attribute > ... ... < geometry > ... transformation = { deformation = 2.0 , -- scaled in all direction by 2.0 } } Different scaling in three direction spatial_object = { ... < attribute > ... ... < geometry > ... transformation = { deformation = { 0.5 , 2.0 , 1.5 } } } Reflection\nBelow example reflect the geometry object in y-axis spatial_object = { ... < attribute > ... ... < geometry > ... transformation = { deformation = { 1.0 , - 1.0 , 1.0 } } } Rotation\n Rotation is defined by the deformation table with 3x3 entries.\n Below example rotate the geometry object in z-axis in anti-clockwise\n direction by 45°. spatial_object = { ... < attribute > ... ... < geometry > ... transformation = { deformation = { { 0.5 * math.cos ( 45 * math.pi / 180 ), - 0.5 * math.sin ( 45 * math.pi / 180 ), 0.0 }, { 0.5 * math.sin ( 45 * math.pi / 180 ), 0.5 * math.cos ( 45 * math.pi / 180 ), 0.0 }, { 0.0 , 0.0 , 0.5 } } } } More information on rotatation matrix can be found in Rotation .\nIt is also possible to combine scaling, reflection and rotation in the \ndeformation matrix.\nExample lua file is available at testsuite/transform/seeder.lua .","tags":"","url":"page/features/transformation.html"},{"title":"Seeder Algorithm – Seeder","text":"In a first step, Seeder will create a protoTree, that refines all domain\nboundaries with the required resolution. This is done iteratively level by\nlevel, and each node, that is intersected by a domain boundary is further\nrefined on the next level, if the maximum level of all intersected objects\nor global minimum level is not reached yet.\nAt the end of this process the boundaries of the domain are resolved as\nrequested everywhere. After the boundaries are properly resolved, it needs to be decided, what is\nactually part of the domain itself. For this elements are marked as flooded\nbased upon their neighborhood. Obviously this only works properly if there\nis some initial starting point to get the flooding running. This is achieved\nby the user defined seed objects, which will mark all the elements that they\nintersect as flooded initially, as long as the elements do not intersect\nboundaries at the same time. Elements which intersect boundaries are never\nflooded!. Before flooding, the neighbors of each leaf node is identified for \neach node faces which is necassary for flooding to find the state of \nneighbor node. This flooding is done iteratively until a iteration did not change any\nelement state anymore. All flooded elements identify the computational\ndomain now. Finally the computational domain is refined to the desired level everywhere,\nas given by refinement objects or the global minimal refinement level and\nboundary conditions are assigned.\nThis data is then written in treelm format to disk at the location, specified\nby the user in the configuration file. Note, that if this is a directory,\nyou should not forget the trailing path separator in the definition and\ncreate the directory beforehand.","tags":"","url":"page/sdr_algorithm.html"},{"title":"Testsuite tutorials – Seeder","text":"The goal of this tutorial is to present the walk through on how\nto generate the mesh using the SEEDER. \nThe tutorial starts from the most simplest mesh\nto complex mesh by introducing the features in the SEEDER one by one.\nIn the seeder configuration file, the debug table can be used to \ndump the protoTree in restart format which can be post-processed\nusing harvester to visualize in paraview. Fully Periodic Cube Points Lines Planes Triangles Boxes Spheres Cylinders Special Periodic Planes STL","tags":"","url":"page/testsuite_tutorials/index.html"},{"title":"Box – Seeder","text":"Boxes are defined by an origin and three vectors.\nBox is considered to be solid as default i.e. all the cubes inside the\nbox are marked as intersected cubes. \nIt is possible to created hollow boxes by setting only_surface = true ,\nit will mark only the cubes intersect with sphere surface as intersected\ncubes. Hollow box is created by converting box definion to triangles\ninternally and do triangle cube intersection. Seeder supports non-axis aligned oriented boxes. Valid definition: Single box geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 }, vec = { { 0.0 , 0.5 , 0.0 }, { 0.2 , 0.0 , 0.0 }, { 0.0 , 0.0 , 0.8 } } only_surface = true , -- If not defined default is set to false } } Rotated box geometry = { kind = 'canoND' , object = { { origin = { 0.0 , 0.0 , 0.0 }, vec = { { 0.0 , 0.4 * math.cos ( 45 * math.pi / 180 ), - 0.4 * math.sin ( 45 * math.pi / 180 ) }, { 0.8 , 0.0 , 0.0 }, { 0.0 , 0.4 * math.sin ( 45 * math.pi / 180 ), 0.4 * math.cos ( 45 * math.pi / 180 ) }, }, -- box rotated along x-axis in anti-clockwise direction by 45° } } } Seeder file to generate the mesh with box folder = 'mesh/' comment = 'box' minlevel = 2 level = 2 -- number of levels are two -- Debug output can be used to output preliminary tree in restart format -- and this restart file can be converted to vtu format by harvester. debug = { debugMode = true , debugFiles = true , debugMesh = 'debug/' } -- boundingbox: two entries: origin and length in this -- order, if no keys are used bounding_cube = { origin = { - 2.0 , - 2.0 , - 2.0 }, length = 4.0 } -- Each spatial object is defined by an attribute and some geometric -- entity attached to this attribute. Attribute might be defined mulitple times. -- Attributes are described by a kind (boundary ,seed or Refinement) a level spatial_object = { { attribute = { kind = 'seed' , label = 'seed' , }, -- Geometric objects might by right now: -- canoND (point, line, plane or box) -- STL geometry = { kind = 'canoND' , object = { origin = { - 1.8 , - 1.8 , - 1.8 } } } }, -- seed -- defining the attribute and geometry of the box { attribute = { kind = 'boundary' , label = 'solid' , level = 3 }, geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 }, vec = { { 0.0 , 0.5 , 0.0 }, { 0.2 , 0.0 , 0.0 }, { 0.0 , 0.0 , 0.8 } }, only_surface = true , } } } } -- spatial object A box can also be defined by two planes printRuntimeInfo = false comment = 'box' minlevel = 2 -- Use this file as template. Do not modify this file for running some testcases -- Location to write the mesh in -- Note the trailing path seperator, needed, if all mesh files should be -- directory. This directory has to exist before running Seeder in this -- case folder = 'mesh/' level = 6 --number of levels are six --Debug output can be used to output preliminary tree in restart format --and this restart file can be converted to vtu format by harvester. debug = { debugMode = true , debugFiles = true , debugMesh = 'debug/' } -- boundingbox: two entries: origin and length in this -- order, if no keys are used bounding_cube = { origin = { - 2.0 , - 2.0 , - 2.0 }, length = 4.0 } -- Each spatial object is defined by an attribute and some geometric -- entity attached to this attribute. Attribute might be defined mulitple times. -- Attributes are described by a kind (boundary ,seed or Refinement) a level spatial_object = { { attribute = { kind = 'seed' , label = 'seed' , }, -- kind and lable are 'seed' -- Geometric objects might by right now: -- canoND (point, line, plane or box) -- STL geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 }, } } }, -- seed -------------------------------------------- -- defining the attribute and geometry for the left wall { attribute = { kind = 'boundary' , label = 'left_wall' , level = level , calc_dist = false , }, geometry = { kind = 'canoND' , object = { origin = { - 2.0 , - 2.0 , - 1.8 }, vec = { { 4.0 , 0.0 , 0.0 }, { 0.0 , 4.0 , 0.0 }, }, only_surface = true , } -- object }, }, -------------------------------------------- -- defining the attribute for the right wall { attribute = { kind = 'boundary' , label = 'right_wall' , level = level , calc_dist = false , }, geometry = { kind = 'canoND' , object = { origin = { - 2.0 , - 2.0 , 1.4 }, vec = { { 4.0 , 0.0 , 0.0 }, { 0.0 , 4.0 , 0.0 }, }, only_surface = true , } -- object }, }, -- right_wall } -- spatial object Mesh with hollow box (Hollow => only_surface = true) Cutview of Mesh with hollow box Mesh generated with solid box (Solid => only_surface = false) Cutview of Mesh with solid box Example lua file is available at testsuite/box/seeder.lua","tags":"","url":"page/testsuite_tutorials/boxes.html"},{"title":"Cylinders – Seeder","text":"Cylinders are defined by an origin, vector defining the length and the\naxis and the radius.\nCylinder is considered to be solid as default i.e. all the cubes inside the\ncylinder are marked as intersected cubes. \nIt is possible to created hollow cylinders by setting only_surface = true ,\nit will mark only the cubes intersect with cylinder surface as intersected\ncubes Valid definition: Single cylinder geometry = { kind = 'cylinder' , object = { origin = { 0.0 , 0.0 , 0.0 }, vec = { 1.0 , 0.0 , 0.0 }, radius = 0.25 , only_surface = true , -- If not defined default is set to false } } Multiple cylinder geometry = { kind = 'cylinder' , object = { { origin = { 0.0 , 0.0 , 0.0 }, vec = { 1.0 , 0.0 , 0.0 }, radius = 0.25 }, { origin = { 0.0 , 0.0 , 0.0 }, vec = { 1.0 , 1.0 , 0.0 }, radius = 0.25 } } } Seeder file to generate mesh with single cylinder ( only_surface=true ) is below: -- Use this file as template. Do not modify this file for running some testcases -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Some comment,you might want to put into the mesh file for later reference. comment = 'cylinder' -- Debug output can be used to output preliminary tree in restart format -- and this restart file can be converted to vtu format by Harvester debug = { debugMode = true , debugFiles = false , debugMesh = 'debug/' } -- Bounding cube: the root node of the octree, defining the complete universe, -- from which all elements are derived by recursive bisection. -- The origin is the corner from which on the cube is spanned with the given -- length in each direction. bounding_cube = { origin = { - 1.0 , - 1.0 , - 1.0 }, length = 4.0 } -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. minlevel = 5 spatial_object = { { -- Defining a domain boundary attribute = { kind = 'boundary' , -- or seed, refinement label = 'solid' , -- some label to identify the boundary -- condition level = 1 -- level to refine this object with, -- default = 0 }, -- Defining Geometry of the cylinder geometry = { kind = 'cylinder' , object = { origin = { 0 , 1.0 , 1.0 }, vec = { 2.0 , 0.0 , 0.0 }, radius = 0.5 , only_surface = true , -- If not defined default is set to false } } }, { -- Defining a seed to identify the part of the computational domain in -- the universe cube. attribute = { kind = 'seed' }, geometry = { -- single point definition with a canoND object. kind = 'canoND' , object = { origin = { - 0.0 , - 1.0 , - 1.0 } } -- origin of the cube for the defining of the 'seed' } } } Mesh with hollow cylinder (Hollow => only_surface = true) Cutview of mesh with hollow cylinder As said earlier, cylinder can be created as solid one using only_surface=false .\nCutview of Mesh generated with only_surface=false : Example lua file is available at testsuite/cylinder/seeder.lua .","tags":"","url":"page/testsuite_tutorials/cylinder.html"},{"title":"Fully periodic cube – Seeder","text":"Fully periodic cube is the most simplest mesh to generate by\ndefining most neccessary basic information for mesh like\nbounding cube defining the universe, minlevel defining\nminimum refinement level in the fluid domain and folder \ndefines where to dump the fluid mesh in treelm format. Example to generate the most simple mesh is given below, -- This seeder configuration file shows an example for fully periodic cube -- mesh with very basic mesh information i.e minlevel, folder and -- bounding cube -- ------------------------------------------------------------------------- -- -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Some comment, you might want to put into the mesh file for later reference. comment = 'Simple Sample Seeder Mesh' -- Debug output can be used to output prelimnary tree in restart format -- and this restart file can be converted to vtk format by Harvester debug = { debugMode = true , debugFiles = false , debugMesh = 'debug/' } -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. minlevel = 3 -- Bounding cube: the root node of the octree, defining the complete universe, -- from which all elements are derived by recursive bisection. -- The origin is the corner from which on the cube is spanned with the given -- length in each direction. bounding_cube = { origin = { - 1.0 , - 1.0 , - 1.0 }, length = 2.0 } spatial_object = { { attribute = { kind = 'seed' }, geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 , }, vec = {{ 2.8 , 3.9 , 4.2 },{ 3.1 , 3.4 , 5.2 }} } } } } Image below shows the output mesh of fully periodic cube.","tags":"","url":"page/testsuite_tutorials/ful_per_cube.html"},{"title":"Line – Seeder","text":"Lines are defined in the configuration file through canonical \ngeometry kind with an origin and vector defining the length\nand direction of the line. Valid definition: Single line geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 }, vec = { 2.0 , 0.0 , 0.0 } } } Multiple line geometry = { kind = 'canoND' , object = { { origin = { 0.0 , 0.0 , 0.0 }, vec = { 2.0 , 0.0 , 0.0 } }, { origin = { 1.0 , 0.0 , 0.0 }, vec = { 0.0 , 2.0 , 0.0 } }, } } Seeder file to generate the mesh with line is generated using above canonical\ngeometry kind and the code is given below: -- This is the standard seeder configuration, that should document the possible -- and required configuration options. -- It should always run out of the box! -- ------------------------------------------------------------------------- -- -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be -- in a  directory. This directory has to exist before running Seeder in -- this case! folder = 'mesh/' -- Some comment, you might want to put into the mesh file for later -- reference. comment = 'Simple Sample Seeder Mesh' -- Debug output can be used to output preliminary tree in restart format -- and this restart file can be converted to vtu format by Harvester debug = { debugMode = true , debugFiles = false , debugMesh = 'debug/' } -- Bounding cube: the root node of the octree, defining the complete universe, -- from which all elements are derived by recursive bisection. -- The origin is the corner from which on the cube is spanned with the given -- length in each direction. bounding_cube = { origin = { - 1.0 , - 1.0 , - 1.0 }, length = 2.0 } -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. minlevel = 6 -- *********************** Table of spatial objects *********************** -- -- Each spatial object is defined by an attribute and some geometric entity -- attached to this attribute. Attributes might be defined multiple times. -- Attributes are described by a kind (boundary, seed or refinement), a level -- and maybe further kind specific values, like a label for the boundary. -- Geometric objects might by right now: -- - canoND (point, line, plane or box) -- - STL -- - Sphere -- - Cylinder -- -- Periodic boundaries are special, spatial objects of this kind can only make -- use of geometric objects of the kind 'periodic'. spatial_object = { { -- Defining a domain boundary attribute = { kind = 'boundary' , -- or seed, refinement label = 'solid' , -- some label to identify the boundary -- condition level = 1 -- level to refine this object with, -- default = 0 }, -- Example for line -- It is also possible to define multiple lines geometry = { kind = 'canoND' , object = { origin = { - 1.0 , 0.0 , 0.0 }, vec = { 0.0 , 2.0 , 0.0 } } }, -- Transformation of line --    transformation = { --      translation = {1.0,0.0,0.0}, --      deformation = { --        { 0.0, 0.5*math.cos(45*math.pi/180), -0.5*math.sin(45*math.pi/180) }, --        { 0.0, 0.5*math.sin(45*math.pi/180), 0.5*math.cos(45*math.pi/180) }, --        { 0.5, 0.0, 0.0 } --                    } -- rotate the line along x-axis in anti-clockwise -- direction --                      -- and scale by 0.5 --    } }, { -- Defining a seed to identify the part of the computational domain in -- the universe cube. attribute = { kind = 'seed' }, geometry = { -- single point definition with a canoND object. kind = 'canoND' , object = { origin = { - 0.0 , - 1.0 , - 1.0 } } } } } -- end of spatial objects -- ************************************************************************ -- The mesh generated with line inside mesh: Example lua file is available at testsuite/line/seeder.lua .","tags":"","url":"page/testsuite_tutorials/lines.html"},{"title":"How to define periodic planes in lua file? – Seeder","text":"There are some Pre-conditions to satisfy to define periodic planes, \n look at \"How periodic boundaries are created in seeder?\" No need to specify any bclabel for periodic planes. No need to specify periodic boundary in the solver configuration \n  file since they are treated explicitly while building the neighbor array. In the example below, the following variables are fixed. length = 1.0 -- minimum refinement level minrefine = 1 -- maximum refinement level maxrefine = 4 -- mesh size -- The offset distance between periodic planes dx is computed from -- the maximum refinement level. dx = 2. * length / ( 2 &#94; maxrefine ) -- bounding box defining the complete domain bounding_cube = { origin = { - length , - length , - length }, length = 2. * length } Single-level Creating a geometry with periodic planes in z.direction with only one fluid element between the periodic planes. Single periodic plane in z-direction spatial_object = { attribute = { kind = 'boundary' , level = 1 }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { - length , - length , dx + dx / 2. }, vec = { { 2. * length , 0.0 , 0.0 }, { 0.0 , 2. * length , 0.0 } } }, plane2 = { origin = { - length , - length , - dx }, vec = { { 0.0 , 2. * length , 0.0 }, { 2. * length , 0.0 , 0.0 } } } } } } Multiple periodic planes spatial_object = { { attribute = { kind = 'boundary' , level = 1 }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { - length , - length , dx + dx / 2. }, vec = { { 2. * length , 0.0 , 0.0 }, { 0.0 , 2. * length , 0.0 } } }, plane2 = { origin = { - length , - length , - dx }, vec = { { 0.0 , 2. * length , 0.0 }, { 2. * length , 0.0 , 0.0 } } } } } }, { attribute = { kind = 'boundary' , level = 1 }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { length , - length , - length }, vec = { { 0.0 , 2. * length , 0.0 }, { 0.0 , 0.0 , 2. * length } } }, plane2 = { origin = { - length , - length , - length }, vec = { { 0.0 , 0.0 , 2. * length }, { 0.0 , 2. * length , 0.0 } } } } } }, { attribute = { kind = 'boundary' , level = 1 }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { - length , length , - length }, vec = { { 0.0 , 0.0 , 2. * length }, { 2. * length , 0.0 , 0.0 } } }, plane2 = { origin = { - length , - length , - length }, vec = { { 2. * length , 0.0 , 0.0 }, { 0.0 , 0.0 , 2. * length } } } } } } } Multi-level For multi-level periodic planes, the minimum offset distance dxmin is computed from the maximum refinement level in the refinement box such that\n  periodic planes are aligned perfectly parallel to each other as shown in the figure below. Two refinement box are used in this example- length = 2.0 -- minimum refinement level minrefine = 4 -- maximum refinement level maxrefine = minrefine + 3 -- mesh size -- The offset distance between periodic planes dx is computed from -- the maximum refinement level. dx = length / ( 2 &#94; minrefine ) dxmin = length / ( 2 &#94; maxrefine ) -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Debug output can be used to output preliminary tree in restart format -- and this restart file can be converted to vtu format by Harvester debug = { debugMode = true , debugFiles = true , debugMesh = 'debug/' } -- bounding box defining the complete domain bounding_cube = { origin = { - length / 2 , - length / 2 , - length / 2 }, length = length } -- refinebox: three entries: origin, length and refinementlevel spatial_object = { { attribute = { kind = 'refinement' , level = maxrefine }, geometry = { kind = 'canoND' , object = { origin = { - 0.25 / 2 , - 0.25 / 2. , dxmin / 2 }, vec = { { 0.5 / 2 , 0.0 , 0.0 }, { 0.0 , 0.5 / 2 , 0.0 }, { 0.0 , 0.0 , dx - dxmin } } } } }, { attribute = { kind = 'refinement' , level = maxrefine - 1 }, geometry = { kind = 'canoND' , object = { origin = { - 0.25 , - 0.25 , dxmin / 2 }, vec = { { 0.5 , 0.0 , 0.0 }, { 0.0 , 0.5 , 0.0 }, { 0.0 , 0.0 , dx - dxmin } } } } }, -- Defining a seed to identify the part of the computational domain in -- the universe cube. { attribute = { kind = 'seed' ,}, geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , dx / 2 } } } }, } table.insert ( spatial_object ,{ attribute = { kind = 'boundary' , level = minrefine }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { - length / 2 , - length / 2 , dx + dxmin / 2. }, vec = { { length , 0.0 , 0.0 }, { 0.0 , length , 0.0 } } }, plane2 = { origin = { - length / 2 , - length / 2 , - dxmin / 2 }, vec = { { 0.0 , length , 0.0 }, { length , 0.0 , 0.0 } } } } } }) Multiple periodic planes -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Some comment,you might want to put into the mesh file for later reference. comment = 'multipleperiodicplanes' -- Debug output can be used to output preliminary tree in restart format -- and this restart file can be converted to vtu format by Harvester debug = { debugMode = true , debugFiles = false , debugMesh = 'debug/' } length = 1.0 --minimum refinement level minrefine = 1 -- maximum refinement level maxrefine = 4 -- mesh size -- The offset distance between periodic planes dx is computed from -- the maximum refinement level. dx = 2. * length / 2 &#94; ( maxrefine ) -- bounding box defining the complete domain bounding_cube = { origin = { - length , - length , - length }, length = 2. * length } spatial_object = { { attribute = { kind = 'boundary' , level = 4 }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { - length , - length , dx + dx / 2. }, vec = { { 2. * length , 0.0 , 0.0 }, { 0.0 , 2. * length , 0.0 } } }, plane2 = { origin = { - length , - length , - dx }, vec = { { 0.0 , 2. * length , 0.0 }, { 2. * length , 0.0 , 0.0 } } } } } }, { attribute = { kind = 'boundary' , level = 4 }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { length , - length , - length }, vec = { { 0.0 , 2. * length , 0.0 }, { 0.0 , 0.0 , 2. * length } } }, plane2 = { origin = { - length , - length , - length }, vec = { { 0.0 , 0.0 , 2. * length }, { 0.0 , 2. * length , 0.0 } } } } } }, { attribute = { kind = 'boundary' , level = 4 }, geometry = { kind = 'periodic' , object = { plane1 = { origin = { - length , length , - length }, vec = { { 0.0 , 0.0 , 2. * length }, { 2. * length , 0.0 , 0.0 } } }, plane2 = { origin = { - length , - length , - length }, vec = { { 2. * length , 0.0 , 0.0 }, { 0.0 , 0.0 , 2. * length } } } } } }, { -- Defining a seed to identify the part of the computational domain in -- the universe cube. -- single point definition with a canoND object. attribute = { kind = 'seed' }, geometry = { kind = 'canoND' , object = { origin = { 0. , 0. , dx * 0.5 } } } } } Example for multiple periodic planes is availabe at testsuite/multiPeriodic/seeder.lua","tags":"","url":"page/testsuite_tutorials/per_plane_example.html"},{"title":"Periodic planes – Seeder","text":"The periodic boundary condition are used to represent the domain \nwith infinite length, which is used when the simulation domain is too long.\nIt can be used to reduce the simulation domain from higher dimension \nto lower dimension for example 3D to 2D or 3D to 1D.\nOn the periodic boundary, the velocity at the outlet is copied to \nthe velocity at the inlet and vice versa. Periodic planes are used to define perodic boundary in the mesh.\nPeriodic plane table contains two planes, plane1 and plane2 i.e\nfluid neighbor of plane1 is mapped to plane2 and vice versa. \nFollowing conditions must be satisfied in defining periodic planes normal direction of plane1 and plane2 should point outwards\n  fluid domain. In seeder, the plane normals are \n  defined by right hand rule , where thump finger represents \n  the 1st vector and index finger represents the 2nd vector and middle finger\n  represents the normal direction. This right hand rule can be seen perfectly \n  in the left plane in the figure below. Above image shows the normal directions for two planes pointing outwards \n  the fluid domain.\n  Normal direction of the plane can be changed by just swaping the vectors\n  defining planes.i.e order of vector as shown in image below. refinement level on both planes should be the same and there should not\n  be any level jump on the periodic planes as shown below. Correct plane definition should look like below This can be achieved by shifting the plane by half of element size of\n  maximum refinement level intersecting the periodic planes.\\n If any of the above condition is not satisfied then seeder will \n  terminate an error message. In seeder, when the node intersect only with periodic planes then the \nboundary id for that direction is set to huge number. So any node \nwith direction of boundary id greater than number of boundaries then\nthe following algorithm is used for that direction. Algorithm used to generate the periodic boundary Find the barycenter of the current element with periodic neighbor Find the intersected periodic plane id and its assosiated opposite\n  plane id in the growing array of periodic planes. (periodic\n  plane definition is needed to project coordinate point from one plane\n  to another and also the normal direction to get to the fluid domain) Project the barycenter of current element on its neighbor periodic \n  plane Translate the projected point to the opposite plane Use the current search direction to move to the fluid node. get the treeID of that node and set negative of this treeID to boundary id\n  for current direction. if the fluid node is intersected by a boundary then set boundary id\n  to minimun of intersected boundary. if the fluid node is again intersected by periodic boundary,\n  then move in the negative normal direction of opposite periodic plane\n  and do step 3 and 4. In the solver, the periodic boundaries are identified with the boundary\nid with negative values. How to define periodic planes in lua file? Example lua file to generate Channel with one element in z-direction\nis available in the repository at: testsuite/periodic/seeder.lua","tags":"","url":"page/testsuite_tutorials/periodic_planes.html"},{"title":"Plane – Seeder","text":"Planes are defined by an origin and two vectors.\nInternally in the code, planes are converted into two triangles. vec2____________ / \\ | | | | | | | | | |-------------->| origin vec1 Defintion: spatial_object = { attribute = { kind = 'boundary' , label = 'plane1' , }, geometry = { kind = 'canoND' , object = { origin = { 2.0 , - 1.0 , - 1.0 }, vec = {{ 0.0 , 2.0 , 0.0 }, { 0.0 , 0.0 , 2.0 }}, } } } Seeder file to generate the mesh with plane is given below: -- Geometry definition height = 0.41 length = height -- Use this file as template. Do not modify this file for running some testcases -- Location to write the mesh in -- Note the trailing path seperator, needed, if all mesh files should be -- directory. This directory has to exist before running Seeder in this -- case folder = 'mesh/' --A minimum level,by which all parts in the computational domain should --at least be resolved with .Default is 0 minlevel = 6 --Debug output can be used to output preliminary tree in restart format --and this restart file can be converted to vtu format by harvester. debug = { debugMode = true , debugFiles = true , debugMesh = 'debug/' } -- boundingbox: two entries: origin and length in this -- order, if no keys are used bounding_cube = { origin = { - length , - length , - length }, length = length * 2.0 } -- Each spatial object is defined by an attribute and some geometric -- entity attached to this attribute. Attribute might be defined mulitple-- times. -- Attributes are described by a kind (boundary ,seed or Refinement) --  a level spatial_object = { { attribute = { kind = 'seed' , }, -- Geometric objects might by right now: -- canoND (point, line, plane or box) -- STL geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 }, } } -- geometry }, -- seed { -- Four edges bounding the plane (east, west, north and south) -- this is for the lable' east' attribute = { kind = 'boundary' , label = 'east' }, -- for define the box object requires the origin and vector geometry = { kind = 'canoND' , object = { origin = { length * 0.5 , - length * 0.5 , - length * 0.5 }, vec = {{ 0.0 , length , 0. }, { 0. , 0.0 , length }} } } }, { -- this is for label 'west' attribute = { kind = 'boundary' , label = 'west' }, geometry = { kind = 'canoND' , object = { origin = { - length * 0.5 , - length * 0.5 , - length * 0.5 }, vec = {{ 0.0 , length , 0. }, { 0. , 0.0 , length }} } } }, { -- this is for label 'North' attribute = { kind = 'boundary' , label = 'north' }, geometry = { kind = 'canoND' , object = { origin = { - length * 0.5 , height * 0.5 , - length * 0.5 }, vec = {{ length , 0.0 , 0. }, { 0. , 0.0 , length }} } } }, { -- this is for label 'South' attribute = { kind = 'boundary' , label = 'south' }, geometry = { kind = 'canoND' , object = { origin = { - length * 0.5 , - height * 0.5 , - length * 0.5 }, vec = {{ length , 0.0 , 0. }, { 0. , 0.0 , length }} } } } } The mesh generated with plane inside mesh: Cut view of plane Example lua file is available at testsuite/plane/seeder.lua .","tags":"","url":"page/testsuite_tutorials/planes.html"},{"title":"Points – Seeder","text":"Points are defined in the configuration file through canonoical \ngeometry kind with an origin. Valid definition: Single point geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 } } } Multiple point geometry = { kind = 'canoND' , object = { { origin = { 0.0 , 0.0 , 0.0 } }, { origin = { 1.0 , 0.0 , 0.0 } }, } } Seeder file to generate the mesh with multiple point obstacle is given below: -- This seeder configuration file shows an example to create a point -- ------------------------------------------------------------------------- -- -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Some comment, you might want to put into the mesh file for later reference. comment = 'Simple Sample Seeder Mesh' -- Debug output can be used to output prelimnary tree in restart format -- and this restart file can be converted to vtu format by Harvester -- debug = { debugMode = true, debugMesh = 'debug/' } -- Bounding cube: the root node of the octree, defining the complete universe, -- from which all elements are derived by recursive bisection. -- The origin is the corner from which on the cube is spanned with the given -- length in each direction. bounding_cube = { origin = { - 1.0 , - 1.0 , - 1.0 }, length = 2.0 } -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. minlevel = 6 -- *********************** Table of spatial objects *********************** -- -- Each spatial object is defined by an attribute and some geometric entity -- attached to this attribute. Attributes might be defined multiple times. -- Attributes are described by a kind (boundary, seed or refinement), a level -- and maybe further kind specific values, like a label for the boundary. spatial_object = { { -- Defining a domain boundary attribute = { kind = 'boundary' , -- or seed, refinement label = 'CornerPoint' , -- some label to identify the boundary -- condition }, geometry = { -- points created inside domain kind = 'canoND' , object = {{ origin = { - 1.0 , - 1.0 , - 1.0 } }, { origin = { 0.9 , 0.9 , 0.9 } } } } }, { -- Defining a domain boundary attribute = { kind = 'boundary' , -- or seed, refinement label = 'Inside' , -- some label to identify the boundary -- condition level = 1 -- level to refine this object with, -- default = 0 }, geometry = { kind = 'canoND' , object = {{ -- 2 more points created inside domain origin = { - 0.5 , - 0.5 , - 0.5 } }, { origin = { 0.0 , 0.0 , 0.5 } } } } }, { -- Defining a seed to identify the part of the computational domain in -- the universe cube. attribute = { kind = 'seed' }, geometry = { -- single point definition with a canoND object. kind = 'canoND' , object = { origin = { - 0.0 , - 0.0 , - 0.0 } } } } } -- end of spatial objects -- ************************************************************************ -- The image generated with multiple point obstacles from the above code: Example lua file is available at testsuite/point/seeder.lua","tags":"","url":"page/testsuite_tutorials/points.html"},{"title":"Special geometries – Seeder","text":"Seeder can create some special geometries. Currently it supports only one special geometry, spacer. spacer","tags":"","url":"page/testsuite_tutorials/special/index.html"},{"title":"Spacers – Seeder","text":"Spacers are defined by an two spacer filaments one along the length and \nother along the width. Each spacer filament is defined by the \\ref cylinders\nand distance between consecutive spacer filaments Valid definition: geometry = { kind = 'spacer' , object = { length = { origin = { 0.0 , 0.0 , 0.0 }, -- starting point of the spacer vec = { 1.0 , 0.0 , 0.0 }, - length and axis of first filament radius = 0.001 -- radius of the filament only_surface = true , -- If not defined default is set to false filament_gap = 0.02 , -- distance between filament }, width = { origin = { 0.0 , 0.0 , 0.0 } vec = { 0.0 , 0.0 , 1.0 }, radius = 0.001 , only_surface = true , -- If not defined default is set to false filament_gap = 0.02 , }, interwoven = true , --switch between interwoven and non-interwoven -- spacer generation } } -- single spacer The following seeder file is to generate mesh with spacer inside: -- This is the standard seeder configuration, that should document the possible -- and required configuration options. -- It should always run out of the box! -- ------------------------------------------------------------------------- -- -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Some comment, you might want to put into the mesh file for later reference. comment = 'Simple Sample Seeder Mesh' -- Debug output can be used to output prelimnary tree in restart format -- and this restart file can be converted to vtu format by Harvester debug = { debugMode = true , debugMesh = 'debug/' } -- Bounding cube: the root node of the octree, defining the complete universe, -- from which all elements are derived by recursive bisection. -- The origin is the corner from which on the cube is spanned with the given -- length in each direction. bounding_cube = { origin = { - 1.0 , - 1.0 , - 1.0 }, length = 2.0 } -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. minlevel = 6 -- *********************** Table of spatial objects *********************** -- -- Each spatial object is defined by an attribute and some geometric entity -- attached to this attribute. Attributes might be defined multiple times. -- Attributes are described by a kind (boundary, seed or refinement), a level -- and maybe further kind specific values, like a label for the boundary. -- Geometric objects might by right now: -- - canoND (point, line, plane or box) -- - STL -- - Sphere -- - Cylinder -- -- Periodic boundaries are special, spatial objects of this kind can only make -- use of geometric objects of the kind 'periodic'. spatial_object = { { -- Defining a domain boundary attribute = { kind = 'boundary' , -- or seed, refinement label = 'solid' , -- some label to identify the boundary -- condition level = 1 -- level to refine this object with, -- default = 0 }, -- Example for spacer geometry = { -- defining the geometry of the spacer kind = 'spacer' , object = { length = { vec = { 2.0 , 0.0 , 0.0 }, filament_gap = 1.0 , radius = 0.10 , origin = { - 1.0 , 0.0 , - 1.0 + 1.0 / 2 } }, width = { vec = { 0.0 , 0.0 , 2.0 }, filament_gap = 1.0 , radius = 0.10 , origin = { - 1.0 + 1.0 / 2 , 0.0 , - 1.0 } }, interwoven = true } } }, -- Example for rotated spacer --    geometry = { --      kind = 'spacer', --      object = { --        length = { --         -- rotated along x-axis 60 angle --          vec = {8.0*math.cos(60*math.pi/180),0.0,8.0*math.sin(60*math.pi/180)}, --          filament_gap = 1.0, --          radius = 0.1, --          origin = {-0.0,0.0,-4.0} --        }, --        width = { --         -- rotated along z-axis 30 angle --          vec = {8.0*math.sin(-30*math.pi/180),0.0,8.0*math.cos(-30*math.pi/180)}, --          filament_gap = 1.0, --          radius = 0.1, --          origin = {-0.0,0.0,-4.0} --        }, --          interwoven = false --      } --    } --  }, { -- Defining a seed to identify the part of the computational domain in -- the universe cube. attribute = { kind = 'seed' }, geometry = { -- single point definition with a canoND object. kind = 'canoND' , object = { origin = { - 0.0 , - 1.0 , - 1.0 } } } } } -- end of spatial objects -- ************************************************************************ -- Mesh generated with above seeder file: Example lua file is available at testsuite/spacer/seeder.lua .","tags":"","url":"page/testsuite_tutorials/special/spacer.html"},{"title":"Sphere – Seeder","text":"Spheres are defined by an origin and radius.\nSphere is considered to be solid as default i.e. all the cubes inside the\nsphere are marked as intersected cubes. \nIt is possible to created hollow spheres by setting only_surface = true ,\nit will mark only the cubes intersect with sphere surface as intersected\ncubes Valid definition: Single sphere geometry = { kind = 'sphere' , object = { origin = { 0.0 , 0.0 , 0.0 }, radius = 0.25 , only_surface = true , -- If not defined default is set to false } } Multiple sphere geometry = { kind = 'sphere' , object = { { origin = { 0.0 , 0.0 , 0.0 }, radius = 0.25 }, { origin = { - 2.0 , 0.0 , 0.0 }, radius = 0.25 } } } The following seeder file is to generate mesh with hollow sphere (hollow => only_surface=true ) inside: -- This is the standard seeder configuration, that should document the possible -- and required configuration options. -- It should always run out of the box! -- ------------------------------------------------------------------------- -- -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Some comment,you might want to put into the mesh file for later reference. comment = 'Simple Sample Seeder Mesh' -- Debug output can be used to output preliminary tree in restart format -- and this restart file can be converted to vtu format by Harvester debug = { debugMode = true , debugFiles = false , debugMesh = 'debug/' } -- Bounding cube: the root node of the octree, defining the complete universe, -- from which all elements are derived by recursive bisection. -- The origin is the corner from which on the cube is spanned with the given -- length in each direction. bounding_cube = { origin = { - 1.0 , - 1.0 , - 1.0 }, length = 2.0 } -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. minlevel = 5 -- *********************** Table of spatial objects *********************** -- -- Each spatial object is defined by an attribute and some geometric entity -- attached to this attribute. Attributes might be defined multiple times. -- Attributes are described by a kind (boundary, seed or refinement), a level -- and maybe further kind specific values, like a label for the boundary. -- Geometric objects might by right now: -- - canoND (point, line, plane or box) -- - STL -- - Sphere -- - Cylinder -- -- Periodic boundaries are special, spatial objects of this kind can only make -- use of geometric objects of the kind 'periodic'. spatial_object = { { -- Defining a domain boundary attribute = { kind = 'boundary' , -- or seed, refinement label = 'solid' , -- some label to identify the boundary -- condition level = 1 -- level to refine this object with, -- default = 0 }, -- Defining Geometry of the sphere geometry = { kind = 'sphere' , object = { { radius = 0.2 , origin = { 0.0 , 0.0 , 0.0 }, -- origin of the sphere only_surface = true -- Use only surface of the object? -- default is: false. } --       ,{ --        radius = 0.1, --        origin = {-1.0,0.0,0.0} --        } } } }, { -- Defining a seed to identify the part of the computational domain in -- the universe cube. attribute = { kind = 'seed' }, geometry = { -- single point definition with a canoND object. kind = 'canoND' , object = { origin = { - 0.0 , - 1.0 , - 1.0 } } -- origin of the cube for the defining the 'seed' } } } -- ------------------------------------------------------------------------ -- Mesh generated with hollow sphere by the seeder file: Cutview of mesh with hollow sphere: Cutview of mesh with solid sphere (solid => only_surface=false ): Example lua file is available at testsuite/sphere/seeder.lua","tags":"","url":"page/testsuite_tutorials/sphere.html"},{"title":"Triangle – Seeder","text":"Triangles are defined by three nodes. It is possible to define triangles\nas a geometry kind. Also, the planes and hollow boxes are converted to\ntriangles internally. Valid definition: Single triangle geometry = { kind = 'triangle' , object = { nodes = { -- triangle 1 { 0.0 , 0.0 , 0.5 }, -- node 1 { - 0.5 , - 0.5 , - 0.5 }, -- node 2 { 0.5 , - 0.5 , - 0.5 } -- node 3 } } } Multiple triangles geometry = { kind = 'triangle' , object = { { nodes = { -- triangle 1 { 0.0 , 0.0 , 0.5 }, -- node 1 { - 0.5 , - 0.5 , - 0.5 }, -- node 2 { 0.5 , - 0.5 , - 0.5 } -- node 3 } }, { nodes = { -- triangle 2 { 0.0 , 0.0 , 0.5 }, -- node 1 { - 0.5 , - 0.5 , - 0.5 }, -- node 2 { - 0.5 , 0.5 , - 0.5 } -- node 3 } } } } A pyramid has created with four triangles and a plane. The corresponding\nseeder code is given below: -- This is the standard seeder configuration, that should document the possible -- and required configuration options. -- It should always run out of the box! -- ------------------------------------------------------------------------- -- -- Location to write the mesh in. -- Note the trailing path seperator, needed, if all mesh files should be in a -- directory. This directory has to exist before running Seeder in this case! folder = 'mesh/' -- Some comment, you might want to put into the mesh file for later reference. comment = 'Simple Sample Seeder Mesh' -- Debug output can be used to output prelimnary tree in restart format -- and this restart file can be converted to vtu format by Harvester debug = { debugMode = true , debugMesh = 'debug/' } logging = { level = 3 } timing_file = 'timing.res' -- Bounding cube: the root node of the octree, defining the complete universe, -- from which all elements are derived by recursive bisection. -- The origin is the corner from which on the cube is spanned with the given -- length in each direction. bounding_cube = { origin = { - 1.0 , - 1.0 , - 1.0 }, length = 2.0 } -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. minlevel = 6 --smoothbounds = false --smoothlevels = true -- *********************** Table of spatial objects *********************** -- -- Each spatial object is defined by an attribute and some geometric entity -- attached to this attribute. Attributes might be defined multiple times. -- Attributes are described by a kind (boundary, seed or refinement), a level -- and maybe further kind specific values, like a label for the boundary. -- Geometric objects might by right now: -- - canoND (point, line, plane or box) -- - STL -- - Sphere -- - Cylinder -- -- Periodic boundaries are special, spatial objects of this kind can only make -- use of geometric objects of the kind 'periodic'. spatial_object = { { -- Defining a domain boundary attribute = { kind = 'boundary' , -- or seed, refinement label = 'solid' , -- some label to identify the boundary -- condition level = 1 , -- level to refine this object with, -- Distance refinement NOdistance_refine = { { radius = 0.2 , level_offset = 0 }, { radius = 0.5 , level_offset = - 1 } } -- default = 0 }, geometry = { -- Example for a triangle definition { -- Here: Pyramid is defined by 4 triangles kind = 'triangle' , object = { { nodes = { -- triangle 1 { 0.0 , 0.0 , 0.5 }, -- node 1 { - 0.5 , - 0.5 , - 0.5 }, -- node 2 { 0.5 , - 0.5 , - 0.5 } -- node 3 } }, { nodes = { -- triangle 2 { 0.0 , 0.0 , 0.5 }, -- node 1 { - 0.5 , - 0.5 , - 0.5 }, -- node 2 { - 0.5 , 0.5 , - 0.5 } -- node 3 } }, { nodes = { -- triangle 3 { 0.0 , 0.0 , 0.5 }, -- node 1 { - 0.5 , 0.5 , - 0.5 }, -- node 2 { 0.5 , 0.5 , - 0.5 } -- node 3 } }, { nodes = { -- triangle 4 { 0.0 , 0.0 , 0.5 }, -- node 1 { 0.5 , - 0.5 , - 0.5 }, -- node 2 { 0.5 , 0.5 , - 0.5 } -- node 3 } } } }, -- plane to close the pyramid bottom { kind = 'canoND' , object = { origin = { - 0.5 , - 0.5 , - 0.5 }, vec = { { 1.0 , 0.0 , 0.0 }, { 0.0 , 1.0 , 0.0 } } } } } }, { -- Defining a seed to identify the part of the computational domain in -- the universe cube. attribute = { kind = 'seed' }, geometry = { -- single point definition with a canoND object. kind = 'canoND' , object = { origin = { - 0.0 , - 1.0 , - 1.0 } } } } } -- end of spatial objects -- ************************************************************************ -- Mesh with pyramid generated by the seeder file:","tags":"","url":"page/testsuite_tutorials/triangle.html"}]}